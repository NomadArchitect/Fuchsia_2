// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![allow(dead_code)] // TODO(https://fxbug.dev/77068) remove after toolchain rolls again

use argh::FromArgs;
use heck::SnakeCase;
use proc_macro2::TokenStream;
use quote::{format_ident, quote};
use serde::Deserialize;
use serde_json::Value;
use std::{
    collections::BTreeMap,
    fs::File,
    io::{BufWriter, Write},
    path::PathBuf,
};
use syn::{
    Token,
    {punctuated::Punctuated, Ident},
};

/// generate a roundtrip test for dynfidl from a file with FIDL's JSON IR.
#[derive(Debug, FromArgs)]
struct Options {
    /// path to the FIDL JSON IR file to use for a round-trip test.
    #[argh(option)]
    input: PathBuf,

    /// output path for the generated Rust test library.
    #[argh(option)]
    output: PathBuf,

    /// path to a rustfmt binary for formatting generated tests
    #[argh(option)]
    rustfmt: PathBuf,

    /// list of types for which to generate round-trip tests
    #[argh(positional)]
    types: Vec<String>,
}

fn main() {
    let Options { input, output, rustfmt, types } = argh::from_env();
    let raw_ir = std::fs::read_to_string(&input).unwrap();
    let FidlIr { struct_declarations } = serde_json::from_str(&raw_ir).unwrap();

    let mut file_tokens = TokenStream::new();
    file_tokens.extend(quote! {
        use dynfidl::{Field, Structure};
        use fidl::encoding::{decode_persistent, encode_persistent, Persistable};
        use std::{cmp::PartialEq, fmt::Debug};

        #[track_caller]
        fn test_persistent_roundtrip<T: Debug + PartialEq + Persistable>(
            mut domain_value: T,
            structure: Structure,
        ) {
            let binding_encoded = encode_persistent(&mut domain_value).unwrap();
            let dynamic_encoded = structure.encode_persistent();
            assert_eq!(
                binding_encoded,
                dynamic_encoded,
                "encoded messages from bindings and dynfidl must match",
            );

            let domain_from_dynamic: T = decode_persistent(&dynamic_encoded[..]).unwrap();
            assert_eq!(
                domain_value,
                domain_from_dynamic,
                "domain value from dynamic encoding must match original",
            );
        }
    });

    let mut declarations = struct_declarations
        .into_iter()
        .map(|decl| (decl.name.clone(), decl))
        .filter(|(_, decl)| decl.can_be_encoded_by_dynfidl())
        .collect::<BTreeMap<String, StructDecl>>();

    // emit a test case for each requested type
    for name in types {
        let to_roundtrip = declarations.remove(&name).expect("provided type names must be in IR");
        to_roundtrip.emit_roundtrip_test(&mut file_tokens);
    }

    // any types still in the declarations from the IR were implicitly skipped by our args
    for (name, _) in declarations {
        let test_name = test_name(&name);
        file_tokens.extend(quote! {
            #[test]
            #[ignore]
            fn #test_name() {}
        })
    }

    {
        // put the output file in a block so it drops/closes before we try formatting
        let mut output_file = BufWriter::new(File::create(&output).unwrap());
        writeln!(
            output_file,
            "
            // Copyright 2021 The Fuchsia Authors. All rights reserved.
            // Use of this source code is governed by a BSD-style license that can be
            // found in the LICENSE file.

            // THIS FILE WAS AUTO-GENERATED BY $OUT_DIR/{}
            #![allow(non_snake_case)] // for easy copy/paste from test output to build config
            {}",
            file!(),
            file_tokens
        )
        .unwrap();
    }

    // format the output file so a human can read it from the out dir
    if !std::process::Command::new(rustfmt).arg(&output).status().unwrap().success() {
        panic!("rustfmt failed!");
    }
}

/// mangle a fidl type name into a test's name. we don't snake/lowercase the ident so that it's
/// easy to copy/paste from terminal output to the list of types to test
fn test_name(name: &str) -> Ident {
    format_ident!("roundtrip_persistent_{}", name.replace("/", "_"))
}

/// returns the rust module path for a given fidl type name
fn domain_value_module_path(name: &str) -> TokenStream {
    let mut parts = name.split("/");
    let library = format_ident!(
        "fidl_{}",
        parts
            .next()
            .expect("must have a library name before a slash")
            .to_snake_case()
            .to_lowercase()
    );
    let ty_name = format_ident!("{}", parts.next().expect("must have a type name after a slash"));
    quote!(#library :: #ty_name)
}

#[derive(Debug, Deserialize)]
struct FidlIr {
    struct_declarations: Vec<StructDecl>,
    // NOTE: the JSON IR has many other fields in the top-level object but we only list those
    // used for generating tests here.
}

#[derive(Debug, Deserialize)]
struct StructDecl {
    name: String,
    resource: bool,
    max_handles: Option<u32>,
    members: Vec<StructMember>,
    type_shape_v2: TypeShape,
    naming_context: Option<Vec<String>>,
    maybe_attributes: Option<Vec<Attribute>>,
    is_request_or_response: Option<bool>,
}

impl StructDecl {
    fn can_be_encoded_by_dynfidl(&self) -> bool {
        // we don't support encoding handles
        if self.resource || self.max_handles.map(|max| max > 0).unwrap_or_default() {
            return false;
        }

        // we don't support structs that are the protocol request/response type (yet?)
        if self.is_request_or_response.unwrap_or_default() {
            return false;
        }

        // check for attributes -- we don't know how to handle those at all
        if self.maybe_attributes.as_ref().map(|attrs| !attrs.is_empty()).unwrap_or_default() {
            return false;
        }

        // check each field for types we don't know how to layout
        for member in &self.members {
            if !member.can_be_encoded_by_dynfidl() {
                return false;
            }
        }

        true
    }

    fn emit_roundtrip_test(&self, tokens: &mut TokenStream) {
        let test_name = test_name(&self.name);
        let domain_value_path = domain_value_module_path(&self.name);

        let mut fidl_domain_fields = Punctuated::<_, Token![,]>::new();
        let mut field_inits = TokenStream::new();
        let mut dynfidl_fields = TokenStream::new();

        for member in &self.members {
            member.initializer(&mut field_inits);
            member.dynfidl_field(&mut dynfidl_fields);
            fidl_domain_fields.push(member.domain_field());
        }

        let fidl_domain_value = quote! { #domain_value_path { #fidl_domain_fields } };
        let dynfidl_structure = quote!(Structure::default() #dynfidl_fields);

        tokens.extend(quote! {
            #[test]
            fn #test_name() {
                #field_inits
                let domain_value = #fidl_domain_value;
                let dynfidl_structure = #dynfidl_structure;
                test_persistent_roundtrip(domain_value, dynfidl_structure);
            }
        })
    }
}

#[derive(Debug, Deserialize)]
struct StructMember {
    name: String,
    r#type: MemberType,
    field_shape_v2: FieldShape,
    maybe_attributes: Option<Vec<Attribute>>,
}

impl StructMember {
    fn can_be_encoded_by_dynfidl(&self) -> bool {
        if self.maybe_attributes.as_ref().map(|a| a.is_empty()).unwrap_or_default() {
            // we don't support attributes at all right now
            return false;
        }

        self.r#type.can_be_encoded_by_dynfidl()
    }

    fn field_name(&self) -> Ident {
        format_ident!("{}", self.name)
    }

    fn initializer(&self, tokens: &mut TokenStream) {
        let field_name = self.field_name();
        let field_init = self.r#type.initializer();
        tokens.extend(quote! { let #field_name = #field_init; });
    }

    fn domain_field(&self) -> TokenStream {
        let field_name = self.field_name();
        quote! { #field_name: #field_name.clone() }
    }

    fn dynfidl_field(&self, tokens: &mut TokenStream) {
        let field_variant = self.r#type.field_variant();
        let field_name = self.field_name();
        tokens.extend(quote! { .field(Field::#field_variant(#field_name)) });
    }
}

#[derive(Debug, Deserialize)]
struct Attribute {
    name: String,
    arguments: Vec<AttributeArg>,
}

#[derive(Debug, Deserialize)]
struct AttributeArg {
    name: String,
    r#type: Value,
    value: Value,
}

#[derive(Debug, Deserialize)]
#[serde(tag = "kind")]
enum MemberType {
    #[serde(rename = "array")]
    Array { element_count: u32, element_type: Box<MemberType>, type_shape_v2: TypeShape },

    #[serde(rename = "vector")]
    Vector {
        element_type: Box<MemberType>,
        nullable: bool,
        type_shape_v2: TypeShape,
        maybe_element_count: Option<u32>,
    },

    #[serde(rename = "string")]
    String { nullable: bool, type_shape_v2: TypeShape, maybe_element_count: Option<u32> },

    #[serde(rename = "handle")]
    Handle { nullable: bool, obj_type: u32, rights: u32, subtype: Value, type_shape_v2: TypeShape },

    #[serde(rename = "request")]
    Request { subtype: String, nullable: bool, type_shape_v2: TypeShape },

    #[serde(rename = "primitive")]
    Basic { subtype: BasicSubtype, nullable: Option<bool>, type_shape_v2: TypeShape },

    #[serde(rename = "identifier")]
    Identifier { identifier: String, nullable: bool, type_shape_v2: TypeShape },
}

impl MemberType {
    fn can_be_encoded_by_dynfidl(&self) -> bool {
        match self {
            Self::Array { .. }
            | Self::Vector { .. }
            | Self::String { .. }
            | Self::Handle { .. }
            | Self::Request { .. }
            | Self::Identifier { .. } => false,
            Self::Basic { subtype, nullable, .. } => {
                // we don't support nullable basics yet
                if nullable.unwrap_or_default() {
                    return false;
                }

                subtype.can_be_encoded_by_dynfidl()
            }
        }
    }

    fn initializer(&self) -> TokenStream {
        match self {
            Self::Array { .. }
            | Self::Vector { .. }
            | Self::String { .. }
            | Self::Handle { .. }
            | Self::Request { .. }
            | Self::Identifier { .. } => {
                unimplemented!("only basic values are currently supported")
            }
            Self::Basic { subtype, .. } => subtype.initializer(),
        }
    }

    fn field_variant(&self) -> TokenStream {
        match self {
            Self::Array { .. }
            | Self::Vector { .. }
            | Self::String { .. }
            | Self::Handle { .. }
            | Self::Request { .. }
            | Self::Identifier { .. } => {
                unimplemented!("only basic values are currently supported")
            }
            Self::Basic { subtype, .. } => subtype.field_variant(),
        }
    }
}

#[derive(Debug, Deserialize)]
#[serde(rename_all = "lowercase")]
enum BasicSubtype {
    Bool,
    UInt8,
    UInt16,
    UInt32,
    UInt64,
    Int8,
    Int16,
    Int32,
    Int64,
    Float32,
    Float64,
}

impl BasicSubtype {
    fn can_be_encoded_by_dynfidl(&self) -> bool {
        match self {
            Self::Float32 | Self::Float64 => false,
            _ => true,
        }
    }

    fn initializer(&self) -> TokenStream {
        match self {
            Self::Bool => quote!(true),
            Self::UInt8 => quote!(2u8),
            Self::UInt16 => quote!(3u16),
            Self::UInt32 => quote!(4u32),
            Self::UInt64 => quote!(5u64),
            Self::Int8 => quote!(6i8),
            Self::Int16 => quote!(7i16),
            Self::Int32 => quote!(8i32),
            Self::Int64 => quote!(9i64),
            _ => unimplemented!(),
        }
    }

    fn field_variant(&self) -> TokenStream {
        match self {
            Self::Bool => quote!(Bool),
            Self::UInt8 => quote!(UInt8),
            Self::UInt16 => quote!(UInt16),
            Self::UInt32 => quote!(UInt32),
            Self::UInt64 => quote!(UInt64),
            Self::Int8 => quote!(Int8),
            Self::Int16 => quote!(Int16),
            Self::Int32 => quote!(Int32),
            Self::Int64 => quote!(Int64),
            _ => unimplemented!(),
        }
    }
}

#[derive(Debug, Deserialize)]
struct TypeShape {
    alignment: u32,
    depth: u32,
    has_flexible_envelope: bool,
    has_padding: bool,
    inline_size: u32,
    max_handles: u32,
    max_out_of_line: u32,
}

#[derive(Debug, Deserialize)]
struct FieldShape {
    offset: u32,
    padding: u32,
}
