// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::Error,
    fidl_fuchsia_bluetooth_avrcp::{PeerManagerMarker, PeerManagerRequest, TargetHandlerProxy},
    fidl_fuchsia_bluetooth_component::{LifecycleMarker, LifecycleProxy, LifecycleState},
    fidl_fuchsia_media_sessions2::{DiscoveryMarker, DiscoveryRequest, SessionsWatcherProxy},
    fuchsia_async as fasync,
    fuchsia_component_test::{
        builder::{ComponentSource, RealmBuilder, RouteEndpoint},
        mock::{Mock, MockHandles},
    },
    fuchsia_zircon::DurationNum,
    futures::{channel::mpsc, SinkExt, StreamExt},
    realmbuilder_mock_helpers::mock_component,
    std::{collections::HashSet, iter::FromIterator},
    tracing::info,
};

/// AVRCP-Target component URL.
const AVRCP_TARGET_URL: &str =
    "fuchsia-pkg://fuchsia.com/bt-avrcp-target-smoke-test#meta/bt-avrcp-target.cm";

/// The different events generated by this test.
/// Note: In order to prevent channel-closure errors, the ClientEnd of the FIDL channels are
/// preserved. Each Proxy is wrapped in an Option<T> so that variants can be easily constructed
/// without the underlying FIDL channel.
enum Event {
    /// AVRCP service event.
    Avrcp(Option<TargetHandlerProxy>),
    /// Media service event.
    Media(Option<SessionsWatcherProxy>),
    /// Bluetooth Lifecycle event.
    Lifecycle(Option<LifecycleProxy>),
}

impl From<DiscoveryRequest> for Event {
    fn from(src: DiscoveryRequest) -> Self {
        // Only expect WatchSessions request in this integration test.
        match src {
            DiscoveryRequest::WatchSessions { session_watcher, .. } => {
                let watcher = session_watcher.into_proxy().unwrap();
                Self::Media(Some(watcher))
            }
            r => panic!("Expected Watch but got {:?}", r),
        }
    }
}

impl From<PeerManagerRequest> for Event {
    fn from(src: PeerManagerRequest) -> Self {
        // Only expect RegisterTargetHandler requests in this integration test.
        match src {
            PeerManagerRequest::RegisterTargetHandler { handler, responder, .. } => {
                let handler = handler.into_proxy().unwrap();
                responder.send(&mut Ok(())).expect("Failed to respond");
                Self::Avrcp(Some(handler))
            }
            r => panic!("Expected RegisterTargetHandler but got: {:?}", r),
        }
    }
}

/// Represents a fake AVRCP-TG client that requests the `fuchsia.bluetooth.component.Lifecycle`
/// service.
async fn mock_avrcp_target_client(
    mut sender: mpsc::Sender<Event>,
    handles: MockHandles,
) -> Result<(), Error> {
    let lifecycle_svc = handles.connect_to_service::<LifecycleMarker>()?;
    fasync::Task::local(async move {
        let lifecycle = lifecycle_svc.clone();
        loop {
            match lifecycle_svc.get_state().await.unwrap() {
                LifecycleState::Initializing => {}
                LifecycleState::Ready => break,
            }
            fasync::Timer::new(fasync::Time::after(1_i64.millis())).await;
        }
        info!("Client successfully connected to Lifecycle service");
        sender.send(Event::Lifecycle(Some(lifecycle))).await.expect("failed sending ack to test");
    })
    .detach();
    Ok(())
}

/// Tests that the v2 AVRCP-TG component has the correct topology and verifies that
/// it connects to the expected services.
#[fasync::run_singlethreaded(test)]
async fn avrcp_tg_v2_connects_to_avrcp_service() {
    fuchsia_syslog::init().unwrap();
    info!("Starting AVRCP-TG v2 smoke test...");

    let (sender, mut receiver) = mpsc::channel(2);
    let avrcp_tx = sender.clone();
    let media_tx = sender.clone();
    let fake_client_tx = sender.clone();

    let mut builder = RealmBuilder::new().await.expect("Failed to create test realm builder");
    // The v2 component under test.
    let _ = builder
        .add_component("avrcp-target", ComponentSource::url(AVRCP_TARGET_URL.to_string()))
        .await
        .expect("Failed adding avrcp-tg to topology");
    // Mock AVRCP component to receive PeerManager requests.
    let _ = builder
        .add_component(
            "fake-avrcp",
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = avrcp_tx.clone();
                    Box::pin(mock_component::<PeerManagerMarker, _>(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding avrcp mock to topology");
    // Mock MediaSession component to receive Discovery requests.
    let _ = builder
        .add_component(
            "fake-media-session",
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = media_tx.clone();
                    Box::pin(mock_component::<DiscoveryMarker, _>(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding media session mock to topology");
    // Mock AVRCP-Target client that will request the Lifecycle service.
    let _ = builder
        .add_eager_component(
            "fake-avrcp-target-client",
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = fake_client_tx.clone();
                    Box::pin(mock_avrcp_target_client(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding avrcp target client mock to topology");

    // Set up capabilities.
    let _ = builder
        .add_protocol_route::<PeerManagerMarker>(
            RouteEndpoint::component("fake-avrcp"),
            vec![RouteEndpoint::component("avrcp-target")],
        )
        .expect("Failed adding route for PeerManager service")
        .add_protocol_route::<DiscoveryMarker>(
            RouteEndpoint::component("fake-media-session"),
            vec![RouteEndpoint::component("avrcp-target")],
        )
        .expect("Failed adding route for Discovery service")
        .add_protocol_route::<LifecycleMarker>(
            RouteEndpoint::component("avrcp-target"),
            vec![RouteEndpoint::component("fake-avrcp-target-client")],
        )
        .expect("Failed adding route for Lifecycle service")
        .add_protocol_route::<fidl_fuchsia_logger::LogSinkMarker>(
            RouteEndpoint::AboveRoot,
            vec![
                RouteEndpoint::component("avrcp-target"),
                RouteEndpoint::component("fake-avrcp"),
                RouteEndpoint::component("fake-media-session"),
                RouteEndpoint::component("fake-avrcp-target-client"),
            ],
        )
        .expect("Failed adding LogSink route to test components");
    let test_topology = builder.build().create().await.unwrap();

    let _ = test_topology.root.connect_to_binder().unwrap();

    // If the routing is correctly configured, we expect three events: `bt-avrcp-target` connecting
    // to the PeerManager and Discovery services and the fake client connecting to the Lifecycle
    // service that is provided by bt-avrcp-target.
    let mut events = Vec::new();
    events.push(receiver.next().await.expect("Unexpected error waiting for 1st response"));
    events.push(receiver.next().await.expect("Unexpected error waiting for 2nd response"));
    events.push(receiver.next().await.expect("Unexpected error waiting for 3rd response"));
    let discriminants: HashSet<_> = HashSet::from_iter(events.iter().map(std::mem::discriminant));
    // Expect one request of each.
    let expected: HashSet<_> = HashSet::from_iter(
        vec![Event::Avrcp(None), Event::Media(None), Event::Lifecycle(None)]
            .iter()
            .map(std::mem::discriminant),
    );
    assert_eq!(discriminants, expected);

    info!("Finished AVRCP-TG smoke test");
}
