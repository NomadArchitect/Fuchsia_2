// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::Error,
    fidl::endpoints::DiscoverableService,
    fidl_fuchsia_bluetooth_a2dp as fidl_a2dp, fidl_fuchsia_bluetooth_avdtp as fidl_avdtp,
    fidl_fuchsia_bluetooth_avrcp as fidl_avrcp,
    fidl_fuchsia_bluetooth_bredr::{ProfileMarker, ProfileRequestStream},
    fidl_fuchsia_cobalt::{LoggerFactoryMarker, LoggerFactoryRequestStream},
    fidl_fuchsia_media::{
        AudioDeviceEnumeratorMarker, AudioDeviceEnumeratorRequestStream,
        SessionAudioConsumerFactoryMarker, SessionAudioConsumerFactoryRequestStream,
    },
    fidl_fuchsia_media_sessions2::{
        DiscoveryMarker, DiscoveryRequestStream, PublisherMarker, PublisherRequestStream,
    },
    fidl_fuchsia_mediacodec::{CodecFactoryMarker, CodecFactoryRequestStream},
    fidl_fuchsia_settings::{AudioMarker, AudioRequestStream},
    fidl_fuchsia_sysmem::{AllocatorMarker, AllocatorRequestStream},
    fidl_fuchsia_tracing_provider::{RegistryMarker, RegistryRequestStream},
    fuchsia_async as fasync,
    fuchsia_component::server::ServiceFs,
    fuchsia_component_test::{
        builder::{Capability, CapabilityRoute, ComponentSource, RealmBuilder, RouteEndpoint},
        mock::{Mock, MockHandles},
    },
    futures::{channel::mpsc, SinkExt, StreamExt},
    log::info,
    std::{collections::HashSet, iter::FromIterator},
};

/// A2DP component URL.
const A2DP_URL: &str = "fuchsia-pkg://fuchsia.com/bt-a2dp-smoke-test#meta/bt-a2dp-topology-fake.cm";

/// The different events generated by this test.
/// Note: In order to prevent the component under test from terminating, any FIDL request or
/// Proxy is preserved.
enum Event {
    Profile(Option<ProfileRequestStream>),
    Avdtp(Option<fidl_avdtp::PeerManagerProxy>),
    AudioMode(Option<fidl_a2dp::AudioModeProxy>),
    Avrcp(Option<fidl_avrcp::PeerManagerRequestStream>),
    Codec(Option<CodecFactoryRequestStream>),
    Registry(Option<RegistryRequestStream>),
    Session(Option<SessionAudioConsumerFactoryRequestStream>),
    AudioSettings(Option<AudioRequestStream>),
    Cobalt(Option<LoggerFactoryRequestStream>),
    MediaSession(Option<DiscoveryRequestStream>),
    MediaPublisher(Option<PublisherRequestStream>),
    AudioDevice(Option<AudioDeviceEnumeratorRequestStream>),
    Allocator(Option<AllocatorRequestStream>),
}

/// Represents a fake A2DP client that requests the `avdtp.PeerManager` and `a2dp.AudioMode` services.
async fn mock_a2dp_client(
    mut sender: mpsc::Sender<Event>,
    handles: MockHandles,
) -> Result<(), Error> {
    let peer_manager_svc = handles.connect_to_service::<fidl_avdtp::PeerManagerMarker>()?;
    sender.send(Event::Avdtp(Some(peer_manager_svc))).await.expect("failed sending ack to test");

    let audio_mode_svc = handles.connect_to_service::<fidl_a2dp::AudioModeMarker>()?;
    sender.send(Event::AudioMode(Some(audio_mode_svc))).await.expect("failed sending ack to test");
    Ok(())
}

/// The component mock that provides all the services that A2DP requires.
async fn mock_component(sender: mpsc::Sender<Event>, handles: MockHandles) -> Result<(), Error> {
    let mut fs = ServiceFs::new();
    let sender0 = sender.clone();
    let sender1 = sender.clone();
    let sender2 = sender.clone();
    let sender3 = sender.clone();
    let sender4 = sender.clone();
    let sender5 = sender.clone();
    let sender6 = sender.clone();
    let sender7 = sender.clone();
    let sender8 = sender.clone();
    let sender9 = sender.clone();
    let sender10 = sender.clone();
    fs.dir("svc")
        .add_fidl_service(move |req_stream: fidl_avrcp::PeerManagerRequestStream| {
            let mut sender = sender0.clone();
            fasync::Task::local(async move {
                info!("Received avrcp.PeerManager connection");
                sender.send(Event::Avrcp(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: ProfileRequestStream| {
            let mut sender = sender1.clone();
            fasync::Task::local(async move {
                info!("Received Profile connection");
                sender.send(Event::Profile(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: LoggerFactoryRequestStream| {
            let mut sender = sender2.clone();
            fasync::Task::local(async move {
                info!("Received cobalt LoggerFactory connection");
                sender.send(Event::Cobalt(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: AudioDeviceEnumeratorRequestStream| {
            let mut sender = sender3.clone();
            fasync::Task::local(async move {
                info!("Received AudioDeviceEnumerator connection");
                sender.send(Event::AudioDevice(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: SessionAudioConsumerFactoryRequestStream| {
            let mut sender = sender4.clone();
            fasync::Task::local(async move {
                info!("Received SessionAudioConsumerFactory connection");
                sender.send(Event::Session(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: PublisherRequestStream| {
            let mut sender = sender5.clone();
            fasync::Task::local(async move {
                info!("Received Publisher connection");
                sender.send(Event::MediaPublisher(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: CodecFactoryRequestStream| {
            let mut sender = sender6.clone();
            fasync::Task::local(async move {
                info!("Received CodecFactory connection");
                sender.send(Event::Codec(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: AudioRequestStream| {
            let mut sender = sender7.clone();
            fasync::Task::local(async move {
                info!("Received Audio connection");
                sender.send(Event::AudioSettings(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: AllocatorRequestStream| {
            let mut sender = sender8.clone();
            fasync::Task::local(async move {
                info!("Received Allocator connection");
                sender.send(Event::Allocator(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: RegistryRequestStream| {
            let mut sender = sender9.clone();
            fasync::Task::local(async move {
                info!("Received Registry connection");
                sender.send(Event::Registry(Some(req_stream))).await.expect("should send");
            })
            .detach()
        })
        .add_fidl_service(move |req_stream: DiscoveryRequestStream| {
            let mut sender = sender10.clone();
            fasync::Task::local(async move {
                info!("Received Discovery connection");
                sender.send(Event::MediaSession(Some(req_stream))).await.expect("should send");
            })
            .detach()
        });

    fs.serve_connection(handles.outgoing_dir.into_channel())?;
    fs.collect::<()>().await;

    Ok(())
}

/// Local name of the A2DP component in the Realm.
const A2DP_MONIKER: &str = "a2dp";
/// Local name of the A2DP client in the Realm.
const A2DP_CLIENT_MONIKER: &str = "fake-a2dp-client";
/// Local name of the component which provides services used by A2DP in the Realm.
const SERVICE_PROVIDER_MONIKER: &str = "fake-service-provider";

fn add_a2dp_dependency_route(builder: &mut RealmBuilder, capability: Capability) {
    builder
        .add_route(CapabilityRoute {
            capability,
            source: RouteEndpoint::component(SERVICE_PROVIDER_MONIKER),
            targets: vec![RouteEndpoint::component(A2DP_MONIKER)],
        })
        .expect("Failed adding route for service");
}

/// Tests that the v2 A2DP component has the correct topology and verifies that
/// it connects and provides the expected services.
#[fasync::run_singlethreaded(test)]
async fn a2dp_v2_component_topology() {
    fuchsia_syslog::init().unwrap();
    info!("Starting A2DP v2 smoke test...");

    let (sender, mut receiver) = mpsc::channel(0);
    let fake_client_tx = sender.clone();
    let service_tx = sender.clone();

    let mut builder = RealmBuilder::new().await.expect("Failed to create test realm builder");

    // The v2 component under test.
    builder
        .add_component(A2DP_MONIKER, ComponentSource::url(A2DP_URL.to_string()))
        .await
        .expect("Failed adding a2dp to topology");

    // Generic backend component that provides a slew of services that will be requested.
    builder
        .add_component(
            SERVICE_PROVIDER_MONIKER,
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = service_tx.clone();
                    Box::pin(mock_component(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding profile mock to topology");

    // Mock A2DP client that will request the PeerManager and AudioMode services
    // which are provided by the A2DP component.
    builder
        .add_eager_component(
            A2DP_CLIENT_MONIKER,
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = fake_client_tx.clone();
                    Box::pin(mock_a2dp_client(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding a2dp client mock to topology");

    // Capabilities provided by A2DP.
    builder
        .add_route(CapabilityRoute {
            capability: Capability::protocol(fidl_avdtp::PeerManagerMarker::SERVICE_NAME),
            source: RouteEndpoint::component(A2DP_MONIKER),
            targets: vec![RouteEndpoint::component(A2DP_CLIENT_MONIKER)],
        })
        .expect("Failed adding route for avdtp.PeerManager service")
        .add_route(CapabilityRoute {
            capability: Capability::protocol(fidl_a2dp::AudioModeMarker::SERVICE_NAME),
            source: RouteEndpoint::component(A2DP_MONIKER),
            targets: vec![RouteEndpoint::component(A2DP_CLIENT_MONIKER)],
        })
        .expect("Failed adding route for a2dp.AudioMode service");

    // Capabilities provided by the generic service provider component, which are consumed
    // by the A2DP component.
    add_a2dp_dependency_route(
        &mut builder,
        Capability::protocol(fidl_avrcp::PeerManagerMarker::SERVICE_NAME),
    );
    add_a2dp_dependency_route(&mut builder, Capability::protocol(ProfileMarker::SERVICE_NAME));
    add_a2dp_dependency_route(
        &mut builder,
        Capability::protocol(LoggerFactoryMarker::SERVICE_NAME),
    );
    add_a2dp_dependency_route(
        &mut builder,
        Capability::protocol(AudioDeviceEnumeratorMarker::SERVICE_NAME),
    );
    add_a2dp_dependency_route(
        &mut builder,
        Capability::protocol(SessionAudioConsumerFactoryMarker::SERVICE_NAME),
    );
    add_a2dp_dependency_route(&mut builder, Capability::protocol(PublisherMarker::SERVICE_NAME));
    add_a2dp_dependency_route(&mut builder, Capability::protocol(CodecFactoryMarker::SERVICE_NAME));
    add_a2dp_dependency_route(&mut builder, Capability::protocol(AudioMarker::SERVICE_NAME));
    add_a2dp_dependency_route(&mut builder, Capability::protocol(AllocatorMarker::SERVICE_NAME));
    add_a2dp_dependency_route(&mut builder, Capability::protocol(RegistryMarker::SERVICE_NAME));
    // Capability used by AVRCP Target, a child of A2DP. Route this service to A2DP to be
    // transitively routed to it.
    add_a2dp_dependency_route(&mut builder, Capability::protocol(DiscoveryMarker::SERVICE_NAME));

    // Logging service, used by all children in this test.
    builder
        .add_route(CapabilityRoute {
            capability: Capability::protocol("fuchsia.logger.LogSink"),
            source: RouteEndpoint::AboveRoot,
            targets: vec![
                RouteEndpoint::component(A2DP_MONIKER),
                RouteEndpoint::component(A2DP_CLIENT_MONIKER),
                RouteEndpoint::component(SERVICE_PROVIDER_MONIKER),
            ],
        })
        .expect("Failed adding LogSink route to test components");
    let _test_topology = builder.build().create().await.unwrap();

    // If the routing is correctly configured, we expect 14 events:
    //   - `bt-a2dp` connecting to the 10 services specified in its manifest.
    //   - `bt-avrcp-target` (a child of bt-a2dp) connecting to the `avrcp.PeerManager` and
    //     `Discovery` services.
    //   - `fake-a2dp-client` connecting to the `avdtp.PeerManager` and `AudioMode` services which
    //      are provided by `bt-a2dp`.
    let mut events = Vec::new();
    let expected_number_of_events = 14;
    for i in 0..expected_number_of_events {
        let msg = format!("Unexpected error waiting for {:?} event", i);
        events.push(receiver.next().await.expect(&msg));
    }
    assert_eq!(events.len(), expected_number_of_events);

    let discriminants: Vec<_> = events.iter().map(std::mem::discriminant).collect();

    // We expect two avrcp.PeerManager events since both bt-a2dp and bt-avrcp-target use it.
    assert_eq!(
        discriminants.iter().filter(|&&d| d == std::mem::discriminant(&Event::Avrcp(None))).count(),
        2
    );
    // There should be only one duplicate service request (avrcp.PeerManager), the rest
    // should be unique requests (13 in total).
    let discriminant_set: HashSet<_> = HashSet::from_iter(discriminants.iter());
    assert_eq!(discriminant_set.len(), 13);

    info!("Finished A2DP smoke test");
}
