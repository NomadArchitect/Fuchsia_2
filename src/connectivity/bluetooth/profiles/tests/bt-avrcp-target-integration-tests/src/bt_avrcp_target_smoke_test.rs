// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::Error,
    fidl_fuchsia_bluetooth_avrcp::{
        PeerManagerRequest, PeerManagerRequestStream, TargetHandlerProxy,
    },
    fidl_fuchsia_bluetooth_component::{LifecycleMarker, LifecycleProxy, LifecycleState},
    fidl_fuchsia_media_sessions2::{
        DiscoveryRequest, DiscoveryRequestStream, SessionsWatcherProxy,
    },
    fuchsia_async as fasync,
    fuchsia_component::server::ServiceFs,
    fuchsia_component_test::{
        builder::{Capability, CapabilityRoute, ComponentSource, RealmBuilder, RouteEndpoint},
        mock::{Mock, MockHandles},
    },
    fuchsia_zircon::DurationNum,
    futures::{channel::mpsc, SinkExt, StreamExt, TryStreamExt},
    log::info,
    std::{collections::HashSet, iter::FromIterator},
};

/// AVRCP-Target component URL.
const AVRCP_TARGET_URL: &str =
    "fuchsia-pkg://fuchsia.com/bt-avrcp-target-smoke-test#meta/bt-avrcp-target.cm";

/// The different events generated by this test.
/// Note: In order to prevent channel-closure errors, the ClientEnd of the FIDL channels are
/// preserved. Each Proxy is wrapped in an Option<T> so that variants can be easily constructed
/// without the underlying FIDL channel.
enum Event {
    /// AVRCP service event.
    Avrcp(Option<TargetHandlerProxy>),
    /// Media service event.
    Media(Option<SessionsWatcherProxy>),
    /// Bluetooth Lifecycle event.
    Lifecycle(Option<LifecycleProxy>),
}

/// Represents a fake AVRCP-TG client that requests the `fuchsia.bluetooth.component.Lifecycle`
/// service.
async fn mock_avrcp_target_client(
    mut sender: mpsc::Sender<Event>,
    handles: MockHandles,
) -> Result<(), Error> {
    let lifecycle_svc = handles.connect_to_service::<LifecycleMarker>()?;
    fasync::Task::local(async move {
        let lifecycle = lifecycle_svc.clone();
        loop {
            match lifecycle_svc.get_state().await.unwrap() {
                LifecycleState::Initializing => {}
                LifecycleState::Ready => break,
            }
            fasync::Timer::new(fasync::Time::after(1_i64.millis())).await;
        }
        info!("Client successfully connected to Lifecycle service");
        sender.send(Event::Lifecycle(Some(lifecycle))).await.expect("failed sending ack to test");
    })
    .detach();
    Ok(())
}

/// Simulates the main AVRCP component (bt-avrcp.cmx) by providing the `PeerManager` service.
async fn mock_avrcp_component(
    sender: mpsc::Sender<Event>,
    handles: MockHandles,
) -> Result<(), Error> {
    let mut fs = ServiceFs::new();
    fs.dir("svc").add_fidl_service(move |mut req_stream: PeerManagerRequestStream| {
        let mut sender_clone = sender.clone();
        fasync::Task::local(async move {
            while let Some(PeerManagerRequest::RegisterTargetHandler {
                handler, responder, ..
            }) = req_stream.try_next().await.expect("serving PeerManager stream failed")
            {
                info!("Received PeerManager service connection");
                let handler = handler.into_proxy().unwrap();
                responder.send(&mut Ok(())).expect("Failed to respond");
                sender_clone
                    .send(Event::Avrcp(Some(handler)))
                    .await
                    .expect("failed sending ack to test");
            }
        })
        .detach();
    });

    fs.serve_connection(handles.outgoing_dir.into_channel())?;
    fs.collect::<()>().await;
    Ok(())
}

/// Simulates the MediaSession component by providing the `Discovery` service.
async fn mock_media_session_component(
    sender: mpsc::Sender<Event>,
    handles: MockHandles,
) -> Result<(), Error> {
    let mut fs = ServiceFs::new();
    fs.dir("svc").add_fidl_service(move |mut req_stream: DiscoveryRequestStream| {
        let mut sender_clone = sender.clone();
        fasync::Task::local(async move {
            while let Some(DiscoveryRequest::WatchSessions { session_watcher, .. }) =
                req_stream.try_next().await.expect("serving PeerManager stream failed")
            {
                info!("Received MediaSession Discovery service connection");
                let stream = session_watcher.into_proxy().unwrap();
                sender_clone
                    .send(Event::Media(Some(stream)))
                    .await
                    .expect("failed sending ack to test");
            }
        })
        .detach();
    });

    fs.serve_connection(handles.outgoing_dir.into_channel())?;
    fs.collect::<()>().await;
    Ok(())
}

/// Tests that the v2 AVRCP-TG component has the correct topology and verifies that
/// it connects to the expected services.
#[fasync::run_singlethreaded(test)]
async fn avrcp_tg_v2_connects_to_avrcp_service() {
    fuchsia_syslog::init().unwrap();
    info!("Starting AVRCP-TG v2 smoke test...");

    let (sender, mut receiver) = mpsc::channel(2);
    let avrcp_tx = sender.clone();
    let media_tx = sender.clone();
    let fake_client_tx = sender.clone();

    let mut builder = RealmBuilder::new().await.expect("Failed to create test realm builder");
    // The v2 component under test.
    builder
        .add_component("avrcp-target", ComponentSource::url(AVRCP_TARGET_URL.to_string()))
        .await
        .expect("Failed adding avrcp-tg to topology");
    // Mock AVRCP component to receive PeerManager requests.
    builder
        .add_component(
            "fake-avrcp",
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = avrcp_tx.clone();
                    Box::pin(mock_avrcp_component(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding avrcp mock to topology");
    // Mock MediaSession component to receive Discovery requests.
    builder
        .add_component(
            "fake-media-session",
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = media_tx.clone();
                    Box::pin(mock_media_session_component(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding media session mock to topology");
    // Mock AVRCP-Target client that will request the Lifecycle service.
    builder
        .add_eager_component(
            "fake-avrcp-target-client",
            ComponentSource::Mock(Mock::new({
                move |mock_handles: MockHandles| {
                    let sender = fake_client_tx.clone();
                    Box::pin(mock_avrcp_target_client(sender, mock_handles))
                }
            })),
        )
        .await
        .expect("Failed adding avrcp target client mock to topology");

    // Set up capabilities.
    builder
        .add_route(CapabilityRoute {
            capability: Capability::protocol("fuchsia.bluetooth.avrcp.PeerManager"),
            source: RouteEndpoint::component("fake-avrcp"),
            targets: vec![RouteEndpoint::component("avrcp-target")],
        })
        .expect("Failed adding route for PeerManager service")
        .add_route(CapabilityRoute {
            capability: Capability::protocol("fuchsia.media.sessions2.Discovery"),
            source: RouteEndpoint::component("fake-media-session"),
            targets: vec![RouteEndpoint::component("avrcp-target")],
        })
        .expect("Failed adding route for Discovery service")
        .add_route(CapabilityRoute {
            capability: Capability::protocol("fuchsia.bluetooth.component.Lifecycle"),
            source: RouteEndpoint::component("avrcp-target"),
            targets: vec![RouteEndpoint::component("fake-avrcp-target-client")],
        })
        .expect("Failed adding route for Lifecycle service")
        .add_route(CapabilityRoute {
            capability: Capability::protocol("fuchsia.logger.LogSink"),
            source: RouteEndpoint::AboveRoot,
            targets: vec![
                RouteEndpoint::component("avrcp-target"),
                RouteEndpoint::component("fake-avrcp"),
                RouteEndpoint::component("fake-media-session"),
                RouteEndpoint::component("fake-avrcp-target-client"),
            ],
        })
        .expect("Failed adding LogSink route to test components");
    let _test_topology = builder.build().create().await.unwrap();

    // If the routing is correctly configured, we expect three events: `bt-avrcp-target` connecting
    // to the PeerManager and Discovery services and the fake client connecting to the Lifecycle
    // service that is provided by bt-avrcp-target.
    let mut events = Vec::new();
    events.push(receiver.next().await.expect("Unexpected error waiting for 1st response"));
    events.push(receiver.next().await.expect("Unexpected error waiting for 2nd response"));
    events.push(receiver.next().await.expect("Unexpected error waiting for 3rd response"));
    let discriminants: HashSet<_> = HashSet::from_iter(events.iter().map(std::mem::discriminant));
    // Expect one request of each.
    let expected: HashSet<_> = HashSet::from_iter(
        vec![Event::Avrcp(None), Event::Media(None), Event::Lifecycle(None)]
            .iter()
            .map(std::mem::discriminant),
    );
    assert_eq!(discriminants, expected);

    info!("Finished AVRCP-TG smoke test");
}
