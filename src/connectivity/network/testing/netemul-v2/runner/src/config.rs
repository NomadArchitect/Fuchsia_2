// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use anyhow::{anyhow, Context as _};
use fidl_fuchsia_data as fdata;
use fidl_fuchsia_net_ext as fnet_ext;
use fidl_fuchsia_netemul as fnetemul;
use fidl_fuchsia_netemul_network as fnetemul_network;
use log::{debug, info};
use std::{
    collections::{hash_map, HashMap, HashSet},
    str::FromStr,
};

#[derive(serde::Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub(crate) struct Network {
    name: String,
    endpoints: Vec<Endpoint>,
}

#[derive(serde::Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub(crate) struct Endpoint {
    name: String,
    mac: Option<fnet_ext::MacAddress>,
    #[serde(default = "Endpoint::default_mtu")]
    mtu: u16,
    #[serde(default = "Endpoint::default_link_up")]
    up: bool,
    #[serde(default)]
    backing: EndpointBacking,
}

impl Endpoint {
    const fn default_mtu() -> u16 {
        netemul::DEFAULT_MTU
    }

    const fn default_link_up() -> bool {
        true
    }
}

#[derive(serde::Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields, rename_all = "snake_case")]
pub(crate) enum EndpointBacking {
    Ethertap,
    NetworkDevice,
}

impl Default for EndpointBacking {
    fn default() -> Self {
        Self::Ethertap
    }
}

impl From<EndpointBacking> for fnetemul_network::EndpointBacking {
    fn from(backing: EndpointBacking) -> Self {
        match backing {
            EndpointBacking::Ethertap => Self::Ethertap,
            EndpointBacking::NetworkDevice => Self::NetworkDevice,
        }
    }
}

#[derive(serde::Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub(crate) struct Netstack {
    name: String,
    interfaces: Vec<Interface>,
}

#[derive(serde::Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
pub(crate) struct Interface {
    name: String,
    #[serde(default)]
    without_autogenerated_addresses: bool,
    #[serde(deserialize_with = "deserialize_vec_from_str")]
    static_ips: Vec<fnet_ext::Subnet>,
    #[serde(default)]
    enable_dhcp: bool,
    #[serde(default, deserialize_with = "deserialize_from_str")]
    gateway: Option<fnet_ext::IpAddress>,
}

fn deserialize_vec_from_str<'de, D, T>(deserializer: D) -> Result<Vec<T>, D::Error>
where
    D: serde::Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    let v = <Vec<String> as serde::Deserialize>::deserialize(deserializer)?;
    v.into_iter()
        .map(|s| T::from_str(&s))
        .collect::<Result<Vec<_>, _>>()
        .map_err(serde::de::Error::custom)
}

fn deserialize_from_str<'de, D, T>(deserializer: D) -> Result<Option<T>, D::Error>
where
    D: serde::Deserializer<'de>,
    T: FromStr,
    <T as FromStr>::Err: std::fmt::Display,
{
    let s = <Option<String> as serde::Deserialize>::deserialize(deserializer)?;
    s.map(|s| T::from_str(&s).map_err(serde::de::Error::custom)).transpose()
}

// Represents a configuration that has been deserialized but not yet validated.
//
// To produce a valid `Config`, pass an `UnvalidatedConfig` to
// `Config::validate`.
#[derive(serde::Deserialize, Debug, PartialEq)]
#[serde(deny_unknown_fields)]
struct UnvalidatedConfig {
    networks: Vec<Network>,
    netstacks: Vec<Netstack>,
}

#[derive(Debug, PartialEq)]
pub(crate) struct Config {
    networks: Vec<Network>,
    netstacks: Vec<Netstack>,
}

#[derive(thiserror::Error, Debug, PartialEq)]
pub(crate) enum Error {
    #[error("duplicate network `{0}`, network names must be unique")]
    DuplicateNetwork(String),
    #[error("duplicate netstack `{0}`, netstack names must be unique")]
    DuplicateNetstack(String),
    #[error("duplicate endpoint `{0}`, endpoint names must be unique")]
    DuplicateEndpoint(String),
    #[error("endpoint `{0}` assigned to a netstack multiple times")]
    EndpointAssignedMultipleTimes(String),
    #[error("unknown endpoint `{0}`, must be declared on a network")]
    UnknownEndpoint(String),
}

impl UnvalidatedConfig {
    fn validate(self) -> Result<Config, Error> {
        let Self { networks, netstacks } = &self;

        let mut network_names = HashSet::new();
        let mut installed_endpoints = HashMap::new();
        let mut netstack_names = HashSet::new();

        for Network { name, endpoints } in networks {
            if !network_names.insert(name) {
                return Err(Error::DuplicateNetwork(name.to_string()));
            }
            for Endpoint { name, .. } in endpoints {
                if let Some(_) = installed_endpoints.insert(name, false) {
                    return Err(Error::DuplicateEndpoint(name.to_string()));
                }
            }
        }

        for Netstack { name, interfaces } in netstacks {
            if !netstack_names.insert(name) {
                return Err(Error::DuplicateNetstack(name.to_string()));
            }
            for Interface { name, .. } in interfaces {
                match installed_endpoints.entry(&name) {
                    hash_map::Entry::Occupied(mut entry) => {
                        if *entry.get() {
                            return Err(Error::EndpointAssignedMultipleTimes(name.to_string()));
                        } else {
                            *entry.get_mut() = true;
                        }
                    }
                    hash_map::Entry::Vacant(_) => {
                        return Err(Error::UnknownEndpoint(name.to_string()));
                    }
                }
            }
        }

        let Self { networks, netstacks } = self;
        Ok(Config { networks, netstacks })
    }
}

impl FromStr for Config {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let config: UnvalidatedConfig = serde_json::from_str(s).context("deserializing config")?;
        config.validate().context("validating config")
    }
}

const NETWORK_CONFIG_PROPERTY_NAME: &str = "network_config";

/// A handle to the virtual network environment created for the test.
///
/// This encodes the lifetime of the network environment, as the netemul sandbox
/// and any networks or endpoints it contains are garbage-collected when the
/// client end of their control channel is dropped.
pub(crate) struct NetworkEnvironment {
    _sandbox: netemul::TestSandbox,
    _networks: HashMap<String, fnetemul_network::NetworkProxy>,
    _endpoints: HashMap<String, fnetemul_network::EndpointProxy>,
}

impl Config {
    /// Loads the virtual network configuration that the test should be run in.
    ///
    /// The configuration should be a JSON file available in the package directory
    /// at `pkg_dir`, and the filepath is specified in `program`.
    pub(crate) async fn load_from_program(
        program: fdata::Dictionary,
        pkg_dir: &fidl_fuchsia_io::DirectoryProxy,
    ) -> Result<Self, anyhow::Error> {
        let fdata::Dictionary { entries, .. } = program;

        // TODO(https://fxbug.dev/95219): read the configuration directly from the
        // `program` section rather than from a packaged config file, once the CML
        // schema supports it.
        let network_config = entries
            .context("`entries` field not set in program")?
            .into_iter()
            .find_map(|fdata::DictionaryEntry { key, value }| {
                (key == NETWORK_CONFIG_PROPERTY_NAME).then(|| value)
            })
            .with_context(|| format!("`{}` missing in program", NETWORK_CONFIG_PROPERTY_NAME))?
            .context("missing value for network configuration property")?;

        let network_config_path = match *network_config {
            fdata::DictionaryValue::Str(path) => Ok(path),
            fdata::DictionaryValue::StrVec(vec) => Err(anyhow!(
                "`{}` should be a single filepath; got a list: {:?}",
                NETWORK_CONFIG_PROPERTY_NAME,
                vec
            )),
            other => {
                Err(anyhow::anyhow!("encountered unknown DictionaryValue variant: {:?}", other))
            }
        }?;

        let file = io_util::open_file(
            pkg_dir,
            std::path::Path::new(&network_config_path),
            fidl_fuchsia_io::OPEN_RIGHT_READABLE,
        )
        .with_context(|| format!("opening network config file at {}", network_config_path))?;
        let contents =
            io_util::file::read_to_string(&file).await.context("reading network config file")?;

        contents.parse()
    }

    /// Applies the virtual network configuration.
    ///
    /// A netemul sandbox is used to create virtual networks and endpoints, and the
    /// netstacks to be configured are connected to with `connect_to_netstack`.
    pub(crate) async fn apply<F>(
        self,
        mut connect_to_netstack: F,
    ) -> Result<NetworkEnvironment, anyhow::Error>
    where
        F: FnMut(String) -> Result<fnetemul::ConfigurableNetstackProxy, anyhow::Error>,
    {
        info!("configuring environment for test: {:#?}", self);
        let Self { networks, netstacks } = self;

        // Create the networks and endpoints in a netemul sandbox.
        let sandbox = netemul::TestSandbox::new().context("create test sandbox")?;
        let mut network_handles = HashMap::new();
        let mut endpoint_handles = HashMap::new();
        for Network { name, endpoints } in networks {
            let network = sandbox
                .create_network(name.clone())
                .await
                .with_context(|| format!("create network `{}`", name))?;
            for Endpoint { name, mac, mtu, up, backing } in endpoints {
                let endpoint = network
                    .create_endpoint_with(
                        name.clone(),
                        fnetemul_network::EndpointConfig {
                            mac: mac.map(Into::into).map(Box::new),
                            mtu,
                            backing: backing.into(),
                        },
                    )
                    .await
                    .with_context(|| format!("create endpoint `{}`", name))?;
                if up {
                    endpoint.set_link_up(true).await.context("set link up")?;
                }
                assert!(endpoint_handles.insert(name, endpoint.into_proxy()).is_none());
            }
            assert!(network_handles.insert(name, network.into_proxy()).is_none());
        }

        // Configure the netstacks.
        for Netstack { name, interfaces } in netstacks {
            debug!("configuring netstack `{}`", name);
            let netstack = connect_to_netstack(name).context("connect to configurable netstack")?;

            for Interface {
                name,
                without_autogenerated_addresses,
                static_ips,
                enable_dhcp,
                gateway,
            } in interfaces
            {
                debug!("configuring interface `{}` with static IPs {:?}", name, static_ips);
                let device = endpoint_handles
                    .get(&name)
                    .with_context(|| format!("could not find endpoint `{}`", name))?
                    .get_device()
                    .await
                    .with_context(|| format!("retrieve device from test endpoint `{}`", name))?;
                let options = fnetemul::InterfaceOptions {
                    name: Some(name.to_string()),
                    device: Some(device),
                    without_autogenerated_addresses: Some(without_autogenerated_addresses),
                    static_ips: Some(static_ips.into_iter().map(Into::into).collect()),
                    enable_dhcp: Some(enable_dhcp),
                    gateway: gateway.map(Into::into),
                    ..fnetemul::InterfaceOptions::EMPTY
                };
                netstack
                    .configure_interface(options)
                    .await
                    .context("call configure interface")?
                    .map_err(|e| anyhow!("error configuring netstack: {:?}", e))?;
            }
        }

        Ok(NetworkEnvironment {
            _sandbox: sandbox,
            _networks: network_handles,
            _endpoints: endpoint_handles,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use assert_matches::assert_matches;
    use futures::{channel::mpsc, StreamExt as _, TryStreamExt as _};
    use net_declare::{fidl_ip, fidl_mac, fidl_subnet};
    use test_case::test_case;

    const LOCAL_NETSTACK: &str = "local";
    const REMOTE_NETSTACK: &str = "remote";

    fn example_config() -> Config {
        Config {
            netstacks: vec![
                Netstack {
                    name: LOCAL_NETSTACK.to_string(),
                    interfaces: vec![
                        Interface {
                            name: "local-ep1".to_string(),
                            without_autogenerated_addresses: true,
                            static_ips: vec![fidl_subnet!("192.168.0.2/24").into()],
                            enable_dhcp: false,
                            gateway: Some(fidl_ip!("192.168.1.1").into()),
                        },
                        Interface {
                            name: "local-ep2".to_string(),
                            without_autogenerated_addresses: false,
                            static_ips: vec![fidl_subnet!("192.168.0.3/24").into()],
                            enable_dhcp: false,
                            gateway: None,
                        },
                    ],
                },
                Netstack {
                    name: REMOTE_NETSTACK.to_string(),
                    interfaces: vec![Interface {
                        name: "remote-ep".to_string(),
                        without_autogenerated_addresses: false,
                        static_ips: vec![fidl_subnet!("192.168.0.1/24").into()],
                        enable_dhcp: false,
                        gateway: None,
                    }],
                },
            ],
            networks: vec![Network {
                name: "net".to_string(),
                endpoints: vec![
                    Endpoint {
                        name: "local-ep1".to_string(),
                        mac: Some(fidl_mac!("aa:bb:cc:dd:ee:ff").into()),
                        mtu: 999,
                        up: false,
                        backing: EndpointBacking::NetworkDevice,
                    },
                    Endpoint {
                        name: "local-ep2".to_string(),
                        mac: None,
                        mtu: Endpoint::default_mtu(),
                        up: Endpoint::default_link_up(),
                        backing: Default::default(),
                    },
                    Endpoint {
                        name: "remote-ep".to_string(),
                        mac: None,
                        mtu: Endpoint::default_mtu(),
                        up: Endpoint::default_link_up(),
                        backing: Default::default(),
                    },
                ],
            }],
        }
    }

    #[test]
    fn valid_config() {
        let file = r#"
{
    "netstacks": [
        {
            "name": "local",
            "interfaces": [
                {
                    "name": "local-ep1",
                    "without_autogenerated_addresses": true,
                    "static_ips": [ "192.168.0.2/24" ],
                    "enable_dhcp": false,
                    "gateway": "192.168.1.1"
                },
                {
                    "name": "local-ep2",
                    "static_ips": [ "192.168.0.3/24" ]
                }
            ]
        },
        {
            "name": "remote",
            "interfaces": [
                {
                    "name": "remote-ep",
                    "static_ips": [ "192.168.0.1/24" ]
                }
            ]
        }
    ],
    "networks": [
        {
            "name": "net",
            "endpoints": [
                {
                    "name": "local-ep1",
                    "mac": "aa:bb:cc:dd:ee:ff",
                    "mtu": 999,
                    "up": false,
                    "backing": "network_device"
                },
                {
                    "name": "local-ep2"
                },
                {
                    "name": "remote-ep"
                }
            ]
        }
    ]
}
"#;

        let config: Config = file.parse().expect("deserialize network config");
        assert_eq!(config, example_config());
    }

    #[test_case(r#"{ "netstacks": [] }"#; "missing required field `networks`")]
    #[test_case(
        r#"{
            "netstacks": [],
            "networks": [],
            "endpoints": []
        }"#;
        "unknown field `endpoints`"
    )]
    #[test_case(
        r#"{
            "netstacks": [],
            "networks": [
                {
                    "name": "net",
                    "endpoints": [
                        {
                            "name": "ep",
                            "mtu": 65536
                        }
                    ]
                }
            ]
        }"#;
        "invalid MTU (larger than `u16::MAX`)"
    )]
    fn invalid_parse(s: &str) {
        assert_matches!(s.parse::<Config>(), Err(_));
    }

    #[test_case(
        UnvalidatedConfig {
            netstacks: vec![
                Netstack {
                    name: "netstack".to_string(),
                    interfaces: vec![
                        Interface {
                            name: "ep".to_string(),
                            without_autogenerated_addresses: false,
                            static_ips: vec![],
                            enable_dhcp: false,
                            gateway: None,
                        },
                    ],
                },
            ],
            networks: vec![],
        },
        Error::UnknownEndpoint("ep".to_string());
        "netstack interfaces must be declared as endpoints on a network"
    )]
    #[test_case(
        UnvalidatedConfig {
            netstacks: vec![
                Netstack {
                    name: "netstack".to_string(),
                    interfaces: vec![],
                },
                Netstack {
                    name: "netstack".to_string(),
                    interfaces: vec![],
                },
            ],
            networks: vec![],
        },
        Error::DuplicateNetstack("netstack".to_string());
        "netstack names must be unique"
    )]
    #[test_case(
        UnvalidatedConfig {
            netstacks: vec![],
            networks: vec![
                Network {
                    name: "net".to_string(),
                    endpoints: vec![],
                },
                Network {
                    name: "net".to_string(),
                    endpoints: vec![],
                },
            ],
        },
        Error::DuplicateNetwork("net".to_string());
        "network names must be unique"
    )]
    #[test_case(
        UnvalidatedConfig {
            netstacks: vec![],
            networks: vec![
                Network {
                    name: "net".to_string(),
                    endpoints: vec![
                        Endpoint {
                            name: "ep".to_string(),
                            mac: None,
                            mtu: Endpoint::default_mtu(),
                            up: Endpoint::default_link_up(),
                            backing: Default::default(),
                        },
                        Endpoint {
                            name: "ep".to_string(),
                            mac: None,
                            mtu: Endpoint::default_mtu(),
                            up: Endpoint::default_link_up(),
                            backing: Default::default(),
                        },
                    ],
                },
            ],
        },
        Error::DuplicateEndpoint("ep".to_string());
        "endpoint names must be unique"
    )]
    #[test_case(
        UnvalidatedConfig {
            netstacks: vec![
                Netstack {
                    name: "ns1".to_string(),
                    interfaces: vec![
                        Interface {
                            name: "ep".to_string(),
                            without_autogenerated_addresses: false,
                            static_ips: vec![],
                            enable_dhcp: false,
                            gateway: None,
                        },
                    ],
                },
                Netstack {
                    name: "ns2".to_string(),
                    interfaces: vec![
                        Interface {
                            name: "ep".to_string(),
                            without_autogenerated_addresses: false,
                            static_ips: vec![],
                            enable_dhcp: false,
                            gateway: None,
                        },
                    ],
                },
            ],
            networks: vec![
                Network {
                    name: "net".to_string(),
                    endpoints: vec![
                        Endpoint {
                            name: "ep".to_string(),
                            mac: None,
                            mtu: Endpoint::default_mtu(),
                            up: Endpoint::default_link_up(),
                            backing: Default::default(),
                        },
                    ],
                },
            ],
        },
        Error::EndpointAssignedMultipleTimes("ep".to_string());
        "endpoints may only be assigned once to a single netstack"
    )]
    fn invalid_config(config: UnvalidatedConfig, error: Error) {
        assert_eq!(config.validate(), Err(error));
    }

    async fn expect_incoming_requests(
        rx: &mut mpsc::UnboundedReceiver<(String, fnetemul::ConfigurableNetstackRequestStream)>,
        expected_netstack: &str,
        expected_configs: Vec<Interface>,
    ) {
        let (netstack, mut stream) =
            rx.next().await.expect("no connection requests for mock netstack");
        assert_eq!(
            netstack, expected_netstack,
            "expected request for netstack '{}', got '{}'",
            expected_netstack, netstack
        );
        for expected_config in expected_configs {
            let fnetemul::ConfigurableNetstackRequest::ConfigureInterface { options, responder } =
                stream
                    .next()
                    .await
                    .expect("expected request not received by mock configurable netstack")
                    .expect("FIDL error on request");
            let fnetemul::InterfaceOptions {
                name,
                without_autogenerated_addresses,
                static_ips,
                enable_dhcp,
                gateway,
                device: _,
                ..
            } = options;
            assert_eq!(
                Interface {
                    name: name.expect("missing interface name"),
                    without_autogenerated_addresses: without_autogenerated_addresses
                        .unwrap_or_default(),
                    static_ips: static_ips
                        .unwrap_or_default()
                        .into_iter()
                        .map(Into::into)
                        .collect(),
                    enable_dhcp: enable_dhcp.unwrap_or_default(),
                    gateway: gateway.map(Into::into),
                },
                expected_config
            );
            responder.send(&mut Ok(())).expect("send response");
        }
        let remaining = stream
            .map_ok(
                |fnetemul::ConfigurableNetstackRequest::ConfigureInterface {
                     options,
                     responder: _,
                 }| options,
            )
            .try_collect::<Vec<_>>()
            .await
            .expect("collect remaining requests");
        assert_eq!(remaining, vec![]);
    }

    #[fuchsia_async::run_singlethreaded(test)]
    async fn configurable_netstack() {
        diagnostics_log::init!();

        let (tx, mut rx) = mpsc::unbounded();
        let configure_environment = async {
            example_config()
                .apply(|name| {
                    let (proxy, server_end) =
                        fidl::endpoints::create_proxy::<fnetemul::ConfigurableNetstackMarker>()
                            .context("create proxy")?;
                    let stream =
                        server_end.into_stream().context("server end into request stream")?;
                    tx.unbounded_send((name, stream))
                        .expect("request stream receiver should not be closed");
                    Ok(proxy)
                })
                .await
                .expect("configure network environment for test")
        };
        let mock_service = async {
            // Expect netstacks to be configured in the order in which they're declared: the
            // "local" netstack first and "remote" second. The same order applies to the
            // interfaces that are installed in the netstacks.
            expect_incoming_requests(
                &mut rx,
                LOCAL_NETSTACK,
                vec![
                    Interface {
                        name: "local-ep1".to_string(),
                        without_autogenerated_addresses: true,
                        static_ips: vec![fidl_subnet!("192.168.0.2/24").into()],
                        enable_dhcp: false,
                        gateway: Some(fidl_ip!("192.168.1.1").into()),
                    },
                    Interface {
                        name: "local-ep2".to_string(),
                        without_autogenerated_addresses: false,
                        static_ips: vec![fidl_subnet!("192.168.0.3/24").into()],
                        enable_dhcp: false,
                        gateway: None,
                    },
                ],
            )
            .await;
            expect_incoming_requests(
                &mut rx,
                REMOTE_NETSTACK,
                vec![Interface {
                    name: "remote-ep".to_string(),
                    without_autogenerated_addresses: false,
                    static_ips: vec![fidl_subnet!("192.168.0.1/24").into()],
                    enable_dhcp: false,
                    gateway: None,
                }],
            )
            .await;
        };
        let (NetworkEnvironment { _sandbox: sandbox, _networks, _endpoints }, ()) =
            futures::future::join(configure_environment, mock_service).await;

        let network_manager = sandbox.get_network_manager().expect("get network manager");
        let networks = network_manager.list_networks().await.expect("list virtual networks");
        assert_eq!(networks, vec!["net".to_string()]);
        let endpoint_manager = sandbox.get_endpoint_manager().expect("get endpoint manager");
        let mut endpoints =
            endpoint_manager.list_endpoints().await.expect("list virtual endpoints");
        endpoints.sort();
        assert_eq!(
            endpoints,
            vec!["local-ep1".to_string(), "local-ep2".to_string(), "remote-ep".to_string()],
        );
    }
}
