// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#![cfg(test)]

use configurable_netstack_test::{server_ips, Bus, CLIENT_NAME, REQUEST, RESPONSE, SERVER_NAME};
use fidl_fuchsia_net as fnet;
use fidl_fuchsia_net_debug as fnet_debug;
use fidl_fuchsia_net_ext as fnet_ext;
use fidl_fuchsia_net_interfaces as fnet_interfaces;
use fidl_fuchsia_net_interfaces_ext as fnet_interfaces_ext;
use fidl_fuchsia_net_stack as fnet_stack;
use fuchsia_component::client::connect_to_protocol;
use futures_util::StreamExt as _;
use net_declare::{fidl_ip, fidl_mac};
use std::{
    collections::HashMap,
    io::{Read as _, Write as _},
};

#[fuchsia_async::run_singlethreaded(test)]
async fn connect_to_server() {
    Bus::subscribe(CLIENT_NAME).wait_for_client(SERVER_NAME).await;

    for addr in server_ips() {
        let mut stream = std::net::TcpStream::connect(&addr).expect("connect to server");
        let request = REQUEST.as_bytes();
        assert_eq!(stream.write(request).expect("write to socket"), request.len());
        stream.flush().expect("flush stream");

        let mut buffer = [0; 512];
        let read = stream.read(&mut buffer).expect("read from socket");
        let response = String::from_utf8_lossy(&buffer[0..read]);
        assert_eq!(response, RESPONSE, "got unexpected response from server: {}", response);
    }
}

const MAC_ADDR: fnet::MacAddress = fidl_mac!("aa:bb:cc:dd:ee:ff");

#[fuchsia_async::run_singlethreaded(test)]
async fn without_autogenerated_addresses() {
    let state = connect_to_protocol::<fnet_interfaces::StateMarker>().expect("connect to protocol");
    let stream = fnet_interfaces_ext::event_stream_from_state(&state)
        .expect("event stream from interfaces state");
    let interfaces = fnet_interfaces_ext::existing(stream, HashMap::new())
        .await
        .expect("list existing interfaces")
        .into_values();
    let debug = connect_to_protocol::<fnet_debug::InterfacesMarker>().expect("connect to protocol");

    // Find the interface that corresponds to `MAC_ADDR` by querying
    // `fuchsia.net.debug/Interfaces.GetMac` with the ID of each existing interface.
    //
    // Once we've found the matching interface, retrieve its IPv4 and link-local
    // IPv6 addresses to ensure any auto-generated addresses were removed by the
    // netemul runner during test setup.
    let addresses = futures_util::stream::iter(interfaces).filter_map(
        |fnet_interfaces_ext::Properties { id, addresses, .. }| {
            let debug = &debug;
            async move {
                match debug.get_mac(id).await.expect("get mac") {
                    Err(fnet_debug::InterfacesGetMacError::NotFound) => None,
                    Ok(mac_address) => {
                        let mac_address = mac_address.expect("mac address not set");
                        (mac_address.octets == MAC_ADDR.octets).then(|| addresses)
                    }
                }
            }
        },
    );
    futures_util::pin_mut!(addresses);
    let addresses = addresses
        .next()
        .await
        .expect("could not find interface")
        .into_iter()
        .filter_map(|fnet_interfaces_ext::Address { value, valid_until: _ }| match value {
            interface_addr @ fnet::InterfaceAddress::Ipv4(_) => Some(interface_addr),
            interface_addr @ fnet::InterfaceAddress::Ipv6(fnet::Ipv6Address { addr }) => {
                let v6_addr = net_types::ip::Ipv6Addr::from_bytes(addr);
                v6_addr.is_unicast_link_local().then(|| interface_addr)
            }
        })
        .collect::<Vec<_>>();
    assert_eq!(addresses, vec![], "found unexpected addresses on interface");
}

const GATEWAY: fnet::IpAddress = fidl_ip!("192.168.0.1");

#[fuchsia_async::run_singlethreaded(test)]
async fn default_gateway() {
    let stack = connect_to_protocol::<fnet_stack::StackMarker>().expect("connect to protocol");
    let table = stack.get_forwarding_table().await.expect("get forwarding table");
    let found = table.into_iter().any(
        |fnet_stack::ForwardingEntry {
             subnet: fnet::Subnet { addr, prefix_len },
             next_hop,
             device_id: _,
             metric: _,
         }| {
            let fnet_ext::IpAddress(addr) = addr.into();
            next_hop.as_ref().map(|next_hop| **next_hop == GATEWAY).unwrap_or(false)
                && addr.is_unspecified()
                && prefix_len == 0
        },
    );
    assert!(found, "could not find default route to gateway {:?}", GATEWAY);
}
