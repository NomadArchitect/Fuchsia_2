# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/components/fuchsia_package.gni")
import("//build/components/fuchsia_test_component.gni")
import("//build/config.gni")
import("//build/dist/resource.gni")
import("//build/images/assemble_system.gni")
import("//build/images/assembly/update_package.gni")
import("//build/rust/rustc_binary.gni")

# Construct a system assembly for use in product security tests.
#
# Parameters:
#
#   board_name (required):
#     [string] board_name forwarded to assemble_system(target_name).
#
#   base_packages (required):
#     [list of labels] base_packages forwarded to assemble_system(target_name).
#
#   repository_config_files (required):
#     [list of labels] The repository configurations for pkg-resolver, to be
#     declared as config_data placed in pkg-resolver's repositories directory.
#
#   update_version_file (required):
#     [string] The file used to designate update version in the assembly's
#     update package.
#
# Public targets:
#
#   ${target_name}:
#     The assemble_system(target_name) { ... } used as a basis for other
#     targets.
#
#   ${target_name}_repository_config:
#     The pkg-resolver repository configuration described by
#     repository_config_files.
#
#   ${target_name}_update_package:
#     The update package for the assembled system.
#
#   ${target_name}_system_resources:
#     The resources required for serving the assembled system as installed on
#     device. Resources reside in package's data/assemblies/${target_name}
#     directory.
#
#   ${target_name}_update_resources:
#     The resources required for serving the update package associated with the
#     assembled system. Resources reside in package's
#     data/assemblies/${target_name} directory.

template("assemble_security_pkg_test_system") {
  assert(defined(invoker.board_name),
         "board_name must be defined for $target_name")
  assert(defined(invoker.base_packages),
         "base_packages must be defined for $target_name")
  assert(defined(invoker.repository_config_files),
         "repository_config_files must be defined for $target_name")
  assert(defined(invoker.update_version_file),
         "update_version_file must be defined for $target_name")

  assembly_name = target_name

  labels = {
    assembly = assembly_name
    assembly_image_assembler = "${assembly_name}_image_assembler"
    empty_pkgfs = "${assembly_name}_empty_pkgfs"
    repository_config = "${assembly_name}_repository_config"
    packages_json = "${assembly_name}_packages_json"
    update_package = "${assembly_name}_update_package"
    system_resources = "${assembly_name}_system_resources"
    update_resources_group = "${assembly_name}_update_resources"
    update_resources_package = "${assembly_name}_update_resources_package"
  }

  directories = {
    assembly_out = get_label_info(":${labels.assembly}", "target_out_dir") +
                   "/${assembly_name}"
    update_out = get_label_info(":${labels.assembly}", "target_out_dir") +
                 "/${labels.update_package}"
    update_resources_package_out =
        get_label_info(":${labels.update_resources_package}",
                       "target_out_dir") + "/${labels.update_resources_package}"
  }
  if (current_toolchain == target_toolchain) {
    directories.update_gen = "${directories.update_out}/gen"
  }

  files = {
    packages_json = "${directories.assembly_out}/packages.json"
    partitions_json = "${directories.assembly_out}_partitions.json"
    images_json = "${directories.assembly_out}/images.json"
    package_manifest_json =
        "${directories.update_resources_package_out}/package_manifest.json"
    update_package_manifest_json =
        "${directories.update_out}/update_package_manifest.json"
  }

  # Resource files with both `local` and `packaged` paths.
  if (current_toolchain == target_toolchain) {
    fvm_blk_resource = {
      local = "${directories.assembly_out}/fvm.blk"
      packaged = "data/assemblies/${assembly_name}/fvm.blk"
    }
    base_far_resource = {
      local = "${directories.assembly_out}/base.far"
      packaged = "data/assemblies/${assembly_name}/base.far"
    }
    zbi_resource = {
      local = "${directories.assembly_out}/${assembly_name}.zbi"
      packaged = "data/assemblies/${assembly_name}/update/zbi"
    }
    update_far_resource = {
      local = "${directories.update_out}/update.far"
      packaged = "data/assemblies/${assembly_name}/update/update.far"
    }
    version_resource = {
      local = invoker.update_version_file
      packaged = "data/assemblies/${assembly_name}/update/version"
    }
    board_resource = {
      local = "${directories.update_gen}/board"
      packaged = "data/assemblies/${assembly_name}/update/board"
    }
    packages_json_resource = {
      local = "${directories.update_gen}/packages.json"
      packaged = "data/assemblies/${assembly_name}/update/packages.json"
    }
    epoch_json_resource = {
      local = "${directories.update_gen}/epoch.json"
      packaged = "data/assemblies/${assembly_name}/update/epoch.json"
    }
    if (use_vbmeta) {
      vbmeta_resource = {
        local = "${directories.assembly_out}/${assembly_name}.vbmeta"
        packaged = "data/assemblies/${assembly_name}/update/fuchsia.vbmeta"
      }
    }
    firmware_resources = []
    foreach(firmware, firmware_prebuilts) {
      assert(defined(firmware.path), "Firmware path must be specified")
      _firmware_path = "${firmware.path}${firmware_prebuilts_path_suffix}"
      _firmware_file = get_path_info(_firmware_path, "file")
      firmware_resources += [
        {
          local = _firmware_path
          packaged = "data/assemblies/${assembly_name}/update/${_firmware_file}"
        },
      ]
    }
  }

  # `assemble_system(...) { base_packages }` requires a package with the name
  # "pkgfs".
  fuchsia_package(labels.empty_pkgfs) {
    testonly = true
    package_name = "pkgfs"
  }

  # Configure repositories for pkg-resolver.
  config_data(labels.repository_config) {
    for_pkg = "pkg-resolver"
    outputs = [ "repositories/{{source_file_part}}" ]
    sources = invoker.repository_config_files
  }

  # Main system assembly.
  assemble_system(labels.assembly) {
    testonly = true
    board_name = invoker.board_name
    bootfs_labels = []
    base_packages = [
                      ":${labels.empty_pkgfs}",
                      ":${labels.repository_config}",
                    ] + invoker.base_packages
  }

  # Construct an update package for the system assembly.
  update_package(labels.update_package) {
    testonly = true
    deps = [
      ":${labels.assembly_image_assembler}",
      ":${labels.assembly}",
    ]
    partitions = files.partitions_json
    packages = files.packages_json
    system_a = files.images_json
    board_name = board_name
    version_file = invoker.update_version_file
    epoch = "1"
  }

  # `resource_group` targets should be built on the `target_toolchain`.
  # Other toolchains should depend on the `target_toolchain` outputs.
  if (current_toolchain == target_toolchain) {
    # Resources needed to host a system image.
    resource_group(labels.system_resources) {
      testonly = true
      deps = [ ":${labels.assembly}" ]
      files = [
        {
          source = fvm_blk_resource.local
          dest = fvm_blk_resource.packaged
        },
        {
          source = base_far_resource.local
          dest = base_far_resource.packaged
        },
      ]
    }

    # Resources needed for update package. The bespoke subset of files from
    # system assembly that is included here is checked below.
    resource_group(labels.update_resources_group) {
      testonly = true
      deps = [
        ":${labels.assembly_image_assembler}",
        ":${labels.update_package}",
      ]
      files = [
        {
          source = zbi_resource.local
          dest = zbi_resource.packaged
        },
        {
          source = board_resource.local
          dest = board_resource.packaged
        },
        {
          source = packages_json_resource.local
          dest = packages_json_resource.packaged
        },
        {
          source = update_far_resource.local
          dest = update_far_resource.packaged
        },
        {
          source = epoch_json_resource.local
          dest = epoch_json_resource.packaged
        },
        {
          source = version_resource.local
          dest = version_resource.packaged
        },
      ]
      if (use_vbmeta) {
        files += [
          {
            source = vbmeta_resource.local
            dest = vbmeta_resource.packaged
          },
        ]
      }
      foreach(firmware, firmware_resources) {
        files += [
          {
            source = firmware.local
            dest = firmware.packaged
          },
        ]
      }
    }
  } else {
    group(labels.system_resources) {
      testonly = true
      public_deps = [ ":${labels.system_resources}($target_toolchain)" ]
    }

    group(labels.update_resources_group) {
      testonly = true
      public_deps = [ ":${labels.update_resources_group}($target_toolchain)" ]
    }
  }

  # Check update package resources:
  # Construct a package that contains update resources.
  fuchsia_package(labels.update_resources_package) {
    testonly = true
    deps = [ ":${labels.update_resources_group}" ]
  }

  # TODO(fxbug.dev/91098): Ensure that actual update package blobs are a subset
  # of package blobs manually included in `labels.update_resources_package`
  # above.
}
