// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::Error,
    assert_matches::assert_matches,
    fuchsia_async as fasync,
    fuchsia_watch::{watch, PathEvent},
    futures::{channel::mpsc, lock::Mutex, stream, SinkExt, StreamExt},
    std::sync::Arc,
};

const DEV_CLASS_BLOCK: &'static str = "/dev/class/block";

enum PauseEvent {
    Pause,
    /// This stream is the newly initiated stream of block devices from the directory watcher.
    Resume(stream::BoxStream<'static, String>),
}

impl std::fmt::Debug for PauseEvent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            PauseEvent::Pause => std::write!(f, "PauseEvent::Pause"),
            PauseEvent::Resume(_) => std::write!(f, "PauseEvent::Resume"),
        }
    }
}

impl PauseEvent {
    /// Get the stream of block devices generated by the directory watcher out of the event.
    fn stream(self) -> Option<stream::BoxStream<'static, String>> {
        match self {
            PauseEvent::Pause => None,
            PauseEvent::Resume(stream) => Some(stream),
        }
    }
}

/// Generates a stream of block devices based off the path events we get from setting up a
/// directory watcher on this path. This will set up a new directory watcher every time stream is
/// called.
#[derive(Clone, Debug)]
struct PathSource {
    path: &'static str,
}

impl PathSource {
    fn new(path: &'static str) -> Self {
        PathSource { path }
    }

    /// Sets up a new directory watcher against the configured path and returns the stream of block
    /// devices found at that path. If [`ignore_existing`] is true then we skip
    /// [`PathEvent::Existing`] events, and only add to the stream when new directory entries are
    /// added after this call.
    async fn stream(&mut self, ignore_existing: bool) -> stream::BoxStream<'static, String> {
        Box::pin(
            watch(self.path).await.expect(&format!("failed to watch {}", self.path)).filter_map(
                move |event| async move {
                    match event {
                        PathEvent::Added(path, _) => Some(path),
                        PathEvent::Existing(path, _) => {
                            if ignore_existing {
                                None
                            } else {
                                Some(path)
                            }
                        }
                        PathEvent::Removed(_) => None,
                    }
                    .map(|p| p.into_os_string().into_string().unwrap())
                },
            ),
        )
    }
}

/// Watcher generates new [`BlockDevice`]s for fshost to process. It provides pausing and resuming
/// mechanisms, which allow the stream to be temporarily stopped.
#[derive(Clone, Debug)]
pub struct Watcher {
    /// This is a bool in a mutex instead of an AtomicBool because it doubles as a lock for the
    /// pause and resume calls to make sure their event signals get through in the right order.
    paused: Arc<Mutex<bool>>,
    pause_event_tx: mpsc::Sender<PauseEvent>,
    source: PathSource,
    _watcher_task: Arc<fasync::Task<()>>,
}

impl Watcher {
    /// Create a new Watcher and BlockDevice stream. The watcher will start watching
    /// /dev/class/block immediately, initially populating the stream with any entries which are
    /// already there, then sending new items on the stream as they are added to the directory.
    ///
    /// Watcher provides pause and resume which will stop the watcher from sending new entries on
    /// the stream.
    pub async fn new() -> Result<(Self, impl futures::Stream<Item = String>), Error> {
        let source = PathSource::new(DEV_CLASS_BLOCK);
        Self::new_with_source(source).await
    }

    async fn new_with_source(
        mut source: PathSource,
    ) -> Result<(Self, impl futures::Stream<Item = String>), Error> {
        // NB. The mpsc channel for the pause event must have a buffer size of 0. Otherwise, `send`
        // on the Sink doesn't wait for the sent event to be processed, and the guarantees about
        // pause and resume not returning until the block watcher is in the right state won't hold.
        let (mut pause_event_tx, pause_event_rx) = mpsc::channel(0);
        let (device_tx, device_rx) = mpsc::unbounded();

        let task = fasync::Task::spawn(Self::watcher_loop(pause_event_rx, device_tx));

        pause_event_tx.send(PauseEvent::Resume(source.stream(false).await)).await?;

        Ok((
            Watcher {
                paused: Arc::new(Mutex::new(false)),
                pause_event_tx,
                source,
                _watcher_task: Arc::new(task),
            },
            device_rx,
        ))
    }

    /// The core watcher loop, which gets spawned as a task and provides devices to a device stream
    /// as they appear. The first event on the pause_event_rx channel should be a Resume event with
    /// the initial device stream.
    async fn watcher_loop(
        mut pause_event_rx: mpsc::Receiver<PauseEvent>,
        mut device_tx: mpsc::UnboundedSender<String>,
    ) {
        while let Some(event) = pause_event_rx.next().await {
            // The event should be a Resume, which contains the new device stream. This will panic
            // if the event is not Resume.
            let mut device_stream = event.stream().expect("unexpected event").fuse();
            loop {
                futures::select_biased! {
                    // select_biased prefers the first branch if both futures are available. This
                    // isn't load-bearing - the client of pause should be waiting for pause to
                    // return before assuming the watcher is paused, and pause won't return until
                    // this branch is processed.
                    pause_event = pause_event_rx.next() => {
                        assert_matches!(pause_event, Some(PauseEvent::Pause));
                        break;
                    },
                    device = device_stream.next() => {
                        assert!(device.is_some(), "device stream returned none");
                        device_tx.send(device.unwrap()).await.expect("failed to send device");
                    }
                };
            }
        }
    }

    /// Pause the watcher. This function doesn't return until the watcher task is no longer
    /// processing new block devices.
    ///
    /// This returns an error if it's called while the watcher is already paused.
    pub async fn pause(&mut self) -> Result<(), Error> {
        let mut paused = self.paused.lock().await;
        if *paused {
            anyhow::bail!("already paused");
        }
        *paused = true;
        // We return an error if we were already paused, so if we get to this point, we need to let
        // the watcher know to pause. `send` will wait until the event is removed from the channel
        // by the watcher loop, as long as the channel buffer is 0.
        self.pause_event_tx.send(PauseEvent::Pause).await?;
        Ok(())
    }

    /// Resume the watcher. It doesn't return until the watcher task has set up the new directory
    /// watchers and will process new entries again.
    ///
    /// If the watcher hasn't been paused, this function returns an error.
    pub async fn resume(&mut self) -> Result<(), Error> {
        let mut paused = self.paused.lock().await;
        if !*paused {
            anyhow::bail!("not paused");
        }
        *paused = false;
        // We return an error if we weren't paused, so if we get to this point, we need to let the
        // watcher know to resume. `send` will wait until the event is removed from the channel by
        // the watcher loop, as long as the channel buffer is 0.
        self.pause_event_tx.send(PauseEvent::Resume(self.source.stream(true).await)).await?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use {
        super::{PathSource, Watcher},
        fidl_fuchsia_io as fio, fuchsia_async as fasync,
        futures::StreamExt,
        vfs::{
            directory::{entry::DirectoryEntry, helper::DirectlyMutable},
            execution_scope::ExecutionScope,
            path::Path,
        },
    };

    #[fasync::run_singlethreaded(test)]
    async fn watcher_populates_device_stream() {
        // Start with a couple of devices
        let block = vfs::mut_pseudo_directory! {
            "000" => vfs::file::vmo::read_only_static(""),
            "001" => vfs::file::vmo::read_only_static(""),
        };
        let class_block = vfs::pseudo_directory! {
            "class" => vfs::pseudo_directory! {
                "block" => block.clone(),
            },
        };

        let (client, server) =
            fuchsia_zircon::Channel::create().expect("failed to make channel pair");
        let scope = ExecutionScope::new();
        class_block.open(
            scope.clone(),
            fio::OpenFlags::RIGHT_READABLE | fio::OpenFlags::RIGHT_WRITABLE,
            fio::MODE_TYPE_DIRECTORY,
            Path::dot(),
            server.into(),
        );

        {
            let ns = fdio::Namespace::installed().expect("failed to get installed namespace");
            ns.bind("/test-dev", client).expect("failed to bind dev in namespace");
        }

        let (mut watcher, mut device_stream) =
            Watcher::new_with_source(PathSource { path: "/test-dev/class/block" })
                .await
                .expect("failed to make watcher");

        // There are a couple of devices that were added before we started watching.
        assert_eq!(&device_stream.next().await.unwrap(), "/test-dev/class/block/000");
        assert_eq!(&device_stream.next().await.unwrap(), "/test-dev/class/block/001");

        // Removing an entry doesn't do anything.
        assert!(block
            .remove_entry("001", false)
            .expect("failed to remove dir entry 001")
            .is_some());

        // Adding an entry generates a new block device.
        block
            .add_entry("002", vfs::file::vmo::read_only_static(""))
            .expect("failed to add dir entry 002");
        assert_eq!(&device_stream.next().await.unwrap(), "/test-dev/class/block/002");

        // Pausing stops events from being generated.
        watcher.pause().await.expect("failed to pause");
        block
            .add_entry("003", vfs::file::vmo::read_only_static(""))
            .expect("failed to add dir entry 003");

        // When we resume, events start flowing again. We don't see any devices which were added
        // while we were paused (or before).
        watcher.resume().await.expect("failed to resume");
        block
            .add_entry("004", vfs::file::vmo::read_only_static(""))
            .expect("failed to add dir entry 006");
        assert_eq!(&device_stream.next().await.unwrap(), "/test-dev/class/block/004");
    }
}
