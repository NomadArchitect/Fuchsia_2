// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use {
    anyhow::{anyhow, Result},
    std::cell::RefCell,
    std::io::{stdout, Write},
    std::rc::Rc,
};

/// The valid formats possible to output for machine consumption.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Format {
    Json,
}

impl std::str::FromStr for Format {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_ref() {
            "json" | "j" => Ok(Format::Json),
            f => Err(anyhow!("Unknown format {}", f)),
        }
    }
}

/// An object that can be used to produce output.
#[derive(Debug, Clone)]
pub struct Writer {
    format: Option<Format>,
    test_buffer: Option<Rc<RefCell<Vec<u8>>>>,
}

impl Writer {
    /// Create a new Writer with the specified format.
    ///
    /// Passing None for format implies no output via the machine function.
    pub fn new(format: Option<Format>) -> Self {
        Self { format, test_buffer: None }
    }

    /// Create a new Writer with the specified format that captures all output for later replay.
    ///
    /// Passing None for format implies no output via the machine function.
    pub fn new_test(format: Option<Format>) -> Self {
        Self { format, test_buffer: Some(Rc::new(RefCell::new(Vec::new()))) }
    }

    /// Get all output that would have been generated by this object.
    ///
    /// An error will be returned if this method is called on a non-test instance.
    pub fn test_output(self) -> Result<String> {
        self.test_buffer
            .ok_or(anyhow!("Misconfigured Output, test_buffer is missing"))
            .and_then(|b| String::from_utf8(b.take()).map_err(|e| e.into()))
    }

    /// Writes machine consumable output to standard output.
    ///
    /// This is a no-op if `is_machine` returns false.
    pub fn machine<T: serde::Serialize>(&mut self, output: &T) -> Result<()> {
        if !self.is_machine() {
            return Ok(());
        }
        match self.format {
            Some(Format::Json) => serde_json::to_writer(self, output)?,
            _ => return Err(anyhow!("Unknown format")),
        }
        Ok(())
    }

    /// Returns true if the receiver was configured to output for machines.
    pub fn is_machine(&self) -> bool {
        self.format.is_some()
    }
}

#[doc(hidden)]
impl Write for Writer {
    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {
        match &self.test_buffer {
            Some(b) => b.borrow_mut().write(buf),
            None => stdout().write(buf),
        }
    }

    fn flush(&mut self) -> std::io::Result<()> {
        match self.test_buffer {
            None => stdout().flush(),
            _ => Ok(()),
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_not_machine_is_ok() {
        let mut writer = Writer::new(None);
        let res = writer.machine(&"ehllo");
        assert!(res.is_ok());
    }

    #[test]
    fn test_machine_valid_json_is_ok() {
        let mut writer = Writer::new(Some(Format::Json));
        let res = writer.machine(&"ehllo");
        assert!(res.is_ok());
    }

    #[test]
    fn test_machine_for_test() {
        let mut writer = Writer::new_test(Some(Format::Json));
        writer.machine(&"hello").unwrap();

        assert_eq!(writer.test_output().unwrap(), "\"hello\"");
    }

    #[test]
    fn test_not_machine_for_test_is_empty() {
        let mut writer = Writer::new_test(None);
        writer.machine(&"hello").unwrap();

        assert!(writer.test_output().unwrap().is_empty());
    }

    #[test]
    fn test_machine_makes_is_machine_true() {
        let writer = Writer::new(Some(Format::Json));
        assert!(writer.is_machine());
    }

    #[test]
    fn test_not_machine_makes_is_machine_false() {
        let writer = Writer::new(None);
        assert!(!writer.is_machine());
    }

    #[test]
    fn test_writing_to_clone_is_shared() {
        let writer = Writer::new_test(None);
        let mut writer_clone = writer.clone();

        write!(&mut writer_clone, "hello").unwrap();

        assert_eq!(writer.test_output().unwrap(), "hello");
    }
}
