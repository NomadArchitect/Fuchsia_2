// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

use anyhow::Error;
use fidl::endpoints::{ClientEnd, ServerEnd};
use fidl_fuchsia_element as felement;
use fidl_fuchsia_ui_input3 as ui_input3;
use fidl_fuchsia_ui_shortcut2 as ui_shortcut2;
use fidl_fuchsia_ui_views as ui_views;
use futures::channel::mpsc::{UnboundedReceiver, UnboundedSender};
use pointer_fusion::PointerEvent;
use tracing::log::error;

use crate::{child_view::ChildViewId, window::WindowId};

/// Defines a set of events generated by the library.
#[derive(Debug)]
pub enum Event<T> {
    /// Use Init to perform one-time app initialization.
    Init,
    /// Set of system level events that are window agnostic.
    SystemEvent { event: SystemEvent },
    /// Set of device level events that are window agnostic.
    DeviceEvent,
    /// Set of events that apply to a window instance.
    WindowEvent { window_id: WindowId, event: WindowEvent },
    /// Set of events that apply to embedded child views.
    ChildViewEvent { child_view_id: ChildViewId, window_id: WindowId, event: ChildViewEvent },
    /// Used to route application specific events T.
    UserEvent(T),
    /// Use to notify the event processing loop to terminate.
    Exit,
}

/// Set of system level events that are window agnostic.
#[derive(Debug)]
pub enum SystemEvent {
    /// Can be used to create a window from a [ui_views::ViewCreationToken]. This is useful only
    /// for ViewProvider based applications.
    ViewCreationToken { token: ui_views::ViewCreationToken },
    /// Used for creating a child view given a ViewSpecHolder using [window.create_child_view].
    PresentViewSpec { view_spec_holder: ViewSpecHolder },
}

/// The next future presentation time, expressed in nanoseconds in the `CLOCK_MONOTONIC` timebase.
type NextPresentTimeInNanos = i64;

/// Set of events that apply to a window instance.
#[derive(Debug)]
pub enum WindowEvent {
    /// Window is resized. This is also the first event sent upon window creation.
    Resized { width: u32, height: u32, pixel_ratio: f32 },
    /// Window needs to be redrawn. Sent upon receiving the next frame request from Flatland.
    NeedsRedraw { next_present_time: NextPresentTimeInNanos },
    /// Window has received or lost focus.
    Focused { focused: bool },
    /// A keyboard key event when the window is in focus.
    Keyboard {
        event: ui_input3::KeyEvent,
        responder: ui_input3::KeyboardListenerOnKeyEventResponder,
    },
    /// A registered keyboard shortcut is invoked by the user.
    Shortcut { id: u32, responder: ui_shortcut2::ListenerOnShortcutResponder },
    /// A pointer event received for this window.
    Pointer { event: PointerEvent },
    /// Window was closed by the [GraphicalPresenter] presenting this window.
    Closed,
}

/// Set of events that apply to embedded child views.
#[derive(Debug)]
pub enum ChildViewEvent {
    /// Child view is created but not attached to the view tree yet.
    Available,
    /// Child view is attached to the view tree.
    Attached { view_ref: ui_views::ViewRef },
    /// Child view is detached from the view tree.
    Detached,
    /// Child view was dismissed by the owning component.
    Dismissed,
}

/// Defines a struct to hold the parameters provided during [GraphicalPresenter.present_view]. This
/// is used when the applications implements the [GraphicalPresenter] protocol to embed child views.
#[derive(Debug)]
pub struct ViewSpecHolder {
    pub view_spec: felement::ViewSpec,
    pub annotation_controller: Option<ClientEnd<felement::AnnotationControllerMarker>>,
    pub view_controller_request: Option<ServerEnd<felement::ViewControllerMarker>>,
    pub responder: Option<felement::GraphicalPresenterPresentViewResponder>,
}

/// Defines a thin wrapper over [futures::channel::mpsc::unbounded] channel to send and receive
/// [Event]s. This is primarily used for implementing a "message-loop" in process system-wide
/// messages in one-place.
#[derive(Debug)]
pub struct EventSender<T>(pub UnboundedSender<Event<T>>);

impl<T> Clone for EventSender<T> {
    fn clone(&self) -> Self {
        Self(self.0.clone())
    }
}

impl<T> EventSender<T> {
    pub fn new() -> (Self, UnboundedReceiver<Event<T>>) {
        let (sender, receiver) = futures::channel::mpsc::unbounded::<Event<T>>();

        let event_sender = EventSender::<T>(sender);
        event_sender.send(Event::<T>::Init).expect("Failed to send Event::Init event");

        (event_sender, receiver)
    }

    pub fn close(&mut self) {
        self.0.disconnect()
    }

    pub fn send(&self, event: Event<T>) -> Result<(), Error> {
        if let Err(e) = self.0.unbounded_send(event) {
            error!("Failed to send event: {:?}", e);
        }
        Ok(())
    }
}
