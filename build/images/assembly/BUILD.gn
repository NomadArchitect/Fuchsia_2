# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# This is a re-implementation of //build/images/BUILD.gn, but using the ffx
# assembly plugin as the main implementation.  Most of the work in this file
# is creating the translation between the Fuchsia Build and the inputs that the
# ffx assembly plugin expects.

import("//build/compiled_action.gni")
import("//build/components/fuchsia_system_package.gni")
import("//build/dist/resource.gni")
import("//build/images/args.gni")
import("//build/images/assemble_system.gni")
import("//build/images/custom_signing.gni")
import("//build/images/vboot/vboot.gni")
import("//build/info/info.gni")
import("//build/packages/package_metadata.gni")
import("//build/security.gni")
import("//build/testing/verify_files_match.gni")
import("//src/developer/ffx/build/ffx_action.gni")

####
#
# Deal with "bringup" and other zbi-only builds.
#
# These builds set `bootfs_only` to true, and do not include a base/system_image
# package, pkgfs, blobfs, fvm, etc.
#
# This declares an inverted variable that has easier reading and is less likely
# to miss the `!` operator:
#
uses_base_package = !bootfs_only

####
#
# All the stuff in this file that we want to build by default:
#
group("assembly") {
  testonly = true
  deps = [
    ":fuchsia",
    ":input_validation_checks",
    ":output_validation_checks",
  ]

  # Recovery-only configurations don't have a properly configured fuchsia.zbi,
  # as they are really building a recovery.zbi, with it's own separate
  # configuration.
  #
  # `ffx assembly` cannot build the configurations these fuchsia.zbi's have, and
  # so we clear the deps here to disable all these targets.
  if (recovery_only) {
    deps = []
  }
}

#####
#
# File Paths used by Image Assembly
#
#  These are all the files that are inputs, outputs, or intermediates that are
#  used by the actions in this file.
#
files = {
  outdir = "${target_out_dir}/fuchsia"
  gendir = "${outdir}/gen"

  base_static_packages = "${gendir}/data/static_packages"
  base_cache_packages = "${gendir}/data/cache_packages"
  base_meta_package = "${gendir}/system_image/meta/package"

  base_package = "${outdir}/base.far"
  zbi = "${outdir}/fuchsia.zbi"
  zbi_signed = "${outdir}/fuchsia.zbi.signed"
  zbi_manifest = "${gendir}/zbi.json"
  vbmeta = "${outdir}/fuchsia.vbmeta"

  update_package = "${outdir}/update.far"
  update_meta_package = "${gendir}/update/meta/package"

  blobfs = "${outdir}/blob.blk"

  fvm = "${outdir}/fvm.blk"
  fvm_sparse = "${outdir}/fvm.sparse.blk"
  fvm_blob_sparse = "${outdir}/fvm.blob.sparse.blk"
  fvm_fastboot = "${outdir}/fvm.fastboot.blk"
}

old_labels = {
  base_package = "//build/images:system_image.meta"

  # `bootfs_only` is only set by 'bringup', which uses different assembly
  # targets and differently named files in the previous assembly implementation
  # than `core` and above.  That difference should go away as
  # //build/images/BUILD.gn is ported over to using ffx assembly.
  if (bootfs_only) {
    zbi = "//build/images/bringup"
    zbi_manifest = zbi

    if (use_vbmeta) {
      vbmeta = "//build/images/bringup:bringup.vbmeta"
    }
  } else {
    if (custom_signing_script != "" || use_vboot) {
      zbi = "//build/images:signed"
    } else {
      zbi = "//build/images:fuchsia"
    }
    zbi_manifest = "//build/images:fuchsia_unverified"

    if (use_vbmeta) {
      vbmeta = "//build/images:fuchsia.vbmeta"
    }
  }

  update_package = "//build/images:update.meta"
  blobfs = "//build/images:blob.blk"
  fvm = "//build/images:fvm.blk"
  fvm_sparse = "//build/images:fvm.sparse.blk"
  fvm_blob_sparse = "//build/images:fvm.blob.sparse.blk"
  fvm_fastboot = "//build/images:fvm.fastboot.blk"
}

old_files = {
  base_package = get_label_info(old_labels.base_package, "target_out_dir") +
                 "/system_image.meta/meta.far"

  # bootfs_only is only set by 'bringup', which uses different assembly targets
  # in the previous assembly implements.
  if (bootfs_only) {
    # The zbi created by //build/images/bringup
    zbi = "${root_build_dir}/bringup.zbi"
    zbi_manifest = "${zbi}.json"

    # The vbmeta for bringup.
    vbmeta = "${root_build_dir}/bringup.vbmeta"
    vbmeta_salt = "${vbmeta}.salt"
  } else {
    if (custom_signing_script != "") {
      # The vendor-processed zbi created by //build/images:signed
      zbi = "${root_build_dir}/fuchsia.zbi.signed"
    } else if (use_vboot) {
      # The vboot-processed zbi created by //build/images:signed
      zbi = "${root_build_dir}/fuchsia.zbi.vboot"
    } else {
      # The zbi created by //build/images:fuchsia
      zbi = "${root_build_dir}/fuchsia.zbi"
    }
    zbi_manifest = "${root_build_dir}/fuchsia_unverified.zbi.json"

    # The vbmeta for zbi
    vbmeta = "${root_build_dir}/fuchsia.vbmeta"
    vbmeta_salt = "${vbmeta}.salt"
  }

  update_package = "${root_build_dir}/obj/build/images/update.meta/meta.far"
  blobfs = "${root_build_dir}/obj/build/images/blob.blk"
  minfs = "${root_build_dir}/obj/build/images/data.blk"
  fvm = "${root_build_dir}/obj/build/images/fvm.blk"
  fvm_sparse = "${root_build_dir}/obj/build/images/fvm.sparse.blk"
  fvm_blob_sparse = "${root_build_dir}/obj/build/images/fvm.blob.sparse.blk"
  fvm_fastboot = "${root_build_dir}/obj/build/images/fvm.fastboot.blk"
}

if (uses_base_package) {
  extracted_files = {
    outdir = target_out_dir
    gendir = "${target_out_dir}/gen"

    base_package_dir = "${outdir}/extracted_base_pkg"
    base_meta_contents = "${base_package_dir}/meta/contents"
    base_meta_package = "${base_package_dir}/meta/package"

    # The system-image package re-extraction (temporary) output dir
    old_base_package_dir = "${outdir}/extracted_old_base_pkg"
    old_base_meta_contents = "${old_base_package_dir}/meta/contents"
    old_base_meta_package = "${old_base_package_dir}/meta/package"

    update_package_dir = "${outdir}/extracted_update_pkg"
    update_meta_contents = "${update_package_dir}/meta/contents"
    update_meta_package = "${update_package_dir}/meta/package"

    old_update_package_dir = "${target_out_dir}/extracted_old_update_pkg"
    old_update_meta_contents = "${old_update_package_dir}/meta/contents"
    old_update_meta_package = "${old_update_package_dir}/meta/package"
  }

  rebased_files = {
    gendir = rebase_path(files.gendir, root_build_dir)
    outdir = rebase_path(files.outdir, root_build_dir)
    minfs = rebase_path(old_files.minfs, root_build_dir)

    if (uses_base_package) {
      old_base_package = rebase_path(old_files.base_package, root_build_dir)
      old_base_package_dir =
          rebase_path(extracted_files.old_base_package_dir, root_build_dir)
      base_package = rebase_path(files.base_package, root_build_dir)
      base_package_dir =
          rebase_path(extracted_files.base_package_dir, root_build_dir)
      old_update_package = rebase_path(old_files.update_package, root_build_dir)
      old_update_package_dir =
          rebase_path(extracted_files.old_update_package_dir, root_build_dir)
      update_package = rebase_path(files.update_package, root_build_dir)
      update_package_dir =
          rebase_path(extracted_files.update_package_dir, root_build_dir)
    }
  }
}

# Select the correct vbmeta and salt depending on if it is bootfs_only or not.
if (use_vbmeta) {
  if (bootfs_only) {
    vbmeta_label = "//build/images/bringup:bringup.vbmeta"
    vbmeta_file = "$root_build_dir/bringup.vbmeta"
  } else {
    vbmeta_label = "//build/images:fuchsia.vbmeta"
    vbmeta_file = "$root_build_dir/fuchsia.vbmeta"
  }
  vbmeta_salt = rebase_path("${vbmeta_file}.salt", root_build_dir)
}

assemble_system("fuchsia") {
  testonly = true
  include_version_and_epoch = true
  include_component_id_index = true
  base_driver_packages = [ "//:additional_base_driver_packages" ]
  board_name = board_name

  _base_packages = [
    "//:additional_base_driver_packages",
    "//:additional_base_packages",
    "//build/images:driver-manager-base-config",
  ]

  # The shell commands may be included by the meta_package_labels.
  # TODO(fxbug.dev/81290): Construct the shell commands package in the Image
  # Assembler.
  include_shell_commands = false

  # Add the meta_package_labels, but ensure we do not include config-data or
  # component_index, because these are already included by assemble_system.
  _base_packages += meta_package_labels
  _base_packages += [
    "//build/images:config-data",
    "//src/sys/component_index:component_index",
  ]
  _base_packages -= [
    "//build/images:config-data",
    "//src/sys/component_index:component_index",
  ]

  _cache_packages = [ "//:additional_cache_packages" ]

  bootfs_labels = [ "//build/input:bootfs" ]
  if (bootfs_only) {
    # BootFS-only builds put all the packages in BootFS.
    bootfs_labels += [ "//build/input:system_image" ]
    bootfs_labels += _base_packages + _cache_packages
    bootfs_labels += [ "//:additional_universe_packages" ]
    base_packages = []
  } else {
    # All other builds, put their packages in the FVM.
    base_packages = _base_packages

    # TODO: Remove once the inclusion of component_index is unified under assemble_system.gni
    base_packages += [ "//src/sys/component_index" ]
    cache_packages = _cache_packages
    system_image_deps = [ "//build/input:system_image" ]
  }

  cmdline_deps = [ "//build/input:bootfs" ]
  recovery = recovery_label
  use_esp = target_cpu != "arm64" && !use_vboot
  zbi_name = "fuchsia"

  # minfs arguments
  if (!bootfs_only) {
    minfs = rebased_files.minfs
    if (minfs_product_minimum_inodes != false) {
      minfs_minimum_inodes = minfs_product_minimum_inodes
    } else if (minfs_board_minimum_inodes != false) {
      minfs_minimum_inodes = minfs_board_minimum_inodes
    }
    if (minfs_product_minimum_data_bytes != false) {
      minfs_minimum_data_bytes = minfs_product_minimum_data_bytes
    } else if (minfs_board_minimum_data_bytes != false) {
      minfs_minimum_data_bytes = minfs_board_minimum_data_bytes
    }
    if (minfs_product_maximum_bytes != false) {
      minfs_maximum_bytes = minfs_product_maximum_bytes
    } else if (minfs_board_maximum_bytes != false) {
      minfs_maximum_bytes = minfs_board_maximum_bytes
    }
  }

  # blobfs arguments
  blob_layout_format = blob_layout_format
  compress_blobs = compress_blobs
  if (!bootfs_only) {
    if (blobfs_product_minimum_inodes != false) {
      blobfs_minimum_inodes = blobfs_product_minimum_inodes
    } else if (blobfs_board_minimum_inodes != false) {
      blobfs_minimum_inodes = blobfs_board_minimum_inodes
    }
    if (blobfs_product_minimum_data_bytes != false) {
      blobfs_minimum_data_bytes = blobfs_product_minimum_data_bytes
    } else if (blobfs_board_minimum_data_bytes != false) {
      blobfs_minimum_data_bytes = blobfs_board_minimum_data_bytes
    }
    if (blobfs_product_maximum_bytes != false) {
      blobfs_maximum_bytes = blobfs_product_maximum_bytes
    } else if (blobfs_board_maximum_bytes != false) {
      blobfs_maximum_bytes = blobfs_board_maximum_bytes
    }
  }

  # fvm arguments
  if (!bootfs_only) {
    fvm_slice_size = fvm_slice_size
  }

  # zbi arguments
  if (custom_signing_script != "") {
    zbi_signing_script = custom_signing_script
  } else if (use_vboot) {
    zbi_signing_script = vboot_action.script
    zbi_signing_args = vboot_action.args
  }

  if (use_vbmeta) {
    deps = [ vbmeta_label ]
    salt_file = vbmeta_salt
  }
}

# Determine if a fastboot-supported FVM should be generated.
build_fastboot_fvm = false
if (fvm_partition != "" && !bootfs_only &&
    (fvm_emmc_partition_size != false || fvm_ftl_nand_block_count != false)) {
  build_fastboot_fvm = true
}

#####
#
# Validation that the inputs generated for the ffx assembly match those of the
# current implementation in //build/images/BUILD.gn
#
# NOTE: For consistency, the //build/images/BUILD.gn inputs and outputs are
#       always listed as the "first" file, and the files generated in this
#       BUILD.gn file are listed as the "second" file, to keep the diff view
#       of the files consistent (left=first=original, right=second=new)
#

group("input_validation_checks") {
  testonly = true
  deps = []
  if (uses_base_package) {
    deps += [
      ":cache_index_matches",
      ":pkgsvr_index_matches",
    ]
  }
}

if (uses_base_package) {
  verify_files_match("pkgsvr_index_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      "//build/images:pkgsvr_index",
    ]

    first = "$root_build_dir/obj/build/images/pkgsvr_index"
    second = files.base_static_packages

    display_text_diff_on_failure = true
  }

  verify_files_match("cache_index_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      "//build/images:cache_index",
    ]

    first = "$root_build_dir/obj/build/images/cache_index"
    second = files.base_cache_packages

    display_text_diff_on_failure = true
  }
}

#####
#
# Validation checks that the base package contents matches the system-image
# package contents
group("output_validation_checks") {
  testonly = true
  deps = []
  if (uses_base_package) {
    deps += [
      ":base_pkg_meta_contents_matches",
      ":base_pkg_meta_far_matches",

      # Even though assembly always creates this, if there is a ZBI, the
      # previous implementation didn't if it was making a bootfs-only image, so
      # only attempt the comparison if there's a base package (which is inverse
      # of bootfs-only).
      ":blobfs_matches",
      ":fvm_matches",
      ":sparse_blob_fvm_matches",
      ":sparse_fvm_matches",
      ":update_matches",
      ":update_pkg_meta_contents_matches",
      ":update_pkg_meta_package_matches",
    ]
  }
  if (build_fastboot_fvm) {
    deps += [ ":fastboot_fvm_matches" ]
  }
  deps += [
    ":zbi_manifest_matches",
    ":zbi_matches",
  ]
  if (use_vbmeta) {
    deps += [ ":vbmeta_matches" ]
  }
}

if (uses_base_package) {
  # Extract system-image's package's contents for inspection
  compiled_action("extract_old_base_package") {
    testonly = true
    tool = "//src/sys/pkg/bin/far:bin"
    tool_output_name = "far"

    args = [
      "extract",
      "--archive=${rebased_files.old_base_package}",
      "--output=${rebased_files.old_base_package_dir}",
    ]

    inputs = [ old_files.base_package ]

    outputs = [
      extracted_files.old_base_meta_contents,
      extracted_files.old_base_meta_package,
    ]

    deps = [ "//build/images:system_image.meta" ]
  }

  # Extract base package's contents for inspection
  compiled_action("extract_base_package") {
    testonly = true
    tool = "//src/sys/pkg/bin/far:bin"
    tool_output_name = "far"

    args = [
      "extract",
      "--archive=${rebased_files.base_package}",
      "--output=${rebased_files.base_package_dir}",
    ]

    inputs = [ files.base_package ]

    outputs = [
      extracted_files.base_meta_contents,
      extracted_files.base_meta_package,
    ]

    deps = [ ":fuchsia" ]
  }

  verify_files_match("base_pkg_meta_contents_matches") {
    testonly = true
    deps = [
      ":extract_base_package",
      ":extract_old_base_package",
    ]

    first = extracted_files.old_base_meta_contents
    second = extracted_files.base_meta_contents

    display_text_diff_on_failure = true
  }

  verify_files_match("base_pkg_meta_far_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      "//build/images:system_image.meta",
    ]

    first = old_files.base_package
    second = files.base_package
  }
}

verify_files_match("zbi_matches") {
  testonly = true
  deps = [
    ":fuchsia",
    old_labels.zbi,
  ]

  first = old_files.zbi

  if (custom_signing_script != "" || use_vboot) {
    second = files.zbi_signed
  } else {
    second = files.zbi
  }
}

verify_files_match("zbi_manifest_matches") {
  testonly = true
  deps = [
    ":fuchsia",
    old_labels.zbi_manifest,
  ]

  first = old_files.zbi_manifest
  second = files.zbi_manifest

  display_text_diff_on_failure = true
}

if (use_vbmeta) {
  verify_files_match("vbmeta_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      old_labels.vbmeta,
    ]

    first = old_files.vbmeta
    second = files.vbmeta
  }
}

if (uses_base_package) {
  verify_files_match("update_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      old_labels.update_package,
    ]

    first = old_files.update_package
    second = files.update_package
  }

  # Extract update package's contents for inspection
  compiled_action("extract_update_pkg") {
    testonly = true
    tool = "//src/sys/pkg/bin/far:bin"
    tool_output_name = "far"

    args = [
      "extract",
      "--archive=${rebased_files.update_package}",
      "--output=${rebased_files.update_package_dir}",
    ]

    inputs = [ files.update_package ]

    outputs = [
      extracted_files.update_meta_contents,
      extracted_files.update_meta_package,
    ]

    deps = [ ":fuchsia" ]
  }

  # Extract update package's contents for inspection
  compiled_action("extract_prev_update_pkg") {
    testonly = true
    tool = "//src/sys/pkg/bin/far:bin"
    tool_output_name = "far"

    args = [
      "extract",
      "--archive=${rebased_files.old_update_package}",
      "--output=${rebased_files.old_update_package_dir}",
    ]

    inputs = [ old_files.update_package ]

    outputs = [
      extracted_files.old_update_meta_contents,
      extracted_files.old_update_meta_package,
    ]

    deps = [ old_labels.update_package ]
  }

  verify_files_match("update_pkg_meta_contents_matches") {
    testonly = true
    deps = [
      ":extract_prev_update_pkg",
      ":extract_update_pkg",
    ]

    first = extracted_files.old_update_meta_contents
    second = extracted_files.update_meta_contents

    display_text_diff_on_failure = true
  }

  verify_files_match("update_pkg_meta_package_matches") {
    testonly = true
    deps = [
      ":extract_prev_update_pkg",
      ":extract_update_pkg",
    ]

    first = extracted_files.old_update_meta_package
    second = extracted_files.update_meta_package

    display_text_diff_on_failure = true
  }

  verify_files_match("blobfs_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      old_labels.blobfs,
    ]

    first = old_files.blobfs
    second = files.blobfs
  }

  verify_files_match("fvm_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      old_labels.fvm,
    ]

    first = old_files.fvm
    second = files.fvm
  }

  verify_files_match("sparse_fvm_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      old_labels.fvm_sparse,
    ]

    first = old_files.fvm_sparse
    second = files.fvm_sparse
  }

  verify_files_match("sparse_blob_fvm_matches") {
    testonly = true
    deps = [
      ":fuchsia",
      old_labels.fvm_blob_sparse,
    ]

    first = old_files.fvm_blob_sparse
    second = files.fvm_blob_sparse
  }

  if (build_fastboot_fvm) {
    verify_files_match("fastboot_fvm_matches") {
      testonly = true
      deps = [
        ":fuchsia",
        old_labels.fvm_fastboot,
      ]

      first = old_files.fvm_fastboot
      second = files.fvm_fastboot
    }
  }
}
