# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/component/component_id_index.gni")
import("//build/config.gni")
import("//build/dist/generated_resource.gni")
import("//build/drivers/driver_manifest.gni")
import("//build/images/assembly/generated_board_config.gni")
import("//build/images/assembly/generated_product_config.gni")
import("//build/images/collect_blob_manifest.gni")
import("//build/images/fvm.gni")
import("//build/images/manifest.gni")
import("//build/images/pkgfs.gni")
import("//build/images/shell_commands.gni")
import("//build/images/system_image_fuchsia_packages.gni")
import("//build/info/info.gni")
import("//build/packages/package_metadata.gni")
import("//build/security/verify_build.gni")
import("//build/unification/future/images/devmgr_config.gni")
import("//build/zbi/zbi.gni")
import("//build/zbi/zbi_input.gni")
import("//src/sys/pkg/bin/pm/pm.gni")

# Assembles a Fuchsia system.
#
# Given base, cache, and universe packages, assembles a Fuchsia system
# containing those packages.
#
# Parameters
#
#   base_packages (required)
#     [list of labels] The packages to include in the base package set.
#
#   base_driver_packages (optional)
#     [list of labels] The driver packages to include in the base package set.
#
#   cache_packages (optional)
#     [list of labels] The packages to cache in the images.
#
#   universe_packages (optional)
#     [list of labels] The packages to build in addition to the base and cache
#     sets. These packages do not contribute to the produced images directly,
#     however they may contribute to the config-data and shell-commands meta
#     packages.
#
#   bootfs_labels (required)
#     [list of labels] The objects installed on the bootfs partition of the
#     generated ZBI.
#
#   system_image_deps (optional)
#     [list of labels] The objects installed in the system image.
#
#   ramdisk_fvm_in_zbi (default: false)
#     [boolean] Whether the generated ZBI should contain the system's FVM as a ramdisk.
#
#   devmgr_config (default: [])
#     [list of strings] List of arguments to add to /boot/config/devmgr.
#     These arguments come after synthesized arguments to configure blobfs and
#     pkgfs.
#
#   sysmgr_golden, sysmgr_golden_warn (optional, default: false)
#     [path, boolean] Passed directly to the config_package template, see //build/config.gni.
#
#   cmdline (optional)
#     [list of strings] Kernel command line text.
#
#   cmdline_inputs (optional)
#     [list of files] Input files treated as kernel command line text.
#
#   compress_blobs (default: true)
#     [boolean] Whether the blobs added to the blobfs image should be compressed.
#
#   blob_layout_format (default: "compact")
#     [string] The format blobfs should store blobs in. The valid values are "deprecated_padded" and
#     "compact". The deprecated padded format is supported only for Astro devices and will be
#     removed in the future (it wastes space).
#
#   output_dir (optional; default: target_out_dir)
#     [string] The output directory into which the final system ZBI is written.
#
#   output_name (optional; default: <target_name>.zbi)
#     [string] The name of the final system ZBI file.
#
#   cmdline_goldens (optional)
#     [list of files] A list of possible kernel cmdline golden file to compare
#     against. Verified if matches one of the goldens. At most two entries are
#     supported for soft migration, if the content matches either of the entries,
#     it is consider a match. Only one entry should be used for normal case.
#
#   bootfs_goldens (optional)
#     [list of files] A list of possible bootFS golden file to compare against.
#     Verified if matches one of the goldens. At most two entries are
#     supported for soft migration, if the content matches either of the entries,
#     it is consider a match. Only one entry should be used for normal case.
#
#   static_pkgs_goldens (optional)
#     [list of files] A list of possible static pkgs golden file to compare
#     against. Verified if matches one of the goldens. At most two entries are
#     supported for soft migration, if the content matches either of the entries,
#     it is consider a match. Only one entry should be used for normal case.
#
#   include_component_id_index (default: false)
#     [bool] Collect and merges a component id index from the base
#     package set.
#
#   check_production_tag (default: false)
#      [bool] Whether to check there is no non_production_tag dependencies.
#
#   include_shell_commands (default: true)
#      [bool] Whether to include shell commands. Should be set to false for
#      build without shell access.
#
#   testonly (optional)
#     [bool] Usual GN meanings.
template("assemble_system") {
  image_name = target_name

  # Internal labels used for Image Assembly.
  labels = {
    product_config = "${image_name}_product_config"
    board_config = "${image_name}_board_config"
    image_assembler = "${image_name}_image_assembler"
    copy_images = "${image_name}_copy_images"
    config_data = "${image_name}_config-data"
    minfs = "${image_name}_data.blk"
    shell_commands = "${image_name}_shell_commands"
  }

  # Intermediate files produced for Image Assembly.
  files = {
    product_config = "$target_out_dir/${image_name}_product_config.json"
    board_config = "$target_out_dir/${image_name}_board_config.json"
    zbi = "$target_out_dir/${image_name}/${image_name}.zbi"
    blobfs_manifest = "$target_out_dir/${image_name}/gen/blob.manifest"
    minfs = "$target_out_dir/${image_name}_data.blk"
  }

  assert(defined(invoker.base_packages), "Need to define base_packages")
  assert(defined(invoker.bootfs_labels), "Need to define bootfs_labels")

  _base_packages = invoker.base_packages
  _base_driver_packages = []
  _cache_packages = []
  _universe_packages = []
  if (defined(invoker.base_driver_packages)) {
    _base_driver_packages = invoker.base_driver_packages
  }
  _base_packages += _base_driver_packages

  if (defined(invoker.cache_packages)) {
    _cache_packages = invoker.cache_packages
  }
  if (defined(invoker.universe_packages)) {
    _universe_packages = invoker.universe_packages
  }

  system_image_deps = []
  if (defined(invoker.system_image_deps)) {
    system_image_deps += invoker.system_image_deps
  }

  ramdisk_fvm_in_zbi = false
  if (defined(invoker.ramdisk_fvm_in_zbi)) {
    ramdisk_fvm_in_zbi = invoker.ramdisk_fvm_in_zbi && !bootfs_only
  }

  compress_blobs = true
  if (defined(invoker.compress_blobs)) {
    compress_blobs = invoker.compress_blobs
  }

  blob_layout_format = "compact"
  if (defined(invoker.blob_layout_format)) {
    blob_layout_format = invoker.blob_layout_format
  }

  devmgr_config = []
  if (defined(invoker.devmgr_config)) {
    devmgr_config = invoker.devmgr_config
  }

  include_shell_commands = true
  if (defined(invoker.include_shell_commands)) {
    include_shell_commands = invoker.include_shell_commands
  }

  # Generate the base driver manifest file that lists all available drivers
  # collected from _base_driver_packages dependency tree. This manifest file
  # will be included in the driver-manager-base-config package.
  base_driver_manifest_label = "${target_name}_base-driver-manifest"
  combined_driver_manifest(base_driver_manifest_label) {
    forward_variables_from(invoker, [ "testonly" ])
    manifest_name = "base-driver-manifest"
    deps = _base_driver_packages
  }

  # The driver-manager-base-config package is read by Driver Manager to
  # discover where the base drivers are located.
  driver_manager_base_config_label = "${target_name}_driver-manager-base-config"
  fuchsia_package(driver_manager_base_config_label) {
    forward_variables_from(invoker, [ "testonly" ])
    package_name = "driver-manager-base-config"
    deps = [ ":${base_driver_manifest_label}" ]
  }
  _base_packages += [ ":${driver_manager_base_config_label}" ]

  # TODO(fxbug.dev/81290): Construct the shell commands package in the Image
  # Assembler.
  if (include_shell_commands) {
    shell_commands(labels.shell_commands) {
      package_name = "shell-commands"
      forward_variables_from(invoker, [ "testonly" ])
      visibility = [ ":*" ]
      deps = _base_packages + _cache_packages + _universe_packages
    }
  }

  # For details, see //docs/development/components/component_id_index.md#system-assembly
  component_id_index_config("${image_name}_component_id_index_config") {
    forward_variables_from(invoker, [ "testonly" ])

    # collect and merge component ID indices from the base set.
    deps = _base_packages
  }

  component_id_index_dep = []
  component_id_index_config_data_dep = []
  if (defined(invoker.include_component_id_index) &&
      invoker.include_component_id_index) {
    component_id_index_dep = [ ":${image_name}_component_id_index_config" ]
    component_id_index_config_data_dep =
        [ ":${image_name}_component_id_index_config-config-data" ]
  }

  config_package(labels.config_data) {
    package_name = "config-data"
    forward_variables_from(invoker, [ "testonly" ])
    visibility = [ ":*" ]
    deps = _base_packages + _cache_packages + _universe_packages +
           component_id_index_config_data_dep
    if (defined(invoker.sysmgr_golden)) {
      sysmgr_golden = invoker.sysmgr_golden
    }
    if (defined(invoker.sysmgr_golden_warn)) {
      sysmgr_golden_warn = invoker.sysmgr_golden_warn
    }
  }

  compiled_action(labels.minfs) {
    data_image_path = "$target_out_dir/${target_name}"
    visibility = [ ":*" ]
    forward_variables_from(invoker, [ "testonly" ])
    outputs = [ data_image_path ]
    tool = "//zircon/tools/minfs"
    args = [
      rebase_path(data_image_path, root_build_dir),
      "create",
    ]
  }

  #######
  # Build the images using the Image Assembler.
  #

  generated_product_config(labels.product_config) {
    forward_variables_from(invoker, [ "testonly" ])

    output_path = files.product_config
    kernel_image = "//zircon/kernel"

    base_packages = _base_packages
    base_packages += component_id_index_dep
    base_packages += [
      ":${labels.config_data}",
      pkgfs_package_label,
    ]
    if (include_shell_commands) {
      base_packages += [ ":${labels.shell_commands}" ]
    }

    cache_packages = _cache_packages
    boot_args = devmgr_config

    # Search for BootFS files in these targets.
    bootfs_labels = invoker.bootfs_labels
    bootfs_labels += component_id_index_dep
    bootfs_labels += [
      "//src/sys/base-resolver:bootfs",
      "//zircon/kernel",
    ]

    if (ramdisk_fvm_in_zbi) {
      bootfs_labels += [ "//src/storage/fshost:minfs_ramdisk" ]
    }
    extra_base_deps = system_image_deps

    # Search for the Kernel cmdline in the BootFS dependencies.
    cmdline_deps = invoker.bootfs_labels
    if (defined(invoker.cmdline)) {
      cmdline = invoker.cmdline
    }
  }

  generated_board_config(labels.board_config) {
    forward_variables_from(invoker, [ "testonly" ])
    board_name = "${image_name}"
    output_path = files.board_config
    zbi_name = "${image_name}"

    # minfs arguments
    if (!bootfs_only) {
      minfs = rebase_path(files.minfs, root_out_dir)
      deps = [ ":${labels.minfs}" ]
    }

    # blobfs arguments
    blob_layout_format = blob_layout_format
    compress_blobs = compress_blobs

    # fvm arguments
    embed_fvm_in_zbi = ramdisk_fvm_in_zbi
    if (!bootfs_only) {
      fvm_slice_size = 1048576
    }
  }

  check_production_tag = false
  if (defined(invoker.check_production_tag)) {
    check_production_tag = invoker.check_production_tag
  }

  ffx_action(labels.image_assembler) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                             "visibility",
                           ])
    metadata = {
      # We insert these barriers to prevent the dependencies of these images
      # from leaking into images "higher up" in the dependency chain.
      package_barrier = []
      config_package_barrier = []
      distribution_entries_barrier = []

      if (defined(invoker.metadata)) {
        forward_variables_from(invoker.metadata, "*")
      }
    }

    # TODO(fxbug.dev/77290) - Add depfile support and then remove the following
    hermetic_deps = false

    outdir = "$target_out_dir/$image_name"
    gendir = "$outdir/gen"
    args = [
      "--config",
      "assembly_enabled=true",
      "assembly",
      "image",
      "--product",
      rebase_path(files.product_config, root_build_dir),
      "--board",
      rebase_path(files.board_config, root_build_dir),
      "--gendir",
      rebase_path(gendir, root_build_dir),
      "--outdir",
      rebase_path(outdir, root_build_dir),
    ]

    deps = [
      ":${labels.board_config}",
      ":${labels.product_config}",
    ]

    inputs = [
      files.board_config,
      files.product_config,
    ]

    # zbi outputs
    outputs = [
      files.zbi,
      "${gendir}/zbi.json",
      "${outdir}/update.far",
    ]

    # Base package outputs, if this configuration uses them.
    if (!bootfs_only) {
      outputs += [
        "${outdir}/base.far",
        "${outdir}/blob.blk",
        "${outdir}/fvm.blk",
        "${outdir}/fvm.sparse.blk",
        "${outdir}/fvm.blob.sparse.blk",

        # intermediate outputs that are in gendir:
        files.blobfs_manifest,
        "${gendir}/data/static_packages",
        "${gendir}/data/cache_packages",
        "${gendir}/system_image/meta/package",
        "${gendir}/update/meta/package",
      ]
    }

    if (check_production_tag) {
      assert_no_deps = [ "//build/validate:non_production_tag" ]
    }
  }

  #######
  # Optionally, copy the resulting ZBI to the specified directory.
  #

  if (defined(invoker.output_dir)) {
    assert(
        invoker.output_dir != target_out_dir,
        "The specified output directory must be different from the default target_out_dir")
    out = get_target_outputs(":${labels.image_assembler}")
    zbi = out[0]

    # The output name is the same as the original file by default.
    output_name = "${image_name}.zbi"
    if (defined(invoker.output_name)) {
      output_name = invoker.output_name
    }

    copy(labels.copy_images) {
      sources = [ zbi ]
      outputs = [ "${invoker.output_dir}/${output_name}" ]
      deps = [ ":${labels.image_assembler}" ]
    }
  }

  #######
  # Check the golden files.
  #

  if (defined(invoker.cmdline_goldens)) {
    verify_kernel_cmdline("${image_name}_cmdline_verify_files") {
      forward_variables_from(invoker, [ "testonly" ])
      zbi = files.zbi
      goldens = invoker.cmdline_goldens
      zbi_target = ":${labels.image_assembler}"
    }
  }
  if (defined(invoker.bootfs_goldens)) {
    verify_bootfs_filelist("${image_name}_bootfs_verify_files") {
      forward_variables_from(invoker, [ "testonly" ])
      zbi = files.zbi
      goldens = invoker.bootfs_goldens
      zbi_target = ":${labels.image_assembler}"
    }
  }
  if (defined(invoker.static_pkgs_goldens)) {
    verify_static_pkgs("${image_name}_static_pkgs_verify_files") {
      forward_variables_from(invoker, [ "testonly" ])
      zbi = files.zbi
      zbi_target = ":${labels.image_assembler}"
      blobfs_manifest = files.blobfs_manifest
      blobfs_manifest_target = ":${labels.image_assembler}"
      goldens = invoker.static_pkgs_goldens
    }
  }

  group(image_name) {
    forward_variables_from(invoker, [ "testonly" ])

    # public_deps is used, so that the outputs of these dependencies are
    # available to external targets.
    public_deps = [ ":${labels.image_assembler}" ]
    if (defined(invoker.output_dir)) {
      public_deps += [ ":${labels.copy_images}" ]
    }

    deps = []
    if (defined(invoker.cmdline_goldens)) {
      deps += [ ":${image_name}_cmdline_verify_files" ]
    }
    if (defined(invoker.bootfs_goldens)) {
      deps += [ ":${image_name}_bootfs_verify_files" ]
    }
    if (defined(invoker.static_pkgs_goldens)) {
      deps += [ ":${image_name}_static_pkgs_verify_files" ]
    }
  }
}
