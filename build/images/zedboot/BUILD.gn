# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/images/args.gni")
import("//build/images/assemble_system.gni")
import("//build/images/custom_signing.gni")
import("//build/images/vbmeta.gni")
import("//build/images/vboot/vboot.gni")
import("//build/images/zedboot/zedboot_args.gni")
import("//src/sys/root/build/root.gni")

root_realm("root") {
  core_package_name = "core-invalid"
}

# Zedboot must be included to pave devices until recovery has a replacement
# mechanism. Products can specify recovery_label to determine which
# image to include in zircon-r.
use_zedboot_as_recovery = false
zedboot_metadata_slot = "zedboot"
if (get_label_info(recovery_label, "label_with_toolchain") ==
    get_label_info(":zedboot", "label_with_toolchain")) {
  use_zedboot_as_recovery = true
  zedboot_metadata_slot = "zircon-r"
}

##################################################
# Old assembly
##################################################

import("//build/component/component_id_index.gni")
import("//build/unification/future/images/devmgr_config.gni")
import("//build/zbi/kernel_cmdline.gni")
import("//build/zbi/zbi.gni")

# Base system.
zedboot_labels = []
zedboot_labels += [
  ":root",
  "//build/info:bootfs",
  "//bundles:bootstrap-zedboot",
  "//bundles/drivers:bootstrap",
  "//bundles/drivers:usb-host-stack",
  "//bundles/drivers:usb-peripheral-stack",
  "//bundles/drivers:utils",
]

# Needed for installer runs.
zedboot_labels += [
  "//src/storage/bin/disk-pave:install-disk-image",
  "//src/storage/bin/mount",
  "//src/sys/installer:bin",
]

# For debugging.
zedboot_labels += [
  "//src/bringup/bin/virtcon:bootfs",
  "//src/connectivity/network/bin/ping",
  "//src/devices/nand/bin/nand-util",
  "//src/devices/nand/drivers/broker:nand-broker",
  "//src/diagnostics/bundles:bootstrap",
  "//src/security/bin/syscall-check",
  "//src/storage/bin/dd",
  "//src/storage/bin/umount",
  "//src/sys/bin/psutils:killall",
  "//src/sys/bin/psutils:ps",
  "//src/sys/bin/psutils:threads",
  "//src/zircon/bin/ktrace",
  "//zircon/third_party/uapp/dash",
]

# Component manager configuration.
component_id_index_config("component_id_index") {
  testonly = true
  deps = zedboot_labels
}
zedboot_deps = zedboot_labels + [
                 "//src/sys/component_manager:component_manager_bootfs_config",
                 "//build/images/zedboot:component_id_index",
               ]

# Zedboot must be included to pave devices until recovery has a replacement
# mechanism. Products can specify recovery_label to determine which
# image to include in zircon-r.
use_zedboot_as_recovery = false
zedboot_metadata_slot = "zedboot"
if (get_label_info(recovery_label, "label_with_toolchain") ==
    get_label_info(":zedboot", "label_with_toolchain")) {
  use_zedboot_as_recovery = true
  zedboot_metadata_slot = "zircon-r"
}

action("devmgr_config.txt") {
  visibility = [
    ":devmgr_config",
    ":zbi",
    ":zedboot.vbmeta",
    ":zedboot.vbmeta__vb_desc",
    ":zedboot.vbmeta__zbi_props",
  ]

  script = "../manifest.py"
  outputs = [ "$target_out_dir/$target_name" ]

  args = [ "--output=" + rebase_path(outputs[0], root_build_dir) ]
  entries = [
              "netsvc.netboot=true",
              "netsvc.all-features=true",
            ] + zedboot_devmgr_config
  foreach(entry, entries) {
    args += [ "--entry=$entry" ]
  }
}

devmgr_config("devmgr_config") {
  label = ":devmgr_config.txt"
}

kernel_cmdline("cmdline") {
  args = [
    "console.shell=true",
    "netsvc.disable=false",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "virtcon.colorscheme=special",
  ]
  deps = [ "//build/validate:non_production_tag" ]
}

# Note: This output is also used by a script in //scripts/verify_cmdline_params.
zbi("zbi") {
  output_name = "zedboot"
  output_dir = root_out_dir
  testonly = true

  deps = [
    ":cmdline",
    "//build/input:zedboot_bootfs",
    "//src/sys/installer:bin",
    "//zircon/kernel",
  ]
  deps += zedboot_deps
  deps += [ ":devmgr_config" ]

  metadata = {
    images = [
      {
        label = get_label_info(":$target_name", "label_with_toolchain")
        if (custom_signing_script == "" && !use_vboot) {
          archive = true
          if (use_zedboot_as_recovery) {
            bootserver_pave = [ "--zirconr" ]
            if (zircon_r_partition != "") {
              fastboot_flash = [ zircon_r_partition ]
            }
          }
          bootserver_pave_zedboot = [ "--zircona" ]
        }
        name = zedboot_metadata_slot
        path = "zedboot.zbi"
        type = "zbi"
      },
    ]

    if (custom_signing_script == "" && !use_vboot) {
      update_target = [ "zedboot=zedboot.zbi" ]
    }
    image_paths = [ "IMAGE_ZEDBOOT_ZBI=zedboot.zbi" ]
    if (use_zedboot_as_recovery) {
      image_paths += [ "IMAGE_ZIRCONR_ZBI=zedboot.zbi" ]
    }
  }
}

if (custom_signing_script != "") {
  custom_signed_zbi("signed") {
    output_name = "zedboot.zbi"
    deps = [ ":zbi" ]
    testonly = true

    zbi_outputs = get_target_outputs(":zbi")
    zbi = [ zbi_outputs[0] ]

    metadata = {
      images = [
        {
          label = get_label_info(":$target_name", "label_with_toolchain")
          archive = true
          if (use_zedboot_as_recovery) {
            mkzedboot_mode = [ "vboot" ]
            bootserver_pave = [ "--zirconr" ]
            if (zircon_r_partition != "") {
              fastboot_flash = [ zircon_r_partition ]
            }
          }
          name = "${zedboot_metadata_slot}.signed"
          bootserver_pave_zedboot = [ "--zircona" ]
          path = "zedboot.zbi.signed"
          type = "zbi.signed"
        },
      ]
      update_target = [ "zedboot.signed=zedboot.zbi.signed" ]
      if (use_zedboot_as_recovery) {
        mkzedboot_mode = [ "vboot" ]
        image_paths = [ "IMAGE_ZIRCONR_SIGNEDZBI=zedboot.zbi.signed" ]
      }
    }
  }
} else if (use_vboot) {
  vboot("signed") {
    output_name = "zedboot.zbi"
    deps = [ ":zbi" ]
    testonly = true
    metadata = {
      images = [
        {
          label = get_label_info(":$target_name", "label_with_toolchain")
          archive = true
          if (use_zedboot_as_recovery) {
            mkzedboot_mode = [ "vboot" ]
            bootserver_pave = [ "--zirconr" ]
            if (zircon_r_partition != "") {
              fastboot_flash = [ zircon_r_partition ]
            }
          }
          name = "${zedboot_metadata_slot}.signed"
          bootserver_pave_zedboot = [ "--zircona" ]
          path = "zedboot.zbi.signed"
          type = "zbi.signed"
        },
      ]
      update_target = [ "zedboot.signed=zedboot.zbi.signed" ]
      if (use_zedboot_as_recovery) {
        mkzedboot_mode = [ "vboot" ]
        image_paths = [ "IMAGE_ZIRCONR_SIGNEDZBI=zedboot.zbi.signed" ]
      }
    }
  }
}

if (use_vbmeta) {
  vbmeta("zedboot.vbmeta") {
    generate_image = true
    output_name = "zedboot"
    testonly = true
    if (custom_signing_script != "") {
      deps = [ ":signed" ]
      zbi_outputs = get_target_outputs(":signed")
      zbi = [ zbi_outputs[0] ]
    } else {
      deps = [ ":zbi" ]
      zbi_outputs = get_target_outputs(":zbi")
      zbi = [ zbi_outputs[0] ]
    }

    metadata = {
      images = [
        {
          label = get_label_info(":$target_name", "label_with_toolchain")
          archive = true
          if (use_zedboot_as_recovery) {
            bootserver_pave = [ "--vbmetar" ]
            if (vbmeta_r_partition != "") {
              fastboot_flash = [ vbmeta_r_partition ]
            }
          }
          name = zedboot_metadata_slot
          bootserver_pave_zedboot = [ "--vbmetaa" ]
          path = "zedboot.vbmeta"
          type = "vbmeta"
        },
      ]
      if (use_zedboot_as_recovery) {
        image_paths = [ "IMAGE_VBMETAR_RAW=zedboot.vbmeta" ]

        # Only include zedboot as recovery.vbmeta if zedboot is used as recovery
        update_target = [ "recovery.vbmeta=zedboot.vbmeta" ]
      }
    }
  }
}

##################################################
# New assembly
##################################################

# Note: The ZBI output is also used by a script in //scripts/verify_cmdline_params.
assemble_system("zedboot_assembly") {
  testonly = true
  image_name = "zedboot"
  include_component_id_index = true
  include_shell_commands = false
  generate_fvm = false

  base_packages = []

  devmgr_config = [
                    "netsvc.all-features=true",
                    "netsvc.netboot=true",
                  ] + zedboot_devmgr_config

  cmdline = [
    "console.shell=true",
    "netsvc.disable=false",
    "kernel.enable-debugging-syscalls=true",
    "kernel.enable-serial-syscalls=true",
    "virtcon.colorscheme=special",
  ]

  bootfs_labels = [
    ":root",
    "//build/input:zedboot_bootfs",
    "//build/info:bootfs",
    "//bundles:bootstrap-zedboot",
    "//bundles/drivers:bootstrap",
    "//bundles/drivers:usb-host-stack",
    "//bundles/drivers:usb-peripheral-stack",
    "//bundles/drivers:utils",
    "//src/sys/component_manager:component_manager_bootfs_config",
    "//src/sys/installer:bin",
  ]

  # Needed for installer runs.
  bootfs_labels += [
    "//src/storage/bin/disk-pave:install-disk-image",
    "//src/storage/bin/mount",
    "//src/sys/installer:bin",
  ]

  # For debugging.
  bootfs_labels += [
    "//src/bringup/bin/virtcon:bootfs",
    "//src/connectivity/network/bin/ping",
    "//src/devices/nand/bin/nand-util",
    "//src/devices/nand/drivers/broker:nand-broker",
    "//src/diagnostics/bundles:bootstrap",
    "//src/security/bin/syscall-check",
    "//src/storage/bin/dd",
    "//src/storage/bin/umount",
    "//src/sys/bin/psutils:killall",
    "//src/sys/bin/psutils:ps",
    "//src/sys/bin/psutils:threads",
    "//src/zircon/bin/ktrace",
    "//zircon/third_party/uapp/dash",
  ]

  # zbi arguments
  if (custom_signing_script != "") {
    zbi_signing_script = custom_signing_script
  } else if (use_vboot) {
    zbi_signing_script = vboot_action.script
    zbi_signing_args = vboot_action.args
  }
}

##################################################
# Verify the assembly outputs are equal
##################################################

files = {
  outdir = "${target_out_dir}/zedboot"
  gendir = "${outdir}/gen"
  zbi = "${outdir}/zedboot.zbi"
  zbi_manifest = "${gendir}/zbi.json"
  zbi_signed = "${outdir}/zedboot.zbi.signed"
}

old_files = {
  outdir = root_build_dir
  zbi = "${outdir}/zedboot.zbi"
  zbi_manifest = "${zbi}.json"
  zbi_signed = "${zbi}.signed"
}

labels = {
  images = ":zedboot_assembly"
}

old_labels = {
  zbi = ":zbi"
  zbi_manifest = zbi
  zbi_signed = ":signed"
}

verify_files_match("zbi_manifest_matches") {
  testonly = true
  deps = [
    labels.images,
    old_labels.zbi_manifest,
  ]

  first = old_files.zbi_manifest
  second = files.zbi_manifest

  display_text_diff_on_failure = true
}

verify_files_match("zbi_matches") {
  testonly = true
  deps = [
    ":zbi_manifest_matches",
    labels.images,
  ]

  if (custom_signing_script != "" || use_vboot) {
    deps += [ old_labels.zbi_signed ]
    first = old_files.zbi_signed
    second = files.zbi_signed
  } else {
    deps += [ old_labels.zbi ]
    first = old_files.zbi
    second = files.zbi
  }
}

if (target_cpu != "arm64" && !use_vboot) {
  esp("esp") {
    output_name = "zedboot"
    cmdline = "efi_cmdline.txt"
    deps = [ ":zbi" ]
    zedboot_zbi_outputs = get_target_outputs(":zbi")
    zedboot = zedboot_zbi_outputs[0]
    testonly = true

    metadata = {
      images = [
        {
          label = get_label_info(":$target_name", "label_with_toolchain")
          mkzedboot_mode = [ "efi" ]
          name = "zedboot-efi"
          path = "zedboot.esp.blk"
          type = "blk"
        },
      ]
      image_paths = [ "IMAGE_ZEDBOOT_ESP=zedboot.esp.blk" ]
    }
  }
}

group("zedboot") {
  deps = [
    ":zbi",
    ":zbi_manifest_matches",
    ":zedboot_assembly",
  ]
  if (target_cpu != "arm64" && !use_vboot) {
    deps += [ ":esp" ]
  }
  if (custom_signing_script != "" || use_vboot) {
    deps += [ ":signed" ]
  }
  if (use_vbmeta) {
    deps += [ ":zedboot.vbmeta" ]
  }
  testonly = true
}
