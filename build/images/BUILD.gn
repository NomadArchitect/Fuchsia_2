# Copyright 2018 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/board.gni")
import("//build/compiled_action.gni")
import("//build/component/component_id_index.gni")
import("//build/config.gni")
import("//build/config/clang/clang.gni")
import("//build/dist/fini_manifest.gni")
import("//build/drivers/driver_manifest.gni")
import("//build/images/args.gni")
import("//build/images/assembly/package_list.gni")
import("//build/images/custom_signing.gni")
import("//build/images/paths.gni")
import("//build/images/shell_commands.gni")
import("//build/images/size_checker/size_checker_input.gni")
import("//build/images/vbmeta.gni")
import("//build/images/vboot/vboot.gni")
import("//build/info/info.gni")
import("//build/packages/package_metadata.gni")
import("//build/product.gni")
import("//build/sdk/config.gni")
import("//build/security.gni")
import("//build/zbi/zbi_input.gni")
import("//build/zircon/tools.gni")
import("//src/sys/pkg/bin/pm/pm.gni")
import("//src/sys/pkg/bin/system-updater/epoch/generate_epoch.gni")

labels = {
  images = "//build/images/fuchsia"
  images_prime = "//build/images/fuchsia:fuchsia_prime"
  images_netboot = "//build/images/fuchsia:netboot"
  base_packages = "//build/images/fuchsia:fuchsia.base_packages"
  cache_packages = "//build/images/fuchsia:fuchsia.cache_packages"
  meta_packages = "//build/images/fuchsia:fuchsia.meta_packages"
}

supports_fastboot_fvm = fvm_partition != "" && !bootfs_only
files = {
  outdir = get_label_info(labels.images, "target_out_dir") + "/fuchsia"
  gendir = "${outdir}/gen"
  minfs = "${outdir}/data.blk"
  blobfs = "${root_out_dir}/obj/build/images/blob.blk"
  flash_manifest =
      "${root_out_dir}/obj/build/images/fuchsia/flash_manifest/flash.json"

  # TODO(https://fxbug.dev/98480) move these to image-relative paths along with tools' usages
  base_package_manifests = "$root_build_dir/base_package_manifests.list"
  cache_package_manifests = "$root_build_dir/cache_package_manifests.list"
  manifests_from_metadata =
      "$root_build_dir/package_manifests_from_metadata.list"
  base_package_names = "$root_build_dir/base_packages.list"
  cache_package_names = "$root_build_dir/cache_packages.list"
  universe_package_names = "$root_build_dir/universe_packages.list"

  if (!bootfs_only) {
    fvm = "${outdir}/fvm.blk"
  }

  if (supports_fastboot_fvm) {
    fvm_fastboot = "${outdir}/fvm.fastboot.blk"
  }
}
if (bootfs_only && !supports_fastboot_fvm) {
  not_needed(files, "*")
}

# Dependencies for all image targets referenced by paver_targets, i.e., the
# images needed by the generated pave scripts.
default_image_deps = [ labels.images ]

board_name_file = "$root_build_dir/board_name"
write_file(board_name_file, "${board_name}")

#####
# These are the package groups that are used to build the system:

group("universe_packages") {
  testonly = fuchsia_zbi_testonly
  visibility = [ ":*" ]
  public_deps = [
    "//:developer_universe_packages",
    "//:legacy_universe_packages",
  ]
}

group("packages") {
  testonly = true
  public_deps = [
    ":universe_packages",
    labels.meta_packages,
  ]
}

#####
# These are lists of the packages in the above groups

package_list_from_assembly("base_packages.list") {
  testonly = true
  system_label = labels.images
  package_set = "base"
  contents = "name"
  outputs = [ files.base_package_names ]
}

package_list_from_assembly("cache_packages.list") {
  testonly = true
  system_label = labels.images
  package_set = "cache"
  contents = "name"
  outputs = [ files.cache_package_names ]
}

generate_package_metadata("universe_packages.list") {
  testonly = true
  visibility = [ ":*" ]
  data_keys = [ "package_names" ]
  outputs = [ files.universe_package_names ]
  deps = [ ":universe_packages" ]
}

group("package_lists") {
  testonly = true
  visibility = [ ":*" ]

  deps = [
    ":all_package_manifests.list",
    ":base_packages.list",
    ":cache_packages.list",
    ":universe_packages.list",
  ]
}

###
### Zircon Boot Images
###

# Used to populate image_paths.sh with the right values to point to the QEMU kernel.
group("qemu-kernel") {
  metadata = {
    image_paths = [ "IMAGE_QEMU_KERNEL_RAW=" +
                    rebase_path(qemu_kernel_file, root_build_dir) ]
  }
  deps = [ qemu_kernel_target ]
}

default_image_deps += [ ":qemu-kernel" ]

# This action runs a script that checks all vtables in fuchsia binaries are
# in readonly data.
action("check_vtables_in_rodata") {
  testonly = true
  hermetic_deps = false
  script = "//scripts/clang/check_vtable_rodata.py"
  outputs = [ "$root_build_dir/$target_name" ]
  depfile = "$root_build_dir/$target_name.d"

  # Ensure that all fuchsia binaries listed in `binaries.json` are created
  # first.
  deps = [ labels.images ]

  args = [
    # Ignore these specific libunwind symbols for now because these are from
    # the libwundind prebuilts used by rust which we do not currently build
    # with relative vtables.
    "--exclude",
    "vtable for libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_x86_64>",
    "--exclude",
    "vtable for libunwind::UnwindCursor<libunwind::LocalAddressSpace, libunwind::Registers_arm64>",

    "--readelf",
    "$rebased_clang_prefix/llvm-readelf",

    # Write to a file.
    "-o",
    rebase_path(outputs[0], root_build_dir),

    # Run in `fuchsia` mode, which looks for `binaries.json` in the provided
    # output directory.
    "fuchsia",

    # Point to the output directory.
    rebase_path("$root_build_dir", root_build_dir),

    "--depfile",
    rebase_path(depfile, root_build_dir),
  ]
}

group("fvm.sparse.blk") {
  testonly = fuchsia_zbi_testonly
  public_deps = [ "${labels.images}" ]
}

group("fvm.blob.sparse.blk") {
  testonly = fuchsia_zbi_testonly
  public_deps = [ "${labels.images}" ]
}

group("fvm.fastboot.blk") {
  testonly = fuchsia_zbi_testonly
  public_deps = [ "${labels.images}" ]
}

group("fuchsia") {
  testonly = fuchsia_zbi_testonly
  public_deps = [ "${labels.images}" ]
}

group("fuchsia.vbmeta") {
  testonly = fuchsia_zbi_testonly
  public_deps = [ "${labels.images}" ]
}

group("signed") {
  testonly = fuchsia_zbi_testonly
  public_deps = [ "${labels.images}" ]
}

# Pseudo-target to record information about the sizes of filesystems assembled
# during the build for later analysis.
# TODO(fxbug.dev/81871): Only include this for builds that generate blobfs
# once this targets is no longer hardcoded in infra.
group("record_filesystem_sizes") {
  testonly = true
  if (!bootfs_only) {
    deps = [ "//build/images/sizes:elf_sizes.json" ]
  }
}

default_image_deps += [ "//build/images/flash" ]

# If a GPT image was specified, make it available as a build artifact.
if (gpt_image != "") {
  copy("gpt") {
    testonly = true
    sources = [ rebase_path(gpt_image, root_build_dir) ]
    outputs = [ "$root_out_dir/gpt.bin" ]

    metadata = {
      images = [
        {
          label = get_label_info(":gpt", "label_with_toolchain")
          archive = true
          name = "gpt"
          path = "gpt.bin"
          type = "bin"
        },
      ]
      image_paths = [ "IMAGE_GPT=gpt.bin" ]
    }
  }

  default_image_deps += [ ":gpt" ]
}

default_image_deps += [ "//build/images/tools:board_tools" ]

default_image_deps += [ ":fastboot_manifest" ]

default_image_deps += [ recovery_label ]

###
### Amber updates.
###

recovery_images_list = root_build_dir + "/recovery_images_list"
generated_file("recovery_images_list") {
  testonly = true
  outputs = [ recovery_images_list ]
  output_conversion = "list lines"
  data_keys = [ "update_target" ]
  deps = [ recovery_label ]
}

generate_epoch("epoch.json") {
  output_file = "${target_out_dir}/${target_name}"
}

# This output is a manifest of manifests that is usable as an input to `pm
# publish -lp`, a tool for publishing a set of packages from a build produced
# list of package manifests.
all_package_manifests_list = root_build_dir + "/all_package_manifests.list"
generate_package_metadata("package_manifests_from_metadata.list") {
  testonly = true
  outputs = [ files.manifests_from_metadata ]
  data_keys = [ "package_output_manifests" ]
  rebase = root_build_dir
  deps = [
    ":packages",
    labels.images,
    labels.images_prime,
  ]
}

package_list_from_assembly("base_package_manifests.list") {
  testonly = true
  system_label = labels.images
  package_set = "base"
  contents = "manifest"
  outputs = [ files.base_package_manifests ]
}

package_list_from_assembly("cache_package_manifests.list") {
  testonly = true
  system_label = labels.images
  package_set = "cache"
  contents = "manifest"
  outputs = [ files.cache_package_manifests ]
}

action("all_package_manifests.list") {
  testonly = true
  script = "//build/cat.sh"
  outputs = [ all_package_manifests_list ]
  deps = [
    ":base_package_manifests.list",
    ":cache_package_manifests.list",
    ":package_manifests_from_metadata.list",
  ]
  args = rebase_path(outputs, root_build_dir)
  sources = []
  foreach(_dep, deps) {
    _dep_outputs = []  # tell gn its ok to rewrite each iteration
    _dep_outputs = get_target_outputs(_dep)
    args += [ rebase_path(_dep_outputs[0], root_build_dir) ]
    sources += [ _dep_outputs[0] ]
  }
}

# initialize and prepare the package repository.
pm_prepare_publish("prepare_publish") {
  testonly = true
}

# publish all packages to the package repository.
pm_publish("publish") {
  testonly = true
  deps = [
    ":all_package_manifests.list",
    ":prepare_publish",
  ]
  inputs = [ all_package_manifests_list ]
}

group("updates") {
  testonly = true
  deps = [
    ":package_lists",
    ":publish",
  ]
}

# Build the UEFI disk image.
# GCE, a consumer of this image, requires it to be named disk.raw
uefi_disk_path = "$target_out_dir/disk.raw"
mkfs_label = "//zircon/third_party/uapp/mkfs-msdosfs($host_toolchain)"
mkfs_out_dir = get_label_info(mkfs_label, "root_out_dir")
mkfs_bin = "$mkfs_out_dir/mkfs-msdosfs"

if (!bootfs_only) {
  fvm_tool_target = "//src/storage/bin/fvm($host_toolchain)"
  fvm_tool_path = get_label_info(fvm_tool_target, "root_out_dir") + "/fvm"
}

compiled_action("uefi-disk") {
  no_output_dir_leaks = false

  deps = [
    "zedboot",
    "//src/firmware/gigaboot:bootloader(//src/firmware/gigaboot:efi_$target_cpu)",
    mkfs_label,
  ]
  if (bootfs_only) {
    deps += [ "bringup" ]
  } else {
    deps += [ labels.images ]
  }
  testonly = true
  tool = "//tools/make-fuchsia-vol"
  inputs = [ mkfs_bin ]
  bootloader_path = "efi_${target_cpu}/boot${target_cpu}.efi"
  if (target_cpu == "arm64") {
    bootloader_path = "efi_${target_cpu}/bootaa64.efi"
  }
  args = [
    "-fuchsia-build-dir",
    rebase_path("$root_build_dir"),
    "-arch",
    target_cpu,
    "-bootloader",
    bootloader_path,
    "-resize",
    "10000000000",  # 10GB
  ]

  if (bootfs_only) {
    args += [ "-ramdisk-only" ]
  } else {
    inputs += [
      fvm_tool_path,
      files.minfs,
      files.blobfs,
    ]
    deps += [
      "//src/storage/bin/fvm:fvm(//build/toolchain:host_x64)",
      labels.images,
    ]
  }

  args += [ rebase_path(uefi_disk_path) ]
  outputs = [ uefi_disk_path ]

  metadata = {
    images = [
      {
        label = get_label_info(":$target_name", "label_with_toolchain")
        archive = false
        name = "uefi-disk"
        path = rebase_path(uefi_disk_path, root_build_dir)
        type = "blk"
      },
    ]
  }
}

group("images") {
  testonly = true
  deps = [
    ":default-images",
    "//build/images/archive:build_args_metadata",
  ]

  if (!bootfs_only) {
    deps += [ labels.images_netboot ]
  }
}

# The default-images target is a dependency of the top level default
# target when appropriate, and contains the minimum set of images that
# are typical given the requested build configuration.
group("default-images") {
  testonly = true

  deps = [
    ":qemu-kernel",
    "//build/images/flash:fastboot_manifest",
    "//build/images/flash:flash_script",
    "//build/images/tools:fastboot",
    recovery_label,
  ]

  if (size_checker_input != {
      }) {
    # Size checks only make sense when bootfs_only is false, since
    # they require system images in addition to the ZBI.
    deps += [ "size_checker:size_report.json" ]
  }

  if (recovery_is_zedboot) {
    deps += [
      "//build/images/archive:paver-script",
      "//build/images/archive:zedboot-script",
      "//build/images/tools:bootserver",
    ]
  }

  if (build_uefi_disk) {
    deps += [ ":uefi-disk" ]
  }

  if (enable_netboot) {
    deps += [ ":netboot-script" ]
  }

  # TODO(fxbug.dev/46415): The build graph for "bringup" (bootfs_only) MUST only
  # contain one zircon-a metadata target, which means that anything
  # reaching fuchsia.zbi must be excluded from the build graph.
  if (!bootfs_only) {
    deps += [
      ":record_filesystem_sizes",
      ":updates",
    ]

    if (!build_sdk_archives) {
      deps += [ "//build/images/flash:product_metadata" ]
    }
  } else {
    deps += [ "//build/images/archive:fastboot-boot-script" ]
  }

  if (check_vtables_in_rodata) {
    deps += [ ":check_vtables_in_rodata" ]
  }

  if (build_usb_installer) {
    deps += [ "//build/installer_images" ]
  }
}

generated_file("image_paths") {
  testonly = true
  outputs = [ "$root_build_dir/image_paths.sh" ]
  output_conversion = "list lines"
  data_keys = [ "image_paths" ]
  deps = [ ":images" ]
}

group("tests") {
  deps = [ "assembly:tests($host_toolchain)" ]
  testonly = true
}
