# Copyright 2021 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/banjo/toolchain.gni")
import("//build/compiled_action.gni")
import("//build/fidl/fidl_library.gni")
import("//build/fidl/toolchain.gni")
import("//build/rust/rustc_library.gni")
import("//build/testing/golden_file.gni")

# Exposes a Banjo library as a FIDL library.
#
# This template is used in the Banjo deprecation project (fxb/67196).
# Banjo sources are processed as FIDL sources, generating a FIDL IR file. That
# file is then fed to fidlgen_banjo which generates bindings identical to the
# ones generated by the legacy banjo tool (as verified by a build step).
#
# This template accepts the same parameters as the `banjo` template, but only
# uses `name` and `sources`.

template("fidl_adapter") {
  not_needed(invoker,
             [
               "disable_verification",
               "needs_composite",
               "sdk_category",
             ])

  main_target_name = "$target_name.fidl"
  library_name = target_name
  if (defined(invoker.name)) {
    library_name = invoker.name
  }

  if (current_toolchain == fidl_toolchain) {
    deps = []
    if (defined(invoker.deps)) {
      foreach(dep, invoker.deps) {
        if (dep == "//sdk/banjo/zx") {
          deps += [ "//zircon/vdso/zx" ]
        } else {
          name = get_label_info(dep, "name")
          dir = get_label_info(dep, "dir")
          deps += [ "$dir:$name.fidl" ]
        }
      }
    }

    fidl_library(main_target_name) {
      name = library_name
      sources = invoker.sources
      should_lint = false
      public_deps = deps
    }
  } else if (is_fuchsia) {
    verify = true
    if (defined(invoker.disable_verification) && invoker.disable_verification) {
      verify = false
    }

    not_needed(invoker, "*")

    original_target_name = target_name

    ir_dep = ":$main_target_name($fidl_toolchain)"
    ir_gen_dir = get_label_info(ir_dep, "target_gen_dir")
    ir_file = "$ir_gen_dir/$main_target_name.fidl.json"

    ##############################################################################
    # C backend

    c_target_name = "${original_target_name}_banjo_c"
    c_fidlgen_target_name = "$c_target_name.gen"
    c_config_target_name = "$c_target_name.config"
    c_verification_target_name = "$c_target_name.verify"

    c_header_path = string_replace(library_name, ".", "/")
    c_header_path = string_replace(c_header_path, "_", "-")
    c_header_include_base = "$target_gen_dir/$c_target_name"
    c_header_file = "$c_header_include_base/$c_header_path/c/banjo.h"

    # Run fidlgen_banjo on the IR and generate C code.
    compiled_action(c_fidlgen_target_name) {
      tool = "//src/devices/tools/fidlgen_banjo:bin"
      tool_output_name = "fidlgen_banjo"

      inputs = [ ir_file ]

      outputs = [ c_header_file ]

      deps = [ ir_dep ]

      args = [
        "--ir",
        rebase_path(ir_file, root_build_dir),
        "--output",
        rebase_path(c_header_file, root_build_dir),
        "--backend",
        "c",
      ]
    }

    c_banjo_dep = ":${target_name}_c_compile($banjo_toolchain)"
    c_banjo_gen_dir = get_label_info(c_banjo_dep, "root_gen_dir")
    c_banjo_header_file = "$c_banjo_gen_dir/$c_header_path/c/banjo.h"

    # Verify that the new-style and old-style bindings are identical.
    golden_file(c_verification_target_name) {
      golden = c_banjo_header_file

      current = c_header_file

      deps = [
        ":$c_fidlgen_target_name",
        c_banjo_dep,
      ]
    }

    # This config ensures dependents can find the generated header within the
    # output directory.
    config(c_config_target_name) {
      include_dirs = [ c_header_include_base ]
    }

    # Exposes the bindings as C sources to the rest of the build.
    # Eventually this target will be surfaced via the `fidl` template.
    source_set(c_target_name) {
      forward_variables_from(invoker, [ "testonly" ])

      public = [ c_header_file ]

      public_configs = [ ":$c_config_target_name" ]

      deps = [ ":$c_fidlgen_target_name" ]
      if (verify) {
        deps += [ ":$c_verification_target_name" ]
      }

      public_deps = []
      if (defined(invoker.deps)) {
        foreach(dep, invoker.deps) {
          if (dep == "//sdk/banjo/zx") {
            public_deps += [ "//zircon/vdso/zx:zx_c" ]
          } else {
            _name = get_label_info(dep, "name")
            _dir = get_label_info(dep, "dir")
            public_deps += [ "$_dir:${_name}_banjo_c" ]
          }
        }
      }
    }

    ##############################################################################
    # Rust backend

    rust_target_name = "${original_target_name}_banjo_rust"
    rust_fidlgen_target_name = "$rust_target_name.gen"
    rust_verification_target_name = "$rust_target_name.verify"

    rust_library_name = "banjo_" + string_replace(library_name, ".", "_")
    rust_file_name = "$rust_library_name.rs"
    rust_source_file = "$target_gen_dir/$rust_file_name"

    # Run fidlgen_banjo on the IR and generate Rust code.
    compiled_action(rust_fidlgen_target_name) {
      tool = "//src/devices/tools/fidlgen_banjo:bin"
      tool_output_name = "fidlgen_banjo"

      inputs = [ ir_file ]

      outputs = [ rust_source_file ]

      deps = [ ir_dep ]

      args = [
        "--ir",
        rebase_path(ir_file, root_build_dir),
        "--output",
        rebase_path(rust_source_file, root_build_dir),
        "--backend",
        "rust",
      ]
    }

    rust_banjo_dep = ":${target_name}_rust_compile($banjo_toolchain)"
    rust_banjo_gen_dir = get_label_info(rust_banjo_dep, "target_gen_dir")
    rust_banjo_source_file = "$rust_banjo_gen_dir/$rust_file_name"

    # Verify that the new-style and old-style bindings are identical.
    golden_file(rust_verification_target_name) {
      golden = rust_banjo_source_file

      current = rust_source_file

      deps = [
        ":$rust_fidlgen_target_name",
        rust_banjo_dep,
      ]
    }

    rustc_library(rust_target_name) {
      forward_variables_from(invoker, [ "testonly" ])

      name = rust_library_name
      version = "0.1.0"
      edition = "2018"

      source_root = rebase_path(rust_source_file)
      sources = [ rust_source_file ]

      output_dir = "$target_out_dir/banjo"

      non_rust_deps = [ ":$rust_fidlgen_target_name" ]
      if (verify) {
        non_rust_deps += [ ":$rust_verification_target_name" ]
      }

      deps = [
        "//src/lib/fuchsia-async",
        "//src/lib/zircon/rust:fuchsia-zircon",
        "//third_party/rust_crates:futures",
      ]

      if (defined(invoker.deps)) {
        foreach(dep, invoker.deps) {
          if (dep == "//sdk/banjo/zx") {
            deps += [ "//zircon/vdso/zx:zx-rustc" ]
          } else {
            _name = get_label_info(dep, "name")
            _dir = get_label_info(dep, "dir")
            deps += [ "$_dir:${_name}_banjo_rust" ]
          }
        }
      }
    }

    ##############################################################################
    # C++ backend

    cpp_target_name = "${original_target_name}_banjo_cpp"
    cpp_mock_target_name = "${original_target_name}_banjo_cpp_mock"
    cpp_public_fidlgen_target_name = "$cpp_target_name.public.gen"
    cpp_private_fidlgen_target_name = "$cpp_target_name.private.gen"
    cpp_mock_fidlgen_target_name = "$cpp_target_name.mock.gen"
    cpp_public_verification_target_name = "$cpp_target_name.public.verify"
    cpp_private_verification_target_name = "$cpp_target_name.private.verify"
    cpp_mock_verification_target_name = "$cpp_target_name.mock.verify"

    cpp_header_path = c_header_path
    cpp_header_include_base = c_header_include_base
    cpp_public_file = "$cpp_header_include_base/$cpp_header_path/cpp/banjo.h"
    cpp_private_file =
        "$cpp_header_include_base/$cpp_header_path/cpp/banjo-internal.h"
    cpp_mock_file = "$cpp_header_include_base/$cpp_header_path/cpp/banjo-mock.h"

    # Run fidlgen_banjo on the IR and generate C++ code.

    compiled_action(cpp_public_fidlgen_target_name) {
      tool = "//src/devices/tools/fidlgen_banjo:bin"
      tool_output_name = "fidlgen_banjo"

      inputs = [ ir_file ]

      outputs = [ cpp_public_file ]

      deps = [ ir_dep ]

      args = [
        "--ir",
        rebase_path(ir_file, root_build_dir),
        "--output",
        rebase_path(cpp_public_file, root_build_dir),
        "--backend",
        "cpp",
      ]
    }

    compiled_action(cpp_private_fidlgen_target_name) {
      tool = "//src/devices/tools/fidlgen_banjo:bin"
      tool_output_name = "fidlgen_banjo"

      inputs = [ ir_file ]

      outputs = [ cpp_private_file ]

      deps = [ ir_dep ]

      args = [
        "--ir",
        rebase_path(ir_file, root_build_dir),
        "--output",
        rebase_path(cpp_private_file, root_build_dir),
        "--backend",
        "cpp_internal",
      ]
    }

    compiled_action(cpp_mock_fidlgen_target_name) {
      tool = "//src/devices/tools/fidlgen_banjo:bin"
      tool_output_name = "fidlgen_banjo"

      inputs = [ ir_file ]

      outputs = [ cpp_mock_file ]

      deps = [ ir_dep ]

      args = [
        "--ir",
        rebase_path(ir_file, root_build_dir),
        "--output",
        rebase_path(cpp_mock_file, root_build_dir),
        "--backend",
        "cpp_mock",
      ]
    }

    cpp_public_banjo_dep = ":${target_name}_cpp_compile($banjo_toolchain)"
    cpp_private_banjo_dep = ":${target_name}_cpp_i_compile($banjo_toolchain)"
    cpp_mock_banjo_dep = ":${target_name}_cpp_mock($banjo_toolchain)"
    cpp_banjo_gen_dir = get_label_info(cpp_public_banjo_dep, "root_gen_dir")
    cpp_public_banjo_header_file =
        "$cpp_banjo_gen_dir/$cpp_header_path/cpp/banjo.h"
    cpp_private_banjo_header_file =
        "$cpp_banjo_gen_dir/$cpp_header_path/cpp/banjo-internal.h"
    cpp_mock_banjo_header_file =
        "$cpp_banjo_gen_dir/$cpp_header_path/cpp/banjo-mock.h"

    # Verify that the new-style and old-style bindings are identical.

    golden_file(cpp_public_verification_target_name) {
      golden = cpp_public_banjo_header_file

      current = cpp_public_file

      deps = [
        ":$cpp_public_fidlgen_target_name",
        cpp_public_banjo_dep,
      ]
    }

    golden_file(cpp_private_verification_target_name) {
      golden = cpp_private_banjo_header_file

      current = cpp_private_file

      deps = [
        ":$cpp_private_fidlgen_target_name",
        cpp_private_banjo_dep,
      ]
    }

    golden_file(cpp_mock_verification_target_name) {
      golden = cpp_mock_banjo_header_file

      current = cpp_mock_file

      deps = [
        ":$cpp_mock_fidlgen_target_name",
        cpp_mock_banjo_dep,
      ]
    }

    source_set(cpp_target_name) {
      forward_variables_from(invoker, [ "testonly" ])

      public = [ cpp_public_file ]

      sources = [ cpp_private_file ]

      # Let dependencies use `#include "$file_stem.h"`.
      public_configs = [ "//build/c:banjo_gen_config" ]

      deps = [
        ":$cpp_private_fidlgen_target_name",
        ":$cpp_public_fidlgen_target_name",
        "//src/zircon/lib/zircon",
      ]

      if (verify) {
        deps += [
          ":$cpp_private_verification_target_name",
          ":$cpp_public_verification_target_name",
        ]
      }

      public_deps = [
        ":$c_target_name",

        # The generated headers #include <ddk/*.h> and #include <ddktl/*.h>
        # files from the libraries (that aren't generated).
        "//src/lib/ddk",
        "//src/lib/ddktl",
        "//zircon/system/ulib/zx",
      ]

      if (defined(invoker.deps)) {
        foreach(dep, invoker.deps) {
          if (dep != "//sdk/banjo/zx") {
            _name = get_label_info(dep, "name")
            _dir = get_label_info(dep, "dir")
            public_deps += [ "$_dir:${_name}_banjo_cpp" ]
          }
        }
      }
    }

    source_set(cpp_mock_target_name) {
      testonly = true

      public = [ cpp_mock_file ]

      deps = [
        ":$cpp_mock_fidlgen_target_name",
        ":$cpp_mock_verification_target_name",
      ]

      public_deps = [
        ":$cpp_target_name",
        "//zircon/system/ulib/fbl",
        "//zircon/system/ulib/mock-function",
        "//zircon/system/ulib/zxtest",
      ]

      if (defined(invoker.deps)) {
        foreach(dep, invoker.deps) {
          if (dep != "//sdk/banjo/zx") {
            _name = get_label_info(dep, "name")
            _dir = get_label_info(dep, "dir")
            public_deps += [ "$_dir:${_name}_banjo_cpp_mock" ]
          }
        }
      }
    }
  } else {
    assert(false,
           "Unable to translate Banjo target to FIDL in $current_toolchain.")
  }
}
