# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/bazel/bazel_inputs.gni")
import("//build/bazel/bazel_workspace.gni")

assert(current_toolchain == default_toolchain,
       "This BUILD.gn file should only be parsed in the default toolchain!")

# A GN target used to generate at GN-gen time a bazel inputs manifest file
# under the following path which is hard-coded in toplevel.WORKSPACE.bazel:
#
# $BUILD_DIR/gen/build/bazel/legacy_ninja_build_outputs.inputs_manifest.json
#
# See bazel_inputs.gni comments for details on the manifest file format,
# and repository_rules.bzl:bazel_inputs_repository() to see how it is parsed
# to generate an external repository for the Bazel project.
#
# It is possible to build this target to ensure that all Ninja outputs seen
# by the Bazel workspace are properly generated, as in:
#
#    fx build build/bazel:legacy_ninja_build_outputs
#
# IMPORTANT: Nothing in the GN graph should depend on this directly, but this
# BUILD.gn file must be reachable from //:* to ensure that it is parsed and
# that this file is generated at `gn gen` time.
#
# Doing so allows breaking the testonly boundary, as required to allow
# non-testonly bazel_build_action() targets to depend on
# :generate_main_workspace below, without depending on this target.
#
bazel_inputs_manifest("legacy_ninja_build_outputs") {
  testonly = true

  # IMPORTANT: Keep this in sync with toplevel.WORKSPACE.bazel
  output = "$root_build_dir/gen/build/bazel/legacy_ninja_build_outputs.inputs_manifest.json"

  # IMPORTANT: All bazel_input_resource_xxx() targets must be reachable
  # from this dependencies list!
  input_deps = [
    "//build/bazel/tests/bazel_input_resource_directory:bazel_inputs",
    "//build/bazel/tests/build_action:bazel_inputs",
  ]
}

# Used by bazel_build_action() to only allow one concurrent `bazel build`
# action at a time during the build, since doing so modifies the workspace,
# in particular the `bazel-bin` symlink that is used to copy the Bazel outputs
# to the Ninja output directory.
pool("build_action_pool") {
  depth = 1
}

action("generate_main_workspace") {
  assert(
      bazel_top_dir == target_gen_dir,
      "Bazel workspace generation action was moved, please update " +
          "//build/bazel/bazel_workspace.gni$0x0aOld bazel_top_dir location " +
          "[${bazel_top_dir}] new location [${target_gen_dir}")

  script = "//build/bazel/scripts/generate-workspace.py"
  inputs = []

  # Location of the Bazel prebuilt binary to invoke.
  _bazel_bin = "//prebuilt/third_party/bazel/${host_os}-${host_cpu}/bazel"

  # This only lists the wrapper script as an output for this script,
  # but it also generates the `workspace` directory, whose content
  # depends on the top-level file and directory entries that appear
  # in the Fuchsia checkout directory and is thus not predictable.
  outputs = [
    "$target_gen_dir/bazel",
    "$target_gen_dir/workspace/WORKSPACE.bazel",
  ]
  args = [
    "--bazel-bin",
    rebase_path(_bazel_bin, root_build_dir),
    "--fuchsia-dir",
    rebase_path("//", root_build_dir),
    rebase_path(target_gen_dir, root_build_dir),
  ]

  # This cannot be hermetic since it creates a collection of
  # symlinks that depends on the state of the source tree.
  #
  # TODO(fxbug.dev/107967): Ensure that the workspace is always
  # re-generated if a top-level directory or file is added to or
  # removed from $FUCHSIA_DIR.
  hermetic_deps = false

  # The generated wrapper includes the absolute path of the Ninja output
  # directory, which will be read by Bazel repository rules during workspace
  # setup.
  no_output_dir_leaks = false
}
