This directory contains _experimental_ support files for using
Bazel with the Fuchsia platform build. Nothing here is final and may break
at any time for now.

# REQUIREMENTS

Have a full Fuchsia platform checkout from Jiri, and run the following
on a Linux build machine (MacOS is not supported at the moment!)

# OVERVIEW

Now that you've been warned, here's how this is supposed to work:

- The `out/default/gen/build/bazel/workspace` directory is used
  as the Bazel workspace for all bazel commands invoked from Ninja.

- The `out/default/gen/build/bazel/output_base` directory is
  used to place all Bazel outputs.

- The `out/default/gen/build/bazel/bazel` wrapper script is used
  to launch a known prebuilt Bazel binary with the right options
  to support this setup, and other requirements of the platform
  build.

- All three are generated by the same script invoked from Ninja,
  (see `//build/bazel/BUILD.gn`). The workspace content has a specific
  layout that mirrors the Fuchsia source tree with a few exceptions:

  - A top-level `BUILD.bazel` symlink to `//build/bazel/toplevel.BUILD.bazel`
    in the source tree.  This is the file you should modify to add new
    top-level targets in the Bazel build graph.

  - A top-level `WORKSPACE.bazel` symlink to
    `//build/bazel/toplevel.WORKSPACE.bazel` in the source tree. This is the
    file you should modify to add new external repositories to the Bazel
    project.

    Also keep this in sync with `//build/bazel/toplevel.MODULE.bazel` which
    will be used in the future when [BzlMod][BzlMod] is enabled to manage
    external dependencies instead or workspace directives.

  - A top-level `.bazelrc` symlink to the build configuration file at
    `//build/bazel/toplevel.bazelrc`. Note that this will likely change in
    the future, since this file's content will need to be generated based on
    configuration options passed to `fint set ...` and `fx set ...` in
    the future.

    Also note that the user's own bazel configuration file (e.g.
    `$HOME/.bazelrc`) will always be ignored.

  - Symlinks to all top-level entries in the Fuchsia source tree, except for
    `out`. This way, any source or configuration file will appear at the same
    exact location during the Bazel and Ninja builds.

    In other words, if you add a file at `$FUCHSIA_DIR/src/foo/BUILD.bazel`,
    it will be visible and will define a Bazel package at `//src/foo:`.

  - The `out` directory is not symlinked intentionally to ensure that Ninja
    outputs are not visible by default.

- The `out/default/gen/build/bazel/legacy_ninja_build_outputs` directory
  contains an external repository that exposes some files generated by Ninja
  that needs to be treated as sources by the Bazel graph.

  For now, its content is generated by a Ninja action that parses
  manifest files generated through GN metadata collection. See the
  corresponding section below.

- Other Bazel external repositories are generated through BzlMod, for
  example the `@prebuilt_clang` repository will provide C++ toolchain
  definitions that use the prebuilt Clang toolchain available from the
  Fuchsia checkout.

- The GN `bazel_build_action()` template can be used to invoke a
  `bazel build ...` command from GN, and copy its outputs to a GN-compatible
  location. See `//build/bazel/bazel_build_action.gni` for details.

  The `//build/bazel/examples/build_action/` directory contains a working
  example, which invokes a Bazel build action from GN, then verifies the
  output.

- For debugging only, the `fx bazel` wrapper tool is provided
  to launch a Bazel command inside the Fuchsia workspace file.

  This requires that the `workspace` and `legacy_ninja_build_outputs`
  are properly generated. This can be done manually with:

```sh
fx build :bazel_workspace
```

  For example, use `fx bazel version` to print information
  about the version number, of `fx bazel workspace` to print
  the absolute path to the workspace.

  And `fx bazel build ...` or `fx bazel query ...` commands will work
  as expected.

# IMPLEMENTATION NOTES

The reasons why the `//build/bazel/toplevel.XXX` files are used, instead
of providing the corresponding files directly at the top of the source tree
are that:

- Developers cannot call Bazel directly from the Fuchsia source tree (which
  otherwise would likely fail with very confusing error messages).

- Bazel's traditional command line interface to configure the build is not
  compatible with the requirements of the Fuchsia platform build. In
  particular, using `--config=fuchsia_arm64` as with the Fuchsia Bazel SDK
  will not work!

- Finally, Bazel support in the Fuchsia platform build is still very
  experimental, and is best considered an implementation detail, hidden
  from developer workflows.

Similarly, the reason why Bazel build artifacts are placed under
`out/default/gen/build/bazel/output_base`, instead of using the standard
location under the user's home directory (e.g. `$HOME/.cache/bazel/`) are:

- This allows `fx clean` to properly remove previous build artifacts.

- This increases the chance of using hard-links when copying Bazel
  build outputs to the Ninja output directory, since in many setups,
  $HOME lives in a different partition / mount point than
  the Fuchsia checkout.

- This prevents filling up the user-specific directory with hundreds
  of GiBs of build artifacts that can be hard to clean up properly
  (e.g. when deleting a Fuchsia checkout directory manually with `rm -rf`).

  In particular, a Bazel module extension is used to generate a repository
  named `@prebuilt_clang` that provides C++ toolchain instances and
  configurations for the build.

- The Fuchsia platform build also relies on the new [Platforms][Platforms]
  feature, which impacts how toolchain selection happens inside a given
  build configuration. See `//build/bazel/platforms/BUILD.bazel` for more
  details.

# NINJA OUTPUTS AS BAZEL INPUTS

The `out/default/gen/build/bazel/legacy_ninja_build_outputs` directory
is used for the special `@legacy_ninja_build_outputs` Bazel repository
to expose Ninja output files as Bazel graph inputs.

It contains a single auto-generated `BUILD.bazel` file, that produces
a set of Bazel `filegroup()` targets that each lists a series of files
that come from the Ninja output directory.

For example a target declaration like the following:

```py
filegroup(
  name = "host_tools",
  srcs = [
    "host_tools/ffx_unversioned"
    "host_tools/zbi",
  ]
)
```

Where `host_tools/ffx_unversioned` and `host_tools/zbi` are paths
relative to the `@legacy_ninja_build_outputs` workspace, that point to
symlinks to `out/default/host_x64/ffx_unversioned` and
`out/default/host_x64/zbi`, respectively.

Note that unlike Ninja, Bazel always follows symlinks when looking at
source files.

For now, the legacy build outputs  workspace content is generated from
a Ninja action, that takes as input a manifest file generated using GN
metadata collection from `bazel_input_resource()` and
`bazel_input_resource_tree()` targets.

As an example, the Bazel filegroup declaration above may come
from the following GN target definition:

```gn
bazel_input_resource_tree("host_tools") {
  sources_root = host_out_dir
  sources = [
    "ffx_unversioned",
    "zbi",
  ]

  # Store everything under `@legacy_ninja_build_outputs//:host_tools/<name>`
  dest_dir = "host_tools"

  deps = [
    "//src/developer/ffx:ffx_bin_unversioned($host_toolchain)",
    "//zircon/tools/zbi:zbi($host_toolchain)",
  ]
}
```

For details see the comments in `//build/bazel/BUILD.gn` and
the template definitions in `//build/bazel/bazel_inputs.gni`.

Note that this scheme may change in the future, since a drawback of the
current approach is that populating the `@legacy_ninja_build_outputs`
workspace requires running Ninja, which prevents running Bazel queries
_before_ the build.


# BAZEL BUILD ACTION

The `bazel_build_action()` template, defined in
`//build/bazel/bazel_build_action.gni` is used to create a GN action that
will run a `bazel build <targets>` command in the Bazel workspace.

All inputs must be specified from `bazel_input_xxx()` targets, and
the Bazel outputs will be copied (possibly hard-linked) into the
Ninja output repository at a stable location (since GN requires that
an action's target must be in its `target_out_dir` or `target_gen_dir`).

For a concrete example, see `//build/bazel/examples/build_action/` that
contains a working target that invokes a Bazel build command (that simply
copies an input file into a Bazel output), then verify that it worked
properly.

# CLANG TOOLCHAIN REPOSITORY

The Bazel build generates an external repository named `@prebuilt_clang`
that mirrors the content of the host Clang toolchain, and augments it
with Bazel-specific files. These are needed to define C++ toolchain
instances and configurations.

C++ Toolchain selection is performed using the new Bazel
[Platforms][Platforms] toolchain, which is very different to the
traditional use of `--crosstool_top`, which is why using this option
will not work.

Note that this is distinct from sdk-integration's own `@fuchsia_clang`
external repository, which defines a C++ toolchain that generates Fuchsia
binaries (while `@prebuilt_clang` is used to generate host binaries and
experiment with build variants and PIE-optimized executables, without
conflicts).

# TESTING

You can invoke `build/bazel/scripts/test-all.py` to verify that everything
works properly. This is used to verify regressions during development of
Bazel support in the platform build, what is does is:

1) Invoke `build/bazel/scripts/prepare-fuchsia-checkout.py`, unless
   the `--skip-prepare` option is used.

2) Invoke `fx clean` unless `--skip-clean` is used.

3) Try to build Ninja targets that require Bazel actions and verify
   their results (e.g. `fx build build/bazel/examples/build_action`).

4) Try to call the `fx bazel` tool to verify that it can correctly
   build and/or run some artifacts in the Bazel workspace
   (e.g. `fx bazel run //build/bazel/examples/hello_world`).

5) Call the `fx bazel` tool to perform queries to verify that
   the generated workspace and repositories are correct.

Always try to add new tests when introducing new features under //build/bazel/,
and run this script when changing its implementation (for now this is all
manual, but will likely be automated in CQ in the future).

[BzlMod]: https://bazel.build/docs/bzlmod
[Platforms]: https://bazel.build/concepts/platforms-intro
