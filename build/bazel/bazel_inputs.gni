# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

# Expose a set of Ninja output files as a corresponding Bazel filegroup()
# of prebuilt input sources for the Bazel build.
#
# This target can be used as a dependency for the bazel_inputs_workspace()
# template, and works like resource(). Consider using bazel_input_resource_tree()
# if you have multiple source files with non-trivial outputs paths.
#
# This works like the copy() or resource() templates, for example:
#
# ```gn
#   # Expose all outputs generated by :foo in Bazel.
#   bazel_input_resource("foo_files") {
#    deps = [ ":foo" ]
#    sources = get_target_outputs(":foo")
#    outputs = [ "{{source_file_part}}" ]
#  }
#
#  ...
#
#  bazel_inputs_workspace("legacy_ninja_build_outputs")
#    inputs_deps = [ ":foo_files" ]
#  }
# ```
#
# Assuming that :foo generates the following files:
#
#    out/default/gen/src/foo/foo.h
#    out/default/gen/src/foo/foo.cc
#
# Then this will generate something like that in
# `out/default/gen/build/bazel/legacy_ninja_build_outputs/BUILD.bazel` file:
#
# ```bazel
#  filegroup("foo_files") {
#      srcs = [
#        "foo.h",
#        "foo.cc",
#      ]
#  )
# ```
#
# After creating the symlinks as:
#
#  out/default/gen/build/bazel/legacy_ninja_build_outputs/
#    foo.h --> ../../../src/foo/foo.h
#    foo.cc --> ../../../.src/foo/foo.cc
#
# Arguments:
#   name: (optional)
#     Bazel filegroup name for the set of files covered by this target.
#     If not specified, defaults to target_name. Note that the filegroup()
#     will be part of the top-level BUILD.bazel file generated by the
#     build)_inputs_workspace() dependent. This name cannot contain a
#     directory separator or colon.
#     Type: string
#
#   sources
#     Required: List of output files that become $outputs in the Bazel
#     workspace. Technically works with source files as well, but these
#     are already exposed to Bazel by default, and don't need to be
#     listed in a bazel_input_resource() target. See copy() for details.
#     Type: list(file)
#
#   outputs
#     Required: List of one runtime path.  This must be a relative path (no
#     leading `/`).  It can use placeholders based on $sources; see copy()
#     and `gn help source_expansion`.
#     Type: list(path)
#
#   deps
#     Optional: Targets that produce $sources.  Any files listed in
#     $sources that are produced by the build should be produced by a
#     target listed here.
#     Type: list(label)
#
template("bazel_input_resource") {
  _name = target_name
  if (defined(invoker.name)) {
    _name = invoker.name
    assert(string_replace(_name, "/", "") == _name,
           "name cannot contain directory separators: $_name")
    assert(string_replace(_name, ":", "") == _name,
           "name cannot contain colon: $_name")
  }

  _sources = rebase_path(invoker.sources, root_build_dir)
  _dest = process_file_template(invoker.sources, invoker.outputs)

  foreach(dst_path, _dest) {
    assert(
        rebase_path(dst_path, "//") != dst_path,
        "`outputs` in bazel_input_resource() cannot start with /: ${dst_path}")
  }

  group(target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "metadata",
                             "name",
                             "outputs",
                             "sources",
                           ])

    metadata = {
      # Used by bazel_inputs_workspace() template.
      # See its documentation for the metadata schema.
      bazel_inputs = [
        {
          name = _name
          sources = _sources
          destinations = _dest
          gn_label = get_label_info(target_name, "label_with_toolchain")
        },
      ]
      bazel_inputs_barrier = []
    }
  }
}

# bazel_input_resource_tree() is similar to bazel_input_resource() but
# makes it easy to replicate a tree of sources files, relative to a given
# sources path prefix, to a given destination directory.
#
# For example:
#
#      bazel_input_resource_tree("my-resources") {
#        sources_root = "res"
#        sources = [
#          foo.resource",
#          bar/bar-1.resource",
#        ]
#        dest_dir = "data/resources"
#      }
#
# Will declare the following symlinks:
#
#   out/default/bazel/legacy_ninja_build_outputs/
#     data/resources/
#       foo.resource ---> .../res/foo.resource
#       bar/bar.resource ---> .../res/bar/bar.resource
#
# And will generate the following Bazel fragment:
#
#   filegroup("my-resources") {
#       srcs = [
#           "data/resources/foo.resource",
#           "data/resources/bar/bar.resource",
#       ]
#   )
#
# This is difficult to do with resource() because GN source expansion
# cannot preserve the original sources input paths.
#
# This template is useful to avoid calling bazel_input_resource() multiple
# times in a loop when dealing with resource files laid out into different
# sub-directories. Note that the files cannot be renamed though!
#
# Parameters
#   name: (optional)
#     Bazel filegroup name for the set of files covered by this target.
#     If not specified, defaults to target_name. Note that the filegroup()
#     will be part of the top-level BUILD.bazel file generated by the
#     build)_inputs_workspace() dependent. This name cannot contain a
#     directory separator or colon.
#     Type: string
#
#   source_root
#     Optional: A path prefix that is prepended to all items in the 'sources'
#     list. If not specified, the current target's directory is used.
#     Type: string(path)
#
#   sources
#     Required: List of files in the source tree or build that will be
#     installed. Each 'file' item in this list is exposed as
#     '$dest_dir/$file', as a symlink to  '$sources_root/$file'.
#     Note that unlike bazel_input_resource(), there is no way to transform
#     or expand source paths.
#     Type: list(file)
#
#   dest_dir
#     Required: Destination path where all sources are exposed.
#     Cannot start with a "/". Use an empty string to expose files directly
#     to the workspace's top-level directory.
#     Type: string(path)
#
#   deps
#     Optional: Targets that produce $sources.  Any files listed in
#     $sources that are produced by the build should be produced by a
#     target listed here.
#     Type: list(label)
#
template("bazel_input_resource_tree") {
  _name = target_name
  if (defined(invoker.name)) {
    _name = invoker.name
    assert(string_replace(_name, "/", "") == _name,
           "name cannot contain directory separators: $_name")
    assert(string_replace(_name, ":", "") == _name,
           "name cannot contain colon: $_name")
  }
  assert(defined(invoker.sources), "sources is required")
  assert(defined(invoker.dest_dir), "dest_dir is required")
  dest_dir = invoker.dest_dir
  if (dest_dir != "") {
    assert(rebase_path(dest_dir, "foo") != dest_dir,
           "dest_dir cannot start with /: $dest_dir")
    assert(dest_dir != "." && dest_dir != ".." &&
               string_replace(dest_dir, "./", "") == dest_dir,
           "dest_dir cannot contain . or .. path elements: $dest_dir")

    # Add trailing directory separator.
    dest_dir = string_replace(dest_dir + "//", "//", "/")
  }

  if (defined(invoker.sources_root)) {
    assert(invoker.sources_root != "", "sources_root cannot be empty!")
    sources_prefix = invoker.sources_root

    # Append trailing separator if needed
    if (string_replace(sources_prefix + "###", "/###", "") ==
        sources_prefix + "###") {
      sources_prefix += "/"
    }
  } else {
    sources_prefix = ""
  }

  _name = target_name
  if (defined(invoker.name)) {
    _name = invoker.name
    assert(string_replace(_name, "/", "") == _name,
           "name cannot contain directory separators: $_name")
    assert(string_replace(_name, ":", "") == _name,
           "name cannot contain colon: $_name")
  }

  _sources = []
  _dest = []
  foreach(_source, invoker.sources) {
    _sources += [ dest_dir + _source ]
    _dest += [ rebase_path(sources_prefix + _source, root_build_dir) ]
  }

  group(target_name) {
    forward_variables_from(invoker,
                           "*",
                           [
                             "dest_dir",
                             "metadata",
                             "sources",
                             "sources_root",
                           ])
    metadata = {
      # Used by bazel_inputs_workspace() template.
      bazel_inputs = [
        {
          name = _name
          sources = _sources
          destinations = _dest
          gn_label = get_label_info(target_name, "label_with_toolchain")
        },
      ]
      bazel_inputs_barrier = []
    }
  }
}

# bazel_input_resource_directory() is used to the content of an output
# directory as a Bazel input filegroup. Instead of passing a list of source
# files, `source_root` source point to a directory whose content will
# be symlinks into a bazel_build_inputs_workspace().
#
# IMPORTANT: This is not hermetic, and can lead to incorrect results during
# incremental builds, unless the directory's content is always cleared
# before the Ninja action that generates its content is run.
#
# For example:
#
#    bazel_input_resource_directory"my-generated-resources") {
#      source_dir = get_label_info(":resource-generator", "target_gen_dir")
#      dest_dir = "data/resources"
#      deps = [ Â¨:resource-generator" ]
#    }
#
# Parameters
#   name: (optional)
#     Bazel filegroup name for the set of files covered by this target.
#     If not specified, defaults to target_name. Note that the filegroup()
#     will be part of the top-level BUILD.bazel file generated by the
#     build)_inputs_workspace() dependent. This name cannot contain a
#     directory separator or colon.
#     Type: string
#
#   source_dir
#     Required: GN path to the source directory that contains all outputs
#     files to be exposed as a Bazel filegroup().
#     Type: string(path)
#
#   dest_dir
#     Required: Destination path where all sources are exposed.
#     Cannot start with a "/". Use an empty string to expose files directly
#     to the workspace's top-level directory.
#     Type: string(path)
#
#   deps
#     Optional: Targets that produce $sources.  Any files listed in
#     $sources that are produced by the build should be produced by a
#     target listed here.
#     Type: list(label)
#
template("bazel_input_resource_directory") {
  _name = target_name
  if (defined(invoker.name)) {
    _name = invoker.name
    assert(string_replace(_name, "/", "") == _name,
           "name cannot contain directory separators: $_name")
    assert(string_replace(_name, ":", "") == _name,
           "name cannot contain colon: $_name")
  }
  assert(defined(invoker.dest_dir), "dest_dir is required")
  dest_dir = invoker.dest_dir
  if (dest_dir != "") {
    assert(rebase_path(dest_dir, "foo") != dest_dir,
           "dest_dir cannot start with /: $dest_dir")
    assert(dest_dir != "." && dest_dir != ".." &&
               string_replace(dest_dir, "./", "") == dest_dir,
           "dest_dir cannot contain . or .. path elements: $dest_dir")

    # Add trailing directory separator.
    dest_dir = string_replace(dest_dir + "//", "//", "/")
  }

  group(target_name) {
    forward_variables_from(invoker,
                           [
                             "deps",
                             "testonly",
                             "visibility",
                           ])
    metadata = {
      # Used by bazel_inputs_workspace() template.
      bazel_inputs = [
        {
          name = _name
          source_dir = rebase_path(invoker.source_dir, root_build_dir)
          dest_dir = dest_dir
          gn_label = get_label_info(target_name, "label_with_toolchain")
        },
      ]
      bazel_inputs_barrier = []
    }
  }
}

# Generate a Bazel workspace that contains a symlink tree to Ninja
# build output files, which will be treated as prebuilt inputs by
# the Bazel build.
#
# Args:
#   inputs_deps:
#     A list of GN labels that point to bazel_input_xxx() targets,
#     each one of them describing a group of files to be visible in the
#     generated workspace (as a Bazel filegroup()). Note thata these
#     label names are used directly as the names of the filegroups.
#
template("bazel_inputs_workspace") {
  # Generate a single manifest file that collects all bazel_input_xxx()
  # resources. Each metadata entry is a scope that describes a single
  # Bazel filegroup() target that will appear at the top of the
  # auto-generated workspace.
  #
  # There are two types of entries:
  #
  # ## REGULAR ENTRIES
  #
  #   name: (required)
  #      Bazel filegroup name.
  #      Type: string
  #
  #   destinations: (required)
  #      List of input files, relative to the top of the generated workspace.
  #      Each one will appear in the `srcs` list of the corresponding
  #      filegroup.
  #
  #   sources: (required)
  #      List of source files for the filegroup. Must have the same
  #      size as the `destinations` list.
  #      Type: list of paths relative to the root_build_dir
  #
  #   gn_label: (optional)
  #      GN label of target that defines this entry. Only used for
  #      debugging the build, completely ignored otherwise.
  #      Type: GN label string
  #
  # ## DIRECTORY ENTRIES
  #
  #   name: (required)
  #      Bazel filegroup name.
  #      Type: string
  #
  #   source_dir: (required)
  #      A source directory path, relative to the Ninja build output
  #      directory, which will contain all input files for the Bazel
  #      filegroup().
  #
  #   dest_dir: (required)
  #      A directory prefix for all input files, relative to the top of
  #      the generated workspace. This will be a symlink to source_dir,
  #      and the filegroup() will use a glob(["<dest_dir>/*"]) call to get all
  #      files in it.
  #
  #   gn_label: (optional)
  #      GN label of target that defines this entry. Only used for
  #      debugging the build, completely ignored otherwise.
  #      Type: GN label string
  #
  generated_file_target = "${target_name}.inputs_manifest"
  generated_file_path = "${target_gen_dir}/${generated_file_target}.json"

  generated_file(generated_file_target) {
    forward_variables_from(invoker, [ "testonly" ])
    outputs = [ generated_file_path ]
    data_keys = [ "bazel_inputs" ]
    walk_keys = [ "bazel_inputs_barrier" ]
    deps = invoker.input_deps
    output_conversion = "json"
  }

  workspace_dir = "$target_gen_dir/$target_name"

  action(target_name) {
    forward_variables_from(invoker, [ "testonly" ])
    script = "//build/bazel/scripts/generate-build-inputs-workspace.py"

    outputs = [
      "${workspace_dir}/BUILD.bazel",
      "${workspace_dir}/MODULE.bazel",
      "${workspace_dir}/WORKSPACE.bazel",
    ]

    inputs = [ generated_file_path ]

    args = [
      "--workspace-dir",
      rebase_path(workspace_dir, root_build_dir),
      "--repository-name",
      target_name,
      "--input-manifest",
      rebase_path(inputs[0], root_build_dir),
      "--source-dir",
      rebase_path(root_build_dir, root_build_dir),
    ]

    # This action cannot be hermetic because it creates output files
    # whose list depend on the content of the manifest generated
    # by input_deps targets. The manifests themselves are already
    # known from `all_files` and don't need to be listed in a depfile.
    #
    # All files should be symlink and are final outputs, from the
    # point of view of the Ninja build system (i.e. they are never
    # used as direct inputs from other Ninja actions) so this
    # should not be an issue.
    #
    # Unlike Ninja, Bazel will look at the timestamps of symmlink
    # targets, not those of the symlink themselves, so any change
    # in a real Ninja output file will be detected by Bazel
    # properly.
    #
    hermetic_deps = false

    deps = [ ":$generated_file_target" ]
  }
}
