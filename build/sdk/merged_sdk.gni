# Copyright 2019 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("config.gni")

# Aggregates multiple SDKs into a single archive.
#
# Parameters
#
#   deps (required)
#     List of labels representing SDKs to merge.
#     A label may point to an `sdk` or a `merged_sdk` instance.

template("merged_sdk") {
  assert(defined(invoker.deps), "Must define a 'deps' parameter")
  assert(invoker.deps != [], "'deps' may not be empty")

  if (!build_sdk_archives) {
    # This template is a no-op if SDK archives are not emitted.
    group(target_name) {
      forward_variables_from(invoker, [ "testonly" ])
      deps = invoker.deps
    }
  } else {
    index = 0
    latest_archive = ""
    latest_step = ""
    foreach(dep, invoker.deps) {
      archive_dir = "${root_out_dir}/sdk/archive"
      name = get_label_info(dep, "name")
      dep_archive = "${archive_dir}/$name.tar.gz"

      if (index == 0) {
        latest_archive = dep_archive
      } else {
        merged_archive = "$target_gen_dir/$target_name.$index.tar.gz"
        step = "${target_name}_merge_${index}"

        action(step) {
          forward_variables_from(invoker, [ "testonly" ])

          #TODO(b/222339823): Switch to Rust merge tool when fixed.
          script = "//scripts/sdk/merger/merge.py"

          sources = [
            dep_archive,
            latest_archive,
          ]

          outputs = [ merged_archive ]

          args = [
            "--first-archive",
            rebase_path(latest_archive, root_build_dir),
            "--second-archive",
            rebase_path(dep_archive, root_build_dir),
            "--output-archive",
            rebase_path(merged_archive, root_build_dir),
          ]

          if (index == 1) {
            public_deps = invoker.deps
          } else {
            public_deps = [ ":$latest_step" ]
          }
        }

        latest_archive = merged_archive
        latest_step = step
      }

      index = index + 1
    }

    copy(target_name) {
      forward_variables_from(invoker, [ "testonly" ])
      output_archive = "${root_out_dir}/sdk/archive/${target_name}.tar.gz"

      sources = [ latest_archive ]

      outputs = [ output_archive ]

      public_deps = [ ":$latest_step" ]

      metadata = {
        sdk_archives = [
          {
            name = target_name
            os = current_os
            cpu = current_cpu
            label = get_label_info(":$target_name", "label_with_toolchain")
            path = rebase_path(output_archive, root_build_dir)
          },
        ]
      }
    }
  }
}
