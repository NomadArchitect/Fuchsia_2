# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/compiled_action.gni")
import("//build/go/go_binary.gni")
import("//build/go/go_library.gni")
import("//build/testing/golden_file.gni")
import("//tools/fidl/lib/fidlgentest/fidlgentest_go_test.gni")

group("tests") {
  testonly = true

  deps = [
    # basic unit tests
    ":unittests($host_toolchain)",

    # golden testing
    ":bits",
    ":constants",
    ":enums",
    ":multifile",
    ":structs",
  ]
}

if (is_host) {
  go_binary("zither") {
    gopackage = "go.fuchsia.dev/fuchsia/zircon/tools/zither/cmd"
    deps = [ ":main" ]
  }

  go_library("main") {
    visibility = [ ":*" ]
    source_dir = "cmd"
    sources = [ "main.go" ]
    deps = [
      ":common",
      "c",
      "//tools/fidl/lib/fidlgen",
      "//tools/lib/color",
      "//tools/lib/flagmisc",
      "//tools/lib/logger",
    ]
  }

  go_library("common") {
    visibility = [ "./*" ]
    name = "go.fuchsia.dev/fuchsia/zircon/tools/zither"
    deps = [
      "//tools/fidl/lib/fidlgen",
      "//tools/fidl/lib/fidlgen_cpp",
    ]
    sources = [
      "zither_ir.go",
      "zither_ir_test.go",
    ]
  }

  fidlgentest_go_test("unittests") {
    output_name = "zither-unittests"
    gopackages = [ "go.fuchsia.dev/fuchsia/zircon/tools/zither" ]
    deps = [
      ":common",
      "//third_party/golibs:github.com/google/go-cmp",
      "//tools/fidl/lib/fidlgen",
      "//tools/fidl/lib/fidlgentest",
    ]
  }
}

#
# Build-time golden tests
#

# zither_golden_test() defines a suite of build-time golden tests for zither
# backends: a FIDL library and its expected bindings are supplied, and the diff
# checks are made as build actions. Further, a check is made that the bindings
# give valid, compilable code.
#
# `target_name` is assumed to be the associated test case name, as is formally
# defined by the subdirectory names in testdata/ (see testdata/README.md).
# This template further assumes the following properties of the directory's
# organizational structure:
#   * FIDL sources are found in testdata/${case_name}/, at the root of the
#     'case data directory';
#   * Goldens, for a given backend, are found in
#     testdata/${case_name}/goldens/${backend}, the 'backend's case golden
#     directory'
#
# Parameters:
#
#  * sources
#    - Required: FIDL files comprising a single library, from which bindings
#      will be generated, relative to the case FIDL directory. The name of this
#      library is assumed to be "zither.${case_name}".
#    - Type: list of relative paths
#
#  * cases
#    - Required: A list of test cases.
#    - Type: list(scope)
#
#    Each scope contains:
#      * backend:
#        - Required: The backend with which to generate bindings. Must be one
#          of the following: "c" (C data layout bindings)
#          (TODO(fxbug.dev/91102): also "cpp", "rust", and "go")
#          (TODO(fxbug.dev/93393): also "asm")
#        - Type: string
#      * files
#        - Required: The list of names for the files to be generated by the
#          backend. This list should be in one-to-one correspondence with the
#          the goldens found in the backend's case golden directory.
#        - Type: list(string)
#
template("zither_golden_test") {
  assert(defined(invoker.sources), "no sources given")
  assert(defined(invoker.cases) && invoker.cases != [], "no test cases defined")

  fidlc_target = "_zither_golden_test.${target_name}.fidlc"
  main_target = target_name

  ir_file = "$target_gen_dir/$target_name.fidl.json"

  case_name = target_name
  libname = "zither.${case_name}"
  case_data_dir = "testdata/${case_name}"

  # Generate the IR.
  compiled_action(fidlc_target) {
    visibility = [ ":*" ]
    testonly = true
    tool = "//tools/fidl/fidlc"

    outputs = [ ir_file ]

    sources = []
    foreach(source, invoker.sources) {
      sources += [ "${case_data_dir}/$source" ]
    }

    args = [
      "--name",
      libname,
      "--json",
      rebase_path(outputs[0], root_build_dir),
      "--files",
    ]
    args += rebase_path(sources, root_build_dir)
  }

  case_deps = []
  foreach(case, invoker.cases) {
    assert(defined(case.backend), "`${case}` must provide `backend`")
    assert(defined(case.files) && case.files != [],
           "`${case}` must provide `files`")

    target_prefix = "_zither_golden_test.${case_name}-${case.backend}"
    zither_target = "${target_prefix}.zither"
    output_check_target = "${target_prefix}.output_check"
    goldens_target = "${target_prefix}.golden_file"
    compilation_check_target = "${target_prefix}.compilation_check"

    output_dir = "$target_gen_dir/${case_name}-${case.backend}"
    output_manifest = "$output_dir/outputs.json"

    # The subdirectory within the output directory under which the backend is
    # expected to generate files. This is simple "name token to path part" of
    # the library name, which is verified above to be "zither.${case_name}"
    output_namespace = "zither/${case_name}"

    generated_files = []
    foreach(file, case.files) {
      generated_files += [ "$output_dir/${output_namespace}/$file" ]
    }

    # Generate the bindings.
    compiled_action(zither_target) {
      visibility = [ ":*" ]
      testonly = true

      tool = ":zither"

      clang_format =
          "//prebuilt/third_party/clang/$host_platform/bin/clang-format"
      clang_format_config = "//.clang-format"
      inputs = [
        clang_format,
        clang_format_config,
      ]

      outputs = generated_files + [ output_manifest ]
      args = [
        "-ir",
        rebase_path(ir_file, root_build_dir),
        "-backend",
        case.backend,
        "-output-manifest",
        rebase_path(output_manifest, root_build_dir),
        "-output-dir",
        rebase_path(output_dir, root_build_dir),
        "-clang-format",
        rebase_path(clang_format, root_build_dir),
        "-clang-format-args",
        "--style=file:" + rebase_path(clang_format_config, root_build_dir),
      ]
      deps = [ ":$fidlc_target" ]
    }

    # Verify that the provided set of 'actual' bindings is indeed the actual
    # set of zither outputs (in name only). This ensures that zither's outputs
    # were fully specified.
    action(output_check_target) {
      visibility = [ ":*" ]
      testonly = true
      script = "testing/check-outputs.py"

      # Stamp file.
      outputs = [ "$target_gen_dir/$output_check_target.stamp" ]

      inputs = generated_files + [ output_manifest ]
      args = [
        "--stamp",
        rebase_path(outputs[0], root_build_dir),
        "--manifest",
        rebase_path(output_manifest, root_build_dir),
      ]
      args += rebase_path(generated_files, root_build_dir)
      deps = [ ":$zither_target" ]
    }

    case_deps += [ ":$output_check_target" ]

    # Verify that the bindings are as expected.
    golden_files(goldens_target) {
      testonly = true
      comparisons = []
      foreach(file, case.files) {
        comparisons += [
          {
            golden = "${case_data_dir}/goldens/${case.backend}/${file}"
            current = "${output_dir}/${output_namespace}/${file}"
          },
        ]
      }
      deps = [ ":$zither_target" ]
    }

    case_deps += [ ":$goldens_target" ]

    # Now verify that the bindings give valid code.
    if (case.backend == "c") {
      create_source_target = "${compilation_check_target}.create_source"

      source = "$output_dir/compile-check.c"
      action(create_source_target) {
        visibility = [ ":*" ]
        testonly = true
        script = "testing/create-file-with-includes.py"
        args = [
          "--comment",
          "Generated by //" + rebase_path(script, "//"),
          "--output",
          rebase_path(source, root_build_dir),
        ]
        foreach(file, case.files) {
          args += [ "${output_namespace}/${file}" ]
        }
        outputs = [ source ]
      }

      source_set(compilation_check_target) {
        visibility = [ ":*" ]
        testonly = true
        public = generated_files
        sources = [ source ]
        deps = [
          ":$create_source_target",
          ":$zither_target",
        ]
        include_dirs = [ output_dir ]
      }
    } else {
      assert(false, "unknown zither backend: ${case}")
    }

    case_deps += [ ":$compilation_check_target" ]
  }

  group(main_target) {
    testonly = true
    deps = case_deps
  }
}

# FIDL: testdata/constants/
# Goldens: testdata/constants/goldens/${backend}/
zither_golden_test("constants") {
  sources = [ "constants.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "constants.h" ]
    },
  ]
}

# FIDL: testdata/enums/
# Goldens: testdata/enums/goldens/${backend}/
zither_golden_test("enums") {
  sources = [ "enums.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "enums.h" ]
    },
  ]
}

# FIDL: testdata/bits/
# Goldens: testdata/bits/goldens/${backend}/
zither_golden_test("bits") {
  sources = [ "bits.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "bits.h" ]
    },
  ]
}

# FIDL: testdata/structs/
# Goldens: testdata/structs/goldens/${backend}/
zither_golden_test("structs") {
  sources = [ "structs.test.fidl" ]

  cases = [
    {
      backend = "c"
      files = [ "structs.h" ]
    },
  ]
}

# FIDL: testdata/multifile/
# Goldens: testdata/multifile/goldens/${backend}/
zither_golden_test("multifile") {
  sources = [
    "a.test.fidl",
    "b.test.fidl",
    "c.test.fidl",
  ]

  cases = [
    {
      backend = "c"
      files = [
        "a.h",
        "b.h",
        "c.h",
      ]
    },
  ]
}
