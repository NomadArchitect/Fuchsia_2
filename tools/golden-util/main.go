// Copyright 2020 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package main

import (
	"bufio"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/google/go-cmp/cmp"
)

type flagsDef struct {
	manifest *string
	regen    *bool
}

var flags = flagsDef{
	manifest: flag.String("manifest", "", "JSON manifest"),
	regen:    flag.Bool("regen", false, "regen instead of testing"),
}

func printUsage() {
	program := path.Base(os.Args[0])
	message := `Usage: ` + program + ` [flags]

Utility used to test/regen golden files.

Flags:
`
	fmt.Fprint(flag.CommandLine.Output(), message)
	flag.PrintDefaults()
}

func main() {
	flag.Usage = printUsage
	flag.Parse()
	// We use log for errors, so clear flags to remove date/time.
	log.SetFlags(0)

	if *flags.manifest == "" {
		log.Fatal("must provide --manifest flag")
	}
	manifestJSON, err := os.ReadFile(*flags.manifest)
	if err != nil {
		log.Fatal(err)
	}
	var manifest manifest
	if err := json.Unmarshal(manifestJSON, &manifest); err != nil {
		log.Fatalf("%s: %s", *flags.manifest, err)
	}
	if err := manifest.validate(); err != nil {
		log.Fatalf("%s: %s", *flags.manifest, err)
	}

	if *flags.regen {
		if err := manifest.regen(os.Stdout); err != nil {
			log.Fatal(err)
		}
	} else {
		passed, err := manifest.test(os.Stdout)
		if err != nil {
			log.Fatal(err)
		}
		if !passed {
			fmt.Println("Run the test again with the --regen flag to regenerate goldens")
			os.Exit(1)
		}
	}
}

// A manifest stores the information needed to test/regen goldens.
type manifest struct {
	// Goldens directory used in test mode.
	TestGoldensDir string `json:"test_goldens_dir"`
	// Goldens directory used in regen mode.
	RegenGoldensDir string `json:"regen_goldens_dir"`
	// List of files to test/regen.
	Entries []entry `json:"entries"`
}

// An entry represents a file that gets compared to (in test mode) or
// overwritten by (in regen mode) another file generated by the build.
type entry struct {
	// Golden filename, relative to TestGoldensDir and RegenGoldensDir.
	Golden string `json:"golden"`
	// Path to the corresponding generated file.
	Generated string `json:"generated"`
}

func (m *manifest) validate() error {
	if m.TestGoldensDir == "" {
		return fmt.Errorf("missing test dir")
	}
	if m.RegenGoldensDir == "" {
		return fmt.Errorf("missing regen dir")
	}
	seenGolden := make(map[string]struct{}, len(m.Entries))
	seenGenerated := make(map[string]struct{}, len(m.Entries))
	for _, entry := range m.Entries {
		if entry.Golden == "" {
			return fmt.Errorf("entry missing golden path")
		}
		if entry.Generated == "" {
			return fmt.Errorf("entry missing generated path")
		}
		if _, ok := seenGolden[entry.Golden]; ok {
			return fmt.Errorf("%s: duplicate golden path", entry.Golden)
		}
		if _, ok := seenGenerated[entry.Generated]; ok {
			return fmt.Errorf("%s: duplicate generated path", entry.Generated)
		}
		seenGolden[entry.Golden] = struct{}{}
		seenGenerated[entry.Generated] = struct{}{}
		if strings.ContainsRune(entry.Golden, '/') {
			return fmt.Errorf("%s: subdirectories not allowed", entry.Golden)
		}
		if filepath.Ext(entry.Golden) != ".golden" {
			return fmt.Errorf("%s: expected .golden extension", entry.Golden)
		}
		if filepath.Ext(entry.Generated) == ".golden" {
			return fmt.Errorf("%s: unexpected .golden extension", entry.Generated)
		}
	}
	return nil
}

func (m *manifest) regen(w io.Writer) error {
	// Print the destination directory. Use an absolute path, since the provided
	// path is relative to GN's root_build_dir.
	absGoldensDir, err := filepath.Abs(m.RegenGoldensDir)
	if err != nil {
		return err
	}
	fmt.Fprintf(w, "Regenerating goldens in %s\n", absGoldensDir)

	// Read the current contents of goldens.txt before overwriting it. If any
	// files it lists are no longer generated, we remove them at the end.
	goldensTxtPath := filepath.Join(m.RegenGoldensDir, "goldens.txt")
	goldensTxtFile, err := os.OpenFile(goldensTxtPath, os.O_RDWR|os.O_APPEND, 0)
	if err != nil {
		return err
	}
	defer goldensTxtFile.Close()
	goldensToRemove, err := readGoldensTxt(goldensTxtFile)
	if err != nil {
		return fmt.Errorf("%s: %s", goldensTxtPath, err)
	}
	// Write a newline in case the file doesn't end with one.
	goldensTxtFile.WriteString("\n")

	var allGoldenPaths []string
	for _, entry := range m.Entries {
		fmt.Fprintf(w, "Writing %s\n", entry.Golden)
		goldenPath := filepath.Join(m.RegenGoldensDir, entry.Golden)
		goldenFile, err := os.Create(goldenPath)
		if err != nil {
			return err
		}
		defer goldenFile.Close()
		generatedPath := entry.Generated
		generatedFile, err := os.Open(generatedPath)
		if err != nil {
			return err
		}
		defer generatedFile.Close()
		if _, err := io.Copy(goldenFile, generatedFile); err != nil {
			return fmt.Errorf("copying %s to %s: %s", generatedPath, goldenPath, err)
		}
		allGoldenPaths = append(allGoldenPaths, entry.Golden)
		delete(goldensToRemove, entry.Golden)
		// Append to goldens.txt, even though we rewrite it at the end, so that
		// it remains accurate if something fails partway through.
		goldensTxtFile.WriteString(entry.Golden)
		goldensTxtFile.WriteString("\n")
	}

	// Purge stale goldens.
	for path := range goldensToRemove {
		fmt.Fprintf(w, "Removing %s\n", path)
		if err := os.Remove(filepath.Join(m.RegenGoldensDir, path)); err != nil {
			return err
		}
	}

	// Rewrite goldens.txt with the new paths, sorted.
	sort.Strings(allGoldenPaths)
	goldensTxtFile.Truncate(0)
	goldensTxtFile.Seek(0, 0)
	for _, path := range allGoldenPaths {
		goldensTxtFile.WriteString(path)
		goldensTxtFile.WriteString("\n")
	}

	// Check if there are any stray .golden files not tracked in goldens.txt.
	// This can happen when rebasing changes incorrectly, for example.
	allGoldensSet := make(map[string]struct{}, len(allGoldenPaths))
	for _, path := range allGoldenPaths {
		allGoldensSet[path] = struct{}{}
	}
	dirEntries, err := os.ReadDir(m.RegenGoldensDir)
	if err != nil {
		return err
	}
	for _, d := range dirEntries {
		if d.Type().IsRegular() && filepath.Ext(d.Name()) == ".golden" {
			name := d.Name()
			if _, ok := allGoldensSet[name]; !ok {
				fmt.Fprintf(w, "Removing untracked file %s\n", name)
				if err := os.Remove(filepath.Join(m.RegenGoldensDir, name)); err != nil {
					return err
				}
			}
		}
	}

	return nil
}

func (m *manifest) test(w io.Writer) (bool, error) {
	// Read goldens.txt to ensure we only consider fresh host_test_data copies,
	// not old files that happen to remain in the build directory.
	goldensTxtPath := filepath.Join(m.TestGoldensDir, "goldens.txt")
	goldensTxtFile, err := os.Open(goldensTxtPath)
	if err != nil {
		return false, err
	}
	remainingGoldens, err := readGoldensTxt(goldensTxtFile)
	goldensTxtFile.Close()
	if err != nil {
		return false, fmt.Errorf("%s: %s", goldensTxtPath, err)
	}

	reporter := reporter{Writer: w}
	for _, entry := range m.Entries {
		tc := reporter.testCase(entry.Golden)
		tc.announce()
		if _, ok := remainingGoldens[entry.Golden]; !ok {
			tc.fail("file missing from goldens.txt (forgot to regen?)")
			continue
		}
		delete(remainingGoldens, entry.Golden)
		goldenPath := filepath.Join(m.TestGoldensDir, entry.Golden)
		goldenBytes, err := os.ReadFile(goldenPath)
		if err != nil {
			tc.fail("%s", err)
			continue
		}
		generatedPath := entry.Generated
		generatedBytes, err := os.ReadFile(generatedPath)
		if err != nil {
			tc.fail("%s", err)
			continue
		}
		if len(goldenBytes) != 0 && len(generatedBytes) == 0 {
			tc.fail("%s: generated file was unexpectedly empty", generatedPath)
			continue
		}
		goldenLines := strings.Split(string(goldenBytes), "\n")
		generatedLines := strings.Split(string(generatedBytes), "\n")
		if diff := cmp.Diff(goldenLines, generatedLines); diff != "" {
			tc.fail(`unexpected difference between golden file:
	%s
and generated file:
	%s
diff -golden +generated:
%s`,
				goldenPath, generatedPath, diff)
			continue
		}
		tc.pass()
	}

	if len(remainingGoldens) != 0 {
		var extras []string
		for golden := range remainingGoldens {
			extras = append(extras, golden)
		}
		sort.Strings(extras)
		var msg strings.Builder
		msg.WriteString("extra files in goldens.txt (forgot to regen?):\n")
		for _, golden := range extras {
			msg.WriteString(fmt.Sprintf("\t%s\n", golden))
		}
		tc := reporter.testCase("goldens.txt")
		tc.announce()
		tc.fail(msg.String())
	}

	reporter.summarize()
	return !reporter.failed, nil
}

func readGoldensTxt(rd io.Reader) (map[string]struct{}, error) {
	scanner := bufio.NewScanner(rd)
	goldens := make(map[string]struct{})
	for scanner.Scan() {
		path := scanner.Text()
		// Omit empty lines to avoid spurious "" paths when setting up tests for
		// the first time (e.g. `touch goldens.txt` or `echo > goldens.txt`).
		if path == "" {
			continue
		}
		if strings.ContainsRune(path, '/') {
			return nil, fmt.Errorf("%s: subdirectories not allowed", path)
		}
		if filepath.Ext(path) != ".golden" {
			return nil, fmt.Errorf("%s: expected .golden extension", path)
		}
		goldens[path] = struct{}{}
	}
	if err := scanner.Err(); err != nil {
		return nil, err
	}
	return goldens, nil
}

type reporter struct {
	io.Writer
	failed bool
}

func (r *reporter) printf(format string, args ...interface{}) {
	fmt.Fprintf(r, format, args...)
}

func (r *reporter) summarize() {
	if r.failed {
		r.printf("FAIL\n")
	} else {
		r.printf("PASS\n")
	}
}

func (r *reporter) testCase(name string) testCase {
	return testCase{name, r}
}

type testCase struct {
	name     string
	reporter *reporter
}

func (c *testCase) announce() {
	c.reporter.printf("=== TEST: %s\n", c.name)
}

func (c *testCase) pass() {
	c.reporter.printf("--- PASS: %s\n", c.name)
}

func (c *testCase) fail(format string, args ...interface{}) {
	c.reporter.printf("--- FAIL: %s\n", c.name)
	s := fmt.Sprintf(format, args...)
	c.reporter.printf("%s", s)
	if s[len(s)-1] != '\n' {
		c.reporter.printf("\n")
	}
	c.reporter.failed = true
}
