// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/natural_types_header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace fidl {
namespace test {
namespace enum_ {

enum class MyStrictEnum : uint32_t {

  FOO = 1u,

  BAR = 2u,
};

inline zx_status_t Clone(::fidl::test::enum_::MyStrictEnum value,
                         ::fidl::test::enum_::MyStrictEnum* result) {
  *result = value;
  return ZX_OK;
}

class MyFlexibleEnumWithCustomUnknown final
    : private ::fidl::internal::FlexibleEnumValue<
          MyFlexibleEnumWithCustomUnknown, uint32_t> {
 private:
  using ValueType =
      ::fidl::internal::FlexibleEnumValue<MyFlexibleEnumWithCustomUnknown,
                                          uint32_t>;

 public:
  constexpr MyFlexibleEnumWithCustomUnknown() : FlexibleEnumValue(0) {}
  constexpr explicit MyFlexibleEnumWithCustomUnknown(uint32_t value)
      : FlexibleEnumValue(value) {}
  constexpr MyFlexibleEnumWithCustomUnknown(
      const MyFlexibleEnumWithCustomUnknown& other)
      : FlexibleEnumValue(other.value_) {}
  constexpr MyFlexibleEnumWithCustomUnknown& operator=(
      MyFlexibleEnumWithCustomUnknown other) {
    value_ = other.value_;
    return *this;
  }

  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
      default:
        return true;
    }
  }

  constexpr static MyFlexibleEnumWithCustomUnknown Unknown() {
    return MyFlexibleEnumWithCustomUnknown(0x3);
  }

  static constexpr ValueType FOO{1u};

  static constexpr ValueType BAR{2u};

  static constexpr ValueType CUSTOM_UNKNOWN{3u};
};

inline zx_status_t Clone(
    ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown value,
    ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown* result) {
  *result = value;
  return ZX_OK;
}

class MyFlexibleEnum final
    : private ::fidl::internal::FlexibleEnumValue<MyFlexibleEnum, uint32_t> {
 private:
  using ValueType =
      ::fidl::internal::FlexibleEnumValue<MyFlexibleEnum, uint32_t>;

 public:
  constexpr MyFlexibleEnum() : FlexibleEnumValue(0) {}
  constexpr explicit MyFlexibleEnum(uint32_t value)
      : FlexibleEnumValue(value) {}
  constexpr MyFlexibleEnum(const MyFlexibleEnum& other)
      : FlexibleEnumValue(other.value_) {}
  constexpr MyFlexibleEnum& operator=(MyFlexibleEnum other) {
    value_ = other.value_;
    return *this;
  }

  constexpr operator uint32_t() const { return value_; }

  constexpr bool IsUnknown() const {
    switch (value_) {
      case 1u:

      case 2u:

        return false;
      default:
        return true;
    }
  }

  constexpr static MyFlexibleEnum Unknown() {
    return MyFlexibleEnum(0xffffffff);
  }

  static constexpr ValueType FOO{1u};

  static constexpr ValueType BAR{2u};
};

inline zx_status_t Clone(::fidl::test::enum_::MyFlexibleEnum value,
                         ::fidl::test::enum_::MyFlexibleEnum* result) {
  *result = value;
  return ZX_OK;
}

}  // namespace enum_
}  // namespace test
template <>
struct CodingTraits<::fidl::test::enum_::MyStrictEnum> {
  static constexpr size_t inline_size_old =
      sizeof(::fidl::test::enum_::MyStrictEnum);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::fidl::test::enum_::MyStrictEnum);
  static void Encode(
      Encoder* encoder, ::fidl::test::enum_::MyStrictEnum* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::fidl::test::enum_::MyStrictEnum* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::fidl::test::enum_::MyStrictEnum>(underlying);
  }
};

inline zx_status_t Clone(::fidl::test::enum_::MyStrictEnum value,
                         ::fidl::test::enum_::MyStrictEnum* result) {
  return ::fidl::test::enum_::Clone(value, result);
}
template <>
struct Equality<::fidl::test::enum_::MyStrictEnum> {
  bool operator()(const ::fidl::test::enum_::MyStrictEnum& _lhs,
                  const ::fidl::test::enum_::MyStrictEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown> {
  static constexpr size_t inline_size_old =
      sizeof(::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown);
  static void Encode(
      Encoder* encoder,
      ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(
      Decoder* decoder,
      ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown* value,
      size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown>(
        underlying);
  }
};

inline zx_status_t Clone(
    ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown value,
    ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown* result) {
  return ::fidl::test::enum_::Clone(value, result);
}
template <>
struct Equality<::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown> {
  bool operator()(
      const ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown& _lhs,
      const ::fidl::test::enum_::MyFlexibleEnumWithCustomUnknown& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct CodingTraits<::fidl::test::enum_::MyFlexibleEnum> {
  static constexpr size_t inline_size_old =
      sizeof(::fidl::test::enum_::MyFlexibleEnum);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::fidl::test::enum_::MyFlexibleEnum);
  static void Encode(
      Encoder* encoder, ::fidl::test::enum_::MyFlexibleEnum* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder,
                     ::fidl::test::enum_::MyFlexibleEnum* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::fidl::test::enum_::MyFlexibleEnum>(underlying);
  }
};

inline zx_status_t Clone(::fidl::test::enum_::MyFlexibleEnum value,
                         ::fidl::test::enum_::MyFlexibleEnum* result) {
  return ::fidl::test::enum_::Clone(value, result);
}
template <>
struct Equality<::fidl::test::enum_::MyFlexibleEnum> {
  bool operator()(const ::fidl::test::enum_::MyFlexibleEnum& _lhs,
                  const ::fidl::test::enum_::MyFlexibleEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

}  // namespace fidl
