// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/natural_types_header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace fidl {
namespace test {
namespace bindingsdenylist {
#ifdef __Fuchsia__

class OnlyLibfuzzerAndDeps;
using OnlyLibfuzzerAndDepsHandle =
    ::fidl::InterfaceHandle<OnlyLibfuzzerAndDeps>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__
class OnlyHlcpp;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class OnlyCppAndDeps;
using OnlyCppAndDepsHandle = ::fidl::InterfaceHandle<OnlyCppAndDeps>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_bindingsdenylist_OnlyLibfuzzerAndDepsLibfuzzerNeedsNonemptyProtocolRequestTable;

}  // namespace _internal
class OnlyLibfuzzerAndDeps_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage LibfuzzerNeedsNonemptyProtocol(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::Encoder::WireFormat::V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case ::fidl::Encoder::WireFormat::V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == ::fidl::Encoder::WireFormat::V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::bindingsdenylist::_internal::
            fidl_test_bindingsdenylist_OnlyLibfuzzerAndDepsLibfuzzerNeedsNonemptyProtocolRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_bindingsdenylist_OnlyLibfuzzerAndDepsLibfuzzerNeedsNonemptyProtocolResponseTable;

}  // namespace _internal
class OnlyLibfuzzerAndDeps_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage LibfuzzerNeedsNonemptyProtocol(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case ::fidl::Encoder::WireFormat::V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case ::fidl::Encoder::WireFormat::V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == ::fidl::Encoder::WireFormat::V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::bindingsdenylist::_internal::
            fidl_test_bindingsdenylist_OnlyLibfuzzerAndDepsLibfuzzerNeedsNonemptyProtocolResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class OnlyCppAndDeps_RequestEncoder {
 public:
};

class OnlyCppAndDeps_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

constexpr uint32_t AllBindings = 0u;

}  // namespace bindingsdenylist
}  // namespace test

}  // namespace fidl
