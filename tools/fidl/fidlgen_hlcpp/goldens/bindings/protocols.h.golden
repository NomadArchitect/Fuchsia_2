// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"

//
// Domain objects declarations (i.e. "natural types" in unified bindings).
//
namespace fidl {
namespace test {
namespace protocols {
enum class rights : uint32_t {

  TRANSFER = 1u,

  DUPLICATE = 2u,
};

const static rights rightsMask = static_cast<rights>(3u);

constexpr inline ::fidl::test::protocols::rights operator|(
    ::fidl::test::protocols::rights _lhs,
    ::fidl::test::protocols::rights _rhs) {
  return static_cast<::fidl::test::protocols::rights>(
      static_cast<uint32_t>(_lhs) | static_cast<uint32_t>(_rhs));
}

constexpr inline ::fidl::test::protocols::rights& operator|=(
    ::fidl::test::protocols::rights& _lhs,
    ::fidl::test::protocols::rights _rhs) {
  _lhs = _lhs | _rhs;
  return _lhs;
}

constexpr inline ::fidl::test::protocols::rights operator&(
    ::fidl::test::protocols::rights _lhs,
    ::fidl::test::protocols::rights _rhs) {
  return static_cast<::fidl::test::protocols::rights>(
      static_cast<uint32_t>(_lhs) & static_cast<uint32_t>(_rhs));
}

constexpr inline ::fidl::test::protocols::rights& operator&=(
    ::fidl::test::protocols::rights& _lhs,
    ::fidl::test::protocols::rights _rhs) {
  _lhs = _lhs & _rhs;
  return _lhs;
}

constexpr inline ::fidl::test::protocols::rights operator^(
    ::fidl::test::protocols::rights _lhs,
    ::fidl::test::protocols::rights _rhs) {
  return static_cast<::fidl::test::protocols::rights>(
      static_cast<uint32_t>(_lhs) ^ static_cast<uint32_t>(_rhs));
}

constexpr inline ::fidl::test::protocols::rights& operator^=(
    ::fidl::test::protocols::rights& _lhs,
    ::fidl::test::protocols::rights _rhs) {
  _lhs = _lhs ^ _rhs;
  return _lhs;
}

constexpr inline ::fidl::test::protocols::rights operator~(
    ::fidl::test::protocols::rights _value) {
  return static_cast<::fidl::test::protocols::rights>(
      ~static_cast<uint32_t>(_value) &
      static_cast<uint32_t>(::fidl::test::protocols::rightsMask));
}

inline zx_status_t Clone(::fidl::test::protocols::rights value,
                         ::fidl::test::protocols::rights* result) {
  *result = value;
  return ZX_OK;
}

enum class obj_type : uint32_t {

  NONE = 0u,

  SOCKET = 14u,
};

inline zx_status_t Clone(::fidl::test::protocols::obj_type value,
                         ::fidl::test::protocols::obj_type* result) {
  *result = value;
  return ZX_OK;
}

class WithErrorSyntax_HandleInResult_Response;

class WithErrorSyntax_HandleInResult_Result;

#ifdef __Fuchsia__

class HandleRightsProtocol;
using HandleRightsProtocolHandle =
    ::fidl::InterfaceHandle<HandleRightsProtocol>;
#endif  // __Fuchsia__

class WithErrorSyntax_ResponseAsStruct_Response;

class WithErrorSyntax_ResponseAsStruct_Result;

class WithErrorSyntax_ErrorAsPrimitive_Response;

class WithErrorSyntax_ErrorAsPrimitive_Result;

class WithErrorSyntax_ErrorAsEnum_Response;

#ifdef __Fuchsia__

class WithAndWithoutRequestResponse;
using WithAndWithoutRequestResponseHandle =
    ::fidl::InterfaceHandle<WithAndWithoutRequestResponse>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class Transitional;
using TransitionalHandle = ::fidl::InterfaceHandle<Transitional>;
#endif  // __Fuchsia__

class TheUnion;

#ifdef __Fuchsia__

class MethodWithUnion;
using MethodWithUnionHandle = ::fidl::InterfaceHandle<MethodWithUnion>;
#endif  // __Fuchsia__

class ProtocolEnds;

#ifdef __Fuchsia__

class WithProtocolEnds;
using WithProtocolEndsHandle = ::fidl::InterfaceHandle<WithProtocolEnds>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ManyParameters;
using ManyParametersHandle = ::fidl::InterfaceHandle<ManyParameters>;
#endif  // __Fuchsia__

enum class ErrorEnum : uint32_t {

  ERR_FOO = 1u,

  ERR_BAR = 2u,
};

inline zx_status_t Clone(::fidl::test::protocols::ErrorEnum value,
                         ::fidl::test::protocols::ErrorEnum* result) {
  *result = value;
  return ZX_OK;
}

class WithErrorSyntax_ErrorAsEnum_Result;

#ifdef __Fuchsia__

class WithErrorSyntax;
using WithErrorSyntaxHandle = ::fidl::InterfaceHandle<WithErrorSyntax>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class DiscoverableProtocol;
using DiscoverableProtocolHandle =
    ::fidl::InterfaceHandle<DiscoverableProtocol>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ChannelProtocol;
using ChannelProtocolHandle = ::fidl::InterfaceHandle<ChannelProtocol>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithErrorSyntax_HandleInResult_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_HandleInResult_Response() = default;
  explicit WithErrorSyntax_HandleInResult_Response(::zx::handle v)
      : h(std::move(v)) {}
  ::zx::handle ResultValue_() { return std::move(h); }
  explicit WithErrorSyntax_HandleInResult_Response(
      ::std::tuple<::zx::handle> _value_tuple) {
    std::tie(h) = std::move(_value_tuple);
  }
  operator ::std::tuple<::zx::handle>() && {
    return std::make_tuple(std::move(h));
  }

  ::zx::handle h{};

  static inline ::std::unique_ptr<WithErrorSyntax_HandleInResult_Response>
  New() {
    return ::std::make_unique<WithErrorSyntax_HandleInResult_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_HandleInResult_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_HandleInResult_Response* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response&
        _value,
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_HandleInResult_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_HandleInResult_Response>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithErrorSyntax_HandleInResult_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_HandleInResult_Result();
  ~WithErrorSyntax_HandleInResult_Result();

  WithErrorSyntax_HandleInResult_Result(
      WithErrorSyntax_HandleInResult_Result&&);
  WithErrorSyntax_HandleInResult_Result& operator=(
      WithErrorSyntax_HandleInResult_Result&&);

  static WithErrorSyntax_HandleInResult_Result WithResponse(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response&&);
  static WithErrorSyntax_HandleInResult_Result WithErr(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_HandleInResult_Result> New() {
    return ::std::make_unique<WithErrorSyntax_HandleInResult_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_HandleInResult_Result* value,
                     size_t offset);
  zx_status_t Clone(WithErrorSyntax_HandleInResult_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::fidl::test::protocols::
                       WithErrorSyntax_HandleInResult_Result::Tag::kResponse;
  }

  ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response& response() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kResponse);
    return response_;
  }

  const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response&
  response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_HandleInResult_Result& set_response(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response value);

  bool is_err() const {
    return tag_ == ::fidl::test::protocols::
                       WithErrorSyntax_HandleInResult_Result::Tag::kErr;
  }

  uint32_t& err() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kErr);
    return err_;
  }

  const uint32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_HandleInResult_Result& set_err(uint32_t value);

  ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag Which()
      const {
    return ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag(
        tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result>;
  WithErrorSyntax_HandleInResult_Result(
      fpromise::result<::zx::handle, uint32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(
          ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response{
              result.take_value()});
    } else {
      set_err(std::move(result.take_error()));
    }
  }
  WithErrorSyntax_HandleInResult_Result(
      fpromise::ok_result<::zx::handle>&& result)
      : WithErrorSyntax_HandleInResult_Result(
            fpromise::result<::zx::handle, uint32_t>(std::move(result))) {}
  WithErrorSyntax_HandleInResult_Result(
      fpromise::error_result<uint32_t>&& result)
      : WithErrorSyntax_HandleInResult_Result(
            fpromise::result<::zx::handle, uint32_t>(std::move(result))) {}
  operator fpromise::result<::zx::handle, uint32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    ::std::tuple<::zx::handle> value_tuple = std::move(response());
    return fpromise::ok(std::move(std::get<0>(value_tuple)));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          Invalid);
  union {
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response response_;
    uint32_t err_;
  };
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result& value,
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_HandleInResult_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_HandleInResult_Result>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolResponseMethodRequestTable;

}  // namespace _internal
class HandleRightsProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage NoResponseMethod(
      ::fidl::Encoder* _encoder, ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_HandleRightsProtocolNoResponseMethodRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ResponseMethod(::fidl::Encoder* _encoder,
                                                     ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_HandleRightsProtocolResponseMethodRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolAnEventEventTable;

}  // namespace _internal
class HandleRightsProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ResponseMethod(::fidl::Encoder* _encoder,
                                                     ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x1,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x1,
                     });
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_HandleRightsProtocolResponseMethodResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage AnEvent(::fidl::Encoder* _encoder,
                                              ::zx::socket* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x3,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_HandleRightsProtocolAnEventEventTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class WithErrorSyntax_ResponseAsStruct_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_ResponseAsStruct_Response() = default;
  explicit WithErrorSyntax_ResponseAsStruct_Response(
      ::std::tuple<int64_t, int64_t, int64_t> _value_tuple) {
    std::tie(a, b, c) = std::move(_value_tuple);
  }
  operator ::std::tuple<int64_t, int64_t, int64_t>() && {
    return std::make_tuple(std::move(a), std::move(b), std::move(c));
  }

  int64_t a{};

  int64_t b{};

  int64_t c{};

  static inline ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Response>
  New() {
    return ::std::make_unique<WithErrorSyntax_ResponseAsStruct_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ResponseAsStruct_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ResponseAsStruct_Response* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&
        _value,
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response*
        _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ResponseAsStruct_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Response>;

class WithErrorSyntax_ResponseAsStruct_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_ResponseAsStruct_Result();
  ~WithErrorSyntax_ResponseAsStruct_Result();

  WithErrorSyntax_ResponseAsStruct_Result(
      WithErrorSyntax_ResponseAsStruct_Result&&);
  WithErrorSyntax_ResponseAsStruct_Result& operator=(
      WithErrorSyntax_ResponseAsStruct_Result&&);

  static WithErrorSyntax_ResponseAsStruct_Result WithResponse(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&&);
  static WithErrorSyntax_ResponseAsStruct_Result WithErr(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Result>
  New() {
    return ::std::make_unique<WithErrorSyntax_ResponseAsStruct_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ResponseAsStruct_Result* value,
                     size_t offset);
  zx_status_t Clone(WithErrorSyntax_ResponseAsStruct_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::fidl::test::protocols::
                       WithErrorSyntax_ResponseAsStruct_Result::Tag::kResponse;
  }

  ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&
  response() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kResponse);
    return response_;
  }

  const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&
  response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_ResponseAsStruct_Result& set_response(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response value);

  bool is_err() const {
    return tag_ == ::fidl::test::protocols::
                       WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr;
  }

  uint32_t& err() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kErr);
    return err_;
  }

  const uint32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_ResponseAsStruct_Result& set_err(uint32_t value);

  ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag Which()
      const {
    return ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::
        Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>;
  WithErrorSyntax_ResponseAsStruct_Result(
      fpromise::result<::std::tuple<int64_t, int64_t, int64_t>, uint32_t>&&
          result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(
          ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response{
              result.take_value()});
    } else {
      set_err(std::move(result.take_error()));
    }
  }
  WithErrorSyntax_ResponseAsStruct_Result(
      fpromise::ok_result<::std::tuple<int64_t, int64_t, int64_t>>&& result)
      : WithErrorSyntax_ResponseAsStruct_Result(
            fpromise::result<::std::tuple<int64_t, int64_t, int64_t>, uint32_t>(
                std::move(result))) {}
  WithErrorSyntax_ResponseAsStruct_Result(
      fpromise::error_result<uint32_t>&& result)
      : WithErrorSyntax_ResponseAsStruct_Result(
            fpromise::result<::std::tuple<int64_t, int64_t, int64_t>, uint32_t>(
                std::move(result))) {}
  operator fpromise::result<::std::tuple<int64_t, int64_t, int64_t>,
                            uint32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok(std::move(response()));
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          Invalid);
  union {
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response
        response_;
    uint32_t err_;
  };
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result&
        value,
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ResponseAsStruct_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_ResponseAsStruct_Result>;

class WithErrorSyntax_ErrorAsPrimitive_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_ErrorAsPrimitive_Response() = default;
  explicit WithErrorSyntax_ErrorAsPrimitive_Response(uint8_t v)
      : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit WithErrorSyntax_ErrorAsPrimitive_Response(
      ::std::tuple<> _value_tuple) {}
  operator ::std::tuple<>() && { return std::make_tuple(); }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response>
  New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsPrimitive_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Response* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&
        _value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response*
        _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Response>;

class WithErrorSyntax_ErrorAsPrimitive_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_ErrorAsPrimitive_Result();
  ~WithErrorSyntax_ErrorAsPrimitive_Result();

  WithErrorSyntax_ErrorAsPrimitive_Result(
      WithErrorSyntax_ErrorAsPrimitive_Result&&);
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(
      WithErrorSyntax_ErrorAsPrimitive_Result&&);

  static WithErrorSyntax_ErrorAsPrimitive_Result WithResponse(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&&);
  static WithErrorSyntax_ErrorAsPrimitive_Result WithErr(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result>
  New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsPrimitive_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsPrimitive_Result* value,
                     size_t offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsPrimitive_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::fidl::test::protocols::
                       WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kResponse;
  }

  ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&
  response() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kResponse);
    return response_;
  }

  const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&
  response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_ErrorAsPrimitive_Result& set_response(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response value);

  bool is_err() const {
    return tag_ == ::fidl::test::protocols::
                       WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr;
  }

  uint32_t& err() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kErr);
    return err_;
  }

  const uint32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_ErrorAsPrimitive_Result& set_err(uint32_t value);

  ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag Which()
      const {
    return ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
        Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>;
  WithErrorSyntax_ErrorAsPrimitive_Result(
      fpromise::result<void, uint32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response{});
    } else {
      set_err(std::move(result.take_error()));
    }
  }
  WithErrorSyntax_ErrorAsPrimitive_Result(fpromise::ok_result<void>&& result)
      : WithErrorSyntax_ErrorAsPrimitive_Result(
            fpromise::result<void, uint32_t>(std::move(result))) {}
  WithErrorSyntax_ErrorAsPrimitive_Result(
      fpromise::error_result<uint32_t>&& result)
      : WithErrorSyntax_ErrorAsPrimitive_Result(
            fpromise::result<void, uint32_t>(std::move(result))) {}
  operator fpromise::result<void, uint32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          Invalid);
  union {
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response
        response_;
    uint32_t err_;
  };
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result&
        value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsPrimitive_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsPrimitive_Result>;

class WithErrorSyntax_ErrorAsEnum_Response final {
 public:
  static const fidl_type_t* FidlType;
  WithErrorSyntax_ErrorAsEnum_Response() = default;
  explicit WithErrorSyntax_ErrorAsEnum_Response(uint8_t v)
      : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit WithErrorSyntax_ErrorAsEnum_Response(::std::tuple<> _value_tuple) {}
  operator ::std::tuple<>() && { return std::make_tuple(); }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response> New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Response>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsEnum_Response* value,
                     size_t _offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Response* result) const;
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& _value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response* _result) {
  return _value.Clone(_result);
}

using WithErrorSyntax_ErrorAsEnum_ResponsePtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Response>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

}  // namespace _internal
class WithAndWithoutRequestResponse_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage NoRequestNoResponse(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage NoRequestEmptyResponse(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage NoRequestWithResponse(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestNoResponse(
      ::fidl::Encoder* _encoder, ::std::string* arg) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, arg, 16);

    } else {
      ::fidl::Encode(_encoder, arg, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestEmptyResponse(
      ::fidl::Encoder* _encoder, ::std::string* arg) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, arg, 16);

    } else {
      ::fidl::Encode(_encoder, arg, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestWithResponse(
      ::fidl::Encoder* _encoder, ::std::string* arg) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, arg, 16);

    } else {
      ::fidl::Encode(_encoder, arg, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnEmptyResponseEventTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseEventTable;

}  // namespace _internal
class WithAndWithoutRequestResponse_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage NoRequestEmptyResponse(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage NoRequestWithResponse(
      ::fidl::Encoder* _encoder, ::std::string* ret) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, ret, 16);

    } else {
      ::fidl::Encode(_encoder, ret, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestEmptyResponse(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage WithRequestWithResponse(
      ::fidl::Encoder* _encoder, ::std::string* ret) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, ret, 16);

    } else {
      ::fidl::Encode(_encoder, ret, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OnEmptyResponse(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseOnEmptyResponseEventTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OnWithResponse(::fidl::Encoder* _encoder,
                                                     ::std::string* ret) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, ret, 16);

    } else {
      ::fidl::Encode(_encoder, ret, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseEventTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalRequestRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalOneWayRequestTable;

}  // namespace _internal
class Transitional_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Request(::fidl::Encoder* _encoder,
                                              int64_t* x) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, x, 16);

    } else {
      ::fidl::Encode(_encoder, x, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_TransitionalRequestRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage OneWay(::fidl::Encoder* _encoder,
                                             int64_t* x) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, x, 16);

    } else {
      ::fidl::Encode(_encoder, x, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_TransitionalOneWayRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalRequestResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalEventEventTable;

}  // namespace _internal
class Transitional_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Request(::fidl::Encoder* _encoder,
                                              int64_t* y) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, y, 16);

    } else {
      ::fidl::Encode(_encoder, y, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_TransitionalRequestResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage Event(::fidl::Encoder* _encoder,
                                            int64_t* x) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, x, 16);

    } else {
      ::fidl::Encode(_encoder, x, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_TransitionalEventEventTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class TheUnion final {
 public:
  static const fidl_type_t* FidlType;

  TheUnion();
  ~TheUnion();

  TheUnion(TheUnion&&);
  TheUnion& operator=(TheUnion&&);

  static TheUnion WithV(uint32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {
    kUnknown = 0,
    Empty = kUnknown,  // DEPRECATED: use kUnknown instead.

    kV = 1,  // 0x1
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<TheUnion> New() {
    return ::std::make_unique<TheUnion>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, TheUnion* value, size_t offset);
  zx_status_t Clone(TheUnion* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_v() const {
    return tag_ == ::fidl::test::protocols::TheUnion::Tag::kV;
  }

  uint32_t& v() {
    EnsureStorageInitialized(::fidl::test::protocols::TheUnion::Tag::kV);
    return v_;
  }

  const uint32_t& v() const {
    ZX_ASSERT(is_v());
    return v_;
  }
  TheUnion& set_v(uint32_t value);
  TheUnion& SetUnknownData(fidl_xunion_tag_t ordinal,
                           std::vector<uint8_t> bytes);

  ::fidl::test::protocols::TheUnion::Tag Which() const {
    switch (tag_) {
      case ::fidl::test::protocols::TheUnion::Tag::Invalid:
      case ::fidl::test::protocols::TheUnion::Tag::kV:
        return ::fidl::test::protocols::TheUnion::Tag(tag_);
      default:
        return ::fidl::test::protocols::TheUnion::Tag::kUnknown;
    }
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }
  const std::vector<uint8_t>* UnknownBytes() const {
    if (Which() != ::fidl::test::protocols::TheUnion::Tag::kUnknown) {
      return nullptr;
    }
    return &unknown_data_;
  }

  friend ::fidl::Equality<::fidl::test::protocols::TheUnion>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::fidl::test::protocols::TheUnion::Tag::Invalid);
  union {
    uint32_t v_;
    std::vector<uint8_t> unknown_data_;
  };
};

inline zx_status_t Clone(const ::fidl::test::protocols::TheUnion& value,
                         ::fidl::test::protocols::TheUnion* result) {
  return value.Clone(result);
}

using TheUnionPtr = ::std::unique_ptr<TheUnion>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_MethodWithUnionUnionMethodRequestTable;

}  // namespace _internal
class MethodWithUnion_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage UnionMethod(
      ::fidl::Encoder* _encoder, ::fidl::test::protocols::TheUnion* u) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(40 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(40 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, u, 16);

    } else {
      ::fidl::Encode(_encoder, u, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_MethodWithUnionUnionMethodRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

class MethodWithUnion_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ProtocolEnds final {
 public:
  static const fidl_type_t* FidlType;

  ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>
      client{};

  ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
      server{};

  ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>
      client_opt{};

  ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
      server_opt{};

  static inline ::std::unique_ptr<ProtocolEnds> New() {
    return ::std::make_unique<ProtocolEnds>();
  }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, ProtocolEnds* value,
                     size_t _offset);
  zx_status_t Clone(ProtocolEnds* result) const;
};

inline zx_status_t Clone(const ::fidl::test::protocols::ProtocolEnds& _value,
                         ::fidl::test::protocols::ProtocolEnds* _result) {
  return _value.Clone(_result);
}

using ProtocolEndsPtr = ::std::unique_ptr<ProtocolEnds>;
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsClientEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsServerEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

}  // namespace _internal
class WithProtocolEnds_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ClientEnds(
      ::fidl::Encoder* _encoder,
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>*
          in) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, in, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, in, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_WithProtocolEndsClientEndsRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ServerEnds(
      ::fidl::Encoder* _encoder,
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>*
          in) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, in, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, in, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_WithProtocolEndsServerEndsRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StructContainingEnds(
      ::fidl::Encoder* _encoder, ::fidl::test::protocols::ProtocolEnds* in) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, in, 16);

    } else {
      ::fidl::Encode(_encoder, in, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithProtocolEndsStructContainingEndsRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsClientEndsResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsServerEndsResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

}  // namespace _internal
class WithProtocolEnds_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ClientEnds(
      ::fidl::Encoder* _encoder,
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>*
          out) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, out, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, out, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_WithProtocolEndsClientEndsResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ServerEnds(
      ::fidl::Encoder* _encoder,
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>*
          out) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, out, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });

    } else {
      ::fidl::Encode(_encoder, out, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_CHANNEL,
                         .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_WithProtocolEndsServerEndsResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StructContainingEnds(
      ::fidl::Encoder* _encoder, ::fidl::test::protocols::ProtocolEnds* out) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, out, 16);

    } else {
      ::fidl::Encode(_encoder, out, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithProtocolEndsStructContainingEndsResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ManyParametersFifteenRequestTable;

}  // namespace _internal
class ManyParameters_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Fifteen(::fidl::Encoder* _encoder,
                                              bool* p1, bool* p2, bool* p3,
                                              bool* p4, bool* p5, bool* p6,
                                              bool* p7, bool* p8, bool* p9,
                                              bool* p10, bool* p11, bool* p12,
                                              bool* p13, bool* p14, bool* p15) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, p1, 16);

      ::fidl::Encode(_encoder, p2, 17);

      ::fidl::Encode(_encoder, p3, 18);

      ::fidl::Encode(_encoder, p4, 19);

      ::fidl::Encode(_encoder, p5, 20);

      ::fidl::Encode(_encoder, p6, 21);

      ::fidl::Encode(_encoder, p7, 22);

      ::fidl::Encode(_encoder, p8, 23);

      ::fidl::Encode(_encoder, p9, 24);

      ::fidl::Encode(_encoder, p10, 25);

      ::fidl::Encode(_encoder, p11, 26);

      ::fidl::Encode(_encoder, p12, 27);

      ::fidl::Encode(_encoder, p13, 28);

      ::fidl::Encode(_encoder, p14, 29);

      ::fidl::Encode(_encoder, p15, 30);

    } else {
      ::fidl::Encode(_encoder, p1, 16);

      ::fidl::Encode(_encoder, p2, 17);

      ::fidl::Encode(_encoder, p3, 18);

      ::fidl::Encode(_encoder, p4, 19);

      ::fidl::Encode(_encoder, p5, 20);

      ::fidl::Encode(_encoder, p6, 21);

      ::fidl::Encode(_encoder, p7, 22);

      ::fidl::Encode(_encoder, p8, 23);

      ::fidl::Encode(_encoder, p9, 24);

      ::fidl::Encode(_encoder, p10, 25);

      ::fidl::Encode(_encoder, p11, 26);

      ::fidl::Encode(_encoder, p12, 27);

      ::fidl::Encode(_encoder, p13, 28);

      ::fidl::Encode(_encoder, p14, 29);

      ::fidl::Encode(_encoder, p15, 30);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ManyParametersFifteenRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

class ManyParameters_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

class WithErrorSyntax_ErrorAsEnum_Result final {
 public:
  static const fidl_type_t* FidlType;

  WithErrorSyntax_ErrorAsEnum_Result();
  ~WithErrorSyntax_ErrorAsEnum_Result();

  WithErrorSyntax_ErrorAsEnum_Result(WithErrorSyntax_ErrorAsEnum_Result&&);
  WithErrorSyntax_ErrorAsEnum_Result& operator=(
      WithErrorSyntax_ErrorAsEnum_Result&&);

  static WithErrorSyntax_ErrorAsEnum_Result WithResponse(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response&&);
  static WithErrorSyntax_ErrorAsEnum_Result WithErr(
      ::fidl::test::protocols::ErrorEnum&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result> New() {
    return ::std::make_unique<WithErrorSyntax_ErrorAsEnum_Result>();
  }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info =
                  cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder,
                     WithErrorSyntax_ErrorAsEnum_Result* value, size_t offset);
  zx_status_t Clone(WithErrorSyntax_ErrorAsEnum_Result* result) const;

  bool has_invalid_tag() const { return tag_ == Invalid; }

  bool is_response() const {
    return tag_ == ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::
                       Tag::kResponse;
  }

  ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& response() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
            kResponse);
    return response_;
  }

  const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response&
  response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  WithErrorSyntax_ErrorAsEnum_Result& set_response(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response value);

  bool is_err() const {
    return tag_ == ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::
                       Tag::kErr;
  }

  ::fidl::test::protocols::ErrorEnum& err() {
    EnsureStorageInitialized(
        ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr);
    return err_;
  }

  const ::fidl::test::protocols::ErrorEnum& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  WithErrorSyntax_ErrorAsEnum_Result& set_err(
      ::fidl::test::protocols::ErrorEnum value);

  ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag Which()
      const {
    return ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag(
        tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal()
  // only when you need access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const { return tag_; }

  friend ::fidl::Equality<
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>;
  WithErrorSyntax_ErrorAsEnum_Result(
      fpromise::result<void, ::fidl::test::protocols::ErrorEnum>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response{});
    } else {
      set_err(std::move(result.take_error()));
    }
  }
  WithErrorSyntax_ErrorAsEnum_Result(fpromise::ok_result<void>&& result)
      : WithErrorSyntax_ErrorAsEnum_Result(
            fpromise::result<void, ::fidl::test::protocols::ErrorEnum>(
                std::move(result))) {}
  WithErrorSyntax_ErrorAsEnum_Result(
      fpromise::error_result<::fidl::test::protocols::ErrorEnum>&& result)
      : WithErrorSyntax_ErrorAsEnum_Result(
            fpromise::result<void, ::fidl::test::protocols::ErrorEnum>(
                std::move(result))) {}
  operator fpromise::result<void, ::fidl::test::protocols::ErrorEnum>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
          Invalid);
  union {
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response response_;
    ::fidl::test::protocols::ErrorEnum err_;
  };
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return value.Clone(result);
}

using WithErrorSyntax_ErrorAsEnum_ResultPtr =
    ::std::unique_ptr<WithErrorSyntax_ErrorAsEnum_Result>;

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxResponseAsStructRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsEnumRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxHandleInResultRequestTable;

}  // namespace _internal
class WithErrorSyntax_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ResponseAsStruct(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithErrorSyntaxResponseAsStructRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsPrimitive(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsEnum(::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_WithErrorSyntaxErrorAsEnumRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage HandleInResult(
      ::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithErrorSyntaxHandleInResultRequestTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxResponseAsStructResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsEnumResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxHandleInResultResponseTable;

}  // namespace _internal
class WithErrorSyntax_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage ResponseAsStruct(
      ::fidl::Encoder* _encoder,
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result*
          result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(40 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, result, 16);

    } else {
      ::fidl::Encode(_encoder, result, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithErrorSyntaxResponseAsStructResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsPrimitive(
      ::fidl::Encoder* _encoder,
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result*
          result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(40 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, result, 16);

    } else {
      ::fidl::Encode(_encoder, result, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage ErrorAsEnum(
      ::fidl::Encoder* _encoder,
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(40 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, result, 16);

    } else {
      ::fidl::Encode(_encoder, result, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_WithErrorSyntaxErrorAsEnumResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage HandleInResult(
      ::fidl::Encoder* _encoder,
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(40 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, result, 16);

    } else {
      ::fidl::Encode(_encoder, result, 16);
    }

    fidl_trace(
        DidHLCPPEncode,
        &::fidl::test::protocols::_internal::
            fidl_test_protocols_WithErrorSyntaxHandleInResultResponseTable,
        _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
        _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_DiscoverableProtocolMethodRequestTable;

}  // namespace _internal
class DiscoverableProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage Method(::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_DiscoverableProtocolMethodRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};

class DiscoverableProtocol_ResponseEncoder {
 public:
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodBRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMutateSocketRequestTable;

}  // namespace _internal
class ChannelProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage MethodA(::fidl::Encoder* _encoder,
                                              int64_t* a, int64_t* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, a, 16);

      ::fidl::Encode(_encoder, b, 24);

    } else {
      ::fidl::Encode(_encoder, a, 16);

      ::fidl::Encode(_encoder, b, 24);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolMethodARequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MethodB(::fidl::Encoder* _encoder,
                                              int64_t* a, int64_t* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, a, 16);

      ::fidl::Encode(_encoder, b, 24);

    } else {
      ::fidl::Encode(_encoder, a, 16);

      ::fidl::Encode(_encoder, b, 24);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolMethodBRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TakeHandle(::fidl::Encoder* _encoder,
                                                 ::zx::handle* h) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_NONE,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, h, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_NONE,
                         .rights = 0x80000000,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolTakeHandleRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MutateSocket(::fidl::Encoder* _encoder,
                                                   ::zx::socket* a) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, a, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, a, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolMutateSocketRequestTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
namespace _internal {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolEventAEventTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodBResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolTakeHandleResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMutateSocketResponseTable;

}  // namespace _internal
class ChannelProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage EventA(::fidl::Encoder* _encoder,
                                             int64_t* a, int64_t* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(32 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, a, 16);

      ::fidl::Encode(_encoder, b, 24);

    } else {
      ::fidl::Encode(_encoder, a, 16);

      ::fidl::Encode(_encoder, b, 24);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolEventAEventTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MethodB(::fidl::Encoder* _encoder,
                                              int64_t* result) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, result, 16);

    } else {
      ::fidl::Encode(_encoder, result, 16);
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolMethodBResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage TakeHandle(::fidl::Encoder* _encoder) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(16 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
    } else {
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolTakeHandleResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage MutateSocket(::fidl::Encoder* _encoder,
                                                   ::zx::socket* b) {
    fidl_trace(WillHLCPPEncode);
    switch (_encoder->wire_format()) {
      case FIDL_WIRE_FORMAT_VERSION_V1:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
      case FIDL_WIRE_FORMAT_VERSION_V2:
        _encoder->Alloc(24 - sizeof(fidl_message_header_t));
        break;
    }

    if (_encoder->wire_format() == FIDL_WIRE_FORMAT_VERSION_V1) {
      ::fidl::Encode(_encoder, b, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });

    } else {
      ::fidl::Encode(_encoder, b, 16,
                     ::fidl::HandleInformation{
                         .object_type = ZX_OBJ_TYPE_SOCKET,
                         .rights = 0x80000000,
                     });
    }

    fidl_trace(DidHLCPPEncode,
               &::fidl::test::protocols::_internal::
                   fidl_test_protocols_ChannelProtocolMutateSocketResponseTable,
               _encoder->GetPtr<const char>(0), _encoder->CurrentLength(),
               _encoder->CurrentHandleCount());
    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

}  // namespace protocols
}  // namespace test
template <>
struct CodingTraits<::fidl::test::protocols::rights> {
  static constexpr size_t inline_size_old =
      sizeof(::fidl::test::protocols::rights);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::fidl::test::protocols::rights);
  static constexpr size_t inline_size_v2 =
      sizeof(::fidl::test::protocols::rights);
  static void Encode(
      Encoder* encoder, ::fidl::test::protocols::rights* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::fidl::test::protocols::rights* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::fidl::test::protocols::rights>(underlying);
  }
};

inline zx_status_t Clone(::fidl::test::protocols::rights value,
                         ::fidl::test::protocols::rights* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<::fidl::test::protocols::rights> {
  bool operator()(const ::fidl::test::protocols::rights& _lhs,
                  const ::fidl::test::protocols::rights& _rhs) const {
    uint32_t _lhs_underlying = static_cast<uint32_t>(_lhs);
    uint32_t _rhs_underlying = static_cast<uint32_t>(_rhs);
    return ::fidl::Equals(_lhs_underlying, _rhs_underlying);
  }
};
template <>
struct CodingTraits<::fidl::test::protocols::obj_type> {
  static constexpr size_t inline_size_old =
      sizeof(::fidl::test::protocols::obj_type);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::fidl::test::protocols::obj_type);
  static constexpr size_t inline_size_v2 =
      sizeof(::fidl::test::protocols::obj_type);
  static void Encode(
      Encoder* encoder, ::fidl::test::protocols::obj_type* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder, ::fidl::test::protocols::obj_type* value,
                     size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::fidl::test::protocols::obj_type>(underlying);
  }
};

inline zx_status_t Clone(::fidl::test::protocols::obj_type value,
                         ::fidl::test::protocols::obj_type* result) {
  return ::fidl::test::protocols::Clone(value, result);
}
template <>
struct Equality<::fidl::test::protocols::obj_type> {
  bool operator()(const ::fidl::test::protocols::obj_type& _lhs,
                  const ::fidl::test::protocols::obj_type& _rhs) const {
    return _lhs == _rhs;
  }
};

#ifdef __Fuchsia__

template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response, 4,
          4> {};

template <>
struct IsMemcpyCompatible<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::protocols::
                          WithErrorSyntax_HandleInResult_Response>::value &&
          IsMemcpyCompatible<::zx::handle>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response&
        value,
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response&
          _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Response&
          _rhs) const {
    if (!::fidl::Equals(_lhs.h, _rhs.h)) {
      return false;
    }
    return true;
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct IsFidlXUnion<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};

template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result, 24,
          16> {};

template <>
struct CodingTraits<std::unique_ptr<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result>*
          value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result>*
          value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(
        new ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result);

    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result& value,
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<
    ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result&
          _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result&
          _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
              Invalid):
        return true;
      case ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
#endif  // __Fuchsia__

template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response,
          24, 24> {};

template <>
struct IsMemcpyCompatible<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::protocols::
                          WithErrorSyntax_ResponseAsStruct_Response>::value &&
          IsMemcpyCompatible<int64_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&
        value,
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response*
        result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&
          _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Response&
          _rhs) const {
    if (!::fidl::Equals(_lhs.a, _rhs.a)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.b, _rhs.b)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.c, _rhs.c)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public std::true_type {};

template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result, 24,
          16> {};

template <>
struct CodingTraits<std::unique_ptr<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>*
          value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result>*
          value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(
        new ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result);

    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result&
        value,
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<
    ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result&
          _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result&
          _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::
              Tag::Invalid):
        return true;
      case ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::
          Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result::
          Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response, 1,
          1> {};

template <>
struct IsMemcpyCompatible<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::protocols::
                          WithErrorSyntax_ErrorAsPrimitive_Response>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&
        value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response*
        result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&
          _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Response&
          _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public std::true_type {};

template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result, 24,
          16> {};

template <>
struct CodingTraits<std::unique_ptr<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>*
          value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result>*
          value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(
        new ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result);

    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result&
        value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result&
          _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result&
          _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
              Tag::Invalid):
        return true;
      case ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
          Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
          Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response, 1, 1> {
};

template <>
struct IsMemcpyCompatible<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::protocols::
                          WithErrorSyntax_ErrorAsEnum_Response>::value &&
          IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Response& _rhs)
      const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::fidl::test::protocols::TheUnion> : public std::true_type {
};

template <>
struct CodingTraits<::fidl::test::protocols::TheUnion>
    : public EncodableCodingTraits<::fidl::test::protocols::TheUnion, 24, 16> {
};

template <>
struct CodingTraits<std::unique_ptr<::fidl::test::protocols::TheUnion>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<::fidl::test::protocols::TheUnion>* value, size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder,
                     std::unique_ptr<::fidl::test::protocols::TheUnion>* value,
                     size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::fidl::test::protocols::TheUnion);

    ::fidl::test::protocols::TheUnion::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::fidl::test::protocols::TheUnion& value,
                         ::fidl::test::protocols::TheUnion* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<::fidl::test::protocols::TheUnion> {
  bool operator()(const ::fidl::test::protocols::TheUnion& _lhs,
                  const ::fidl::test::protocols::TheUnion& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::fidl::test::protocols::TheUnion::Tag::Invalid):
        return true;
      case ::fidl::test::protocols::TheUnion::Tag::kV:
        return ::fidl::Equals(_lhs.v_, _rhs.v_);
      default:
        return ::fidl::Equals(_lhs.unknown_data_, _rhs.unknown_data_);
    }
  }
};
#ifdef __Fuchsia__

template <>
struct CodingTraits<::fidl::test::protocols::ProtocolEnds>
    : public EncodableCodingTraits<::fidl::test::protocols::ProtocolEnds, 16,
                                   16> {};

template <>
struct IsMemcpyCompatible<::fidl::test::protocols::ProtocolEnds>
    : public internal::BoolConstant<
          !HasPadding<::fidl::test::protocols::ProtocolEnds>::value &&
          IsMemcpyCompatible<::fidl::InterfaceHandle<
              ::fidl::test::protocols::DiscoverableProtocol>>::value &&
          IsMemcpyCompatible<::fidl::InterfaceRequest<
              ::fidl::test::protocols::DiscoverableProtocol>>::value> {};

inline zx_status_t Clone(const ::fidl::test::protocols::ProtocolEnds& value,
                         ::fidl::test::protocols::ProtocolEnds* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<::fidl::test::protocols::ProtocolEnds> {
  bool operator()(const ::fidl::test::protocols::ProtocolEnds& _lhs,
                  const ::fidl::test::protocols::ProtocolEnds& _rhs) const {
    if (!::fidl::Equals(_lhs.client, _rhs.client)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.server, _rhs.server)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.client_opt, _rhs.client_opt)) {
      return false;
    }
    if (!::fidl::Equals(_lhs.server_opt, _rhs.server_opt)) {
      return false;
    }
    return true;
  }
};
#endif  // __Fuchsia__

template <>
struct CodingTraits<::fidl::test::protocols::ErrorEnum> {
  static constexpr size_t inline_size_old =
      sizeof(::fidl::test::protocols::ErrorEnum);
  static constexpr size_t inline_size_v1_no_ee =
      sizeof(::fidl::test::protocols::ErrorEnum);
  static constexpr size_t inline_size_v2 =
      sizeof(::fidl::test::protocols::ErrorEnum);
  static void Encode(
      Encoder* encoder, ::fidl::test::protocols::ErrorEnum* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    ZX_DEBUG_ASSERT(!maybe_handle_info);
    uint32_t underlying = static_cast<uint32_t>(*value);
    ::fidl::Encode(encoder, &underlying, offset);
  }
  static void Decode(Decoder* decoder,
                     ::fidl::test::protocols::ErrorEnum* value, size_t offset) {
    uint32_t underlying = {};
    ::fidl::Decode(decoder, &underlying, offset);
    *value = static_cast<::fidl::test::protocols::ErrorEnum>(underlying);
  }
};

inline zx_status_t Clone(::fidl::test::protocols::ErrorEnum value,
                         ::fidl::test::protocols::ErrorEnum* result) {
  return ::fidl::test::protocols::Clone(value, result);
}
template <>
struct Equality<::fidl::test::protocols::ErrorEnum> {
  bool operator()(const ::fidl::test::protocols::ErrorEnum& _lhs,
                  const ::fidl::test::protocols::ErrorEnum& _rhs) const {
    return _lhs == _rhs;
  }
};

template <>
struct IsFidlXUnion<::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public EncodableCodingTraits<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result, 24, 16> {
};

template <>
struct CodingTraits<std::unique_ptr<
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(
      Encoder* encoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>* value,
      size_t offset,
      cpp17::optional<::fidl::HandleInformation> maybe_handle_info) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(
      Decoder* _decoder,
      std::unique_ptr<
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result>* value,
      size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(
        new ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result);

    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Decode(
        _decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(
    const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& value,
    ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* result) {
  return ::fidl::test::protocols::Clone(value, result);
}

template <>
struct Equality<::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result> {
  bool operator()(
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& _lhs,
      const ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result& _rhs)
      const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(
          ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
              Invalid):
        return true;
      case ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
          kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
          kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};

//
// Proxies and stubs declarations
//
namespace test {
namespace protocols {
#ifdef __Fuchsia__

using HandleRightsProtocolPtr = ::fidl::InterfacePtr<HandleRightsProtocol>;
class HandleRightsProtocol_Proxy;
class HandleRightsProtocol_Stub;
class HandleRightsProtocol_EventSender;
class HandleRightsProtocol_Sync;
using HandleRightsProtocolSyncPtr =
    ::fidl::SynchronousInterfacePtr<HandleRightsProtocol>;
class HandleRightsProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kHandleRightsProtocol_NoResponseMethod_Ordinal =
    0x466a6fe3be0bcb7clu;
constexpr uint64_t kHandleRightsProtocol_ResponseMethod_Ordinal =
    0x5ef2bd2bbb280ffclu;
constexpr uint64_t kHandleRightsProtocol_AnEvent_Ordinal = 0xce6b76255d6ed71lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using WithAndWithoutRequestResponsePtr =
    ::fidl::InterfacePtr<WithAndWithoutRequestResponse>;
class WithAndWithoutRequestResponse_Proxy;
class WithAndWithoutRequestResponse_Stub;
class WithAndWithoutRequestResponse_EventSender;
class WithAndWithoutRequestResponse_Sync;
using WithAndWithoutRequestResponseSyncPtr =
    ::fidl::SynchronousInterfacePtr<WithAndWithoutRequestResponse>;
class WithAndWithoutRequestResponse_SyncProxy;

namespace internal {
constexpr uint64_t kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
    0x6ad894147d0c6ba4lu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        0x4068f26bf6d868aelu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        0x447e655905ccfbf4lu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        0x7cb47b2f9e76d17dlu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        0x65eb512ff0e1c07elu;
constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        0x1d323510d4447cf1lu;
constexpr uint64_t kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
    0x125c87a592bff029lu;
constexpr uint64_t kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
    0x177adc0a3ee346c2lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using TransitionalPtr = ::fidl::InterfacePtr<Transitional>;
class Transitional_Proxy;
class Transitional_Stub;
class Transitional_EventSender;
class Transitional_Sync;
using TransitionalSyncPtr = ::fidl::SynchronousInterfacePtr<Transitional>;
class Transitional_SyncProxy;

namespace internal {
constexpr uint64_t kTransitional_Request_Ordinal = 0x62d345e621780ee8lu;
constexpr uint64_t kTransitional_OneWay_Ordinal = 0xf99bc4b26bc9ea5lu;
constexpr uint64_t kTransitional_Event_Ordinal = 0x53bb9212bcbe8966lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using MethodWithUnionPtr = ::fidl::InterfacePtr<MethodWithUnion>;
class MethodWithUnion_Proxy;
class MethodWithUnion_Stub;
class MethodWithUnion_EventSender;
class MethodWithUnion_Sync;
using MethodWithUnionSyncPtr = ::fidl::SynchronousInterfacePtr<MethodWithUnion>;
class MethodWithUnion_SyncProxy;

namespace internal {
constexpr uint64_t kMethodWithUnion_UnionMethod_Ordinal = 0x5ba125a32d36092alu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using WithProtocolEndsPtr = ::fidl::InterfacePtr<WithProtocolEnds>;
class WithProtocolEnds_Proxy;
class WithProtocolEnds_Stub;
class WithProtocolEnds_EventSender;
class WithProtocolEnds_Sync;
using WithProtocolEndsSyncPtr =
    ::fidl::SynchronousInterfacePtr<WithProtocolEnds>;
class WithProtocolEnds_SyncProxy;

namespace internal {
constexpr uint64_t kWithProtocolEnds_ClientEnds_Ordinal = 0x60b18491ac8062adlu;
constexpr uint64_t kWithProtocolEnds_ServerEnds_Ordinal = 0x3e5b3b503a05a17clu;
constexpr uint64_t kWithProtocolEnds_StructContainingEnds_Ordinal =
    0x26f2c10b743415clu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using ManyParametersPtr = ::fidl::InterfacePtr<ManyParameters>;
class ManyParameters_Proxy;
class ManyParameters_Stub;
class ManyParameters_EventSender;
class ManyParameters_Sync;
using ManyParametersSyncPtr = ::fidl::SynchronousInterfacePtr<ManyParameters>;
class ManyParameters_SyncProxy;

namespace internal {
constexpr uint64_t kManyParameters_Fifteen_Ordinal = 0x295ae26a080f53e3lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using WithErrorSyntaxPtr = ::fidl::InterfacePtr<WithErrorSyntax>;
class WithErrorSyntax_Proxy;
class WithErrorSyntax_Stub;
class WithErrorSyntax_EventSender;
class WithErrorSyntax_Sync;
using WithErrorSyntaxSyncPtr = ::fidl::SynchronousInterfacePtr<WithErrorSyntax>;
class WithErrorSyntax_SyncProxy;

namespace internal {
constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal =
    0x3784d38864674290lu;
constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal =
    0x2f7c390f3cdef4celu;
constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal = 0x8b550d7c29f740clu;
constexpr uint64_t kWithErrorSyntax_HandleInResult_Ordinal =
    0x1dcf0cfb09e14f97lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using DiscoverableProtocolPtr = ::fidl::InterfacePtr<DiscoverableProtocol>;
class DiscoverableProtocol_Proxy;
class DiscoverableProtocol_Stub;
class DiscoverableProtocol_EventSender;
class DiscoverableProtocol_Sync;
using DiscoverableProtocolSyncPtr =
    ::fidl::SynchronousInterfacePtr<DiscoverableProtocol>;
class DiscoverableProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kDiscoverableProtocol_Method_Ordinal = 0x39790af74e0167lu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using ChannelProtocolPtr = ::fidl::InterfacePtr<ChannelProtocol>;
class ChannelProtocol_Proxy;
class ChannelProtocol_Stub;
class ChannelProtocol_EventSender;
class ChannelProtocol_Sync;
using ChannelProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<ChannelProtocol>;
class ChannelProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kChannelProtocol_MethodA_Ordinal = 0x7d92c10fb2d002elu;
constexpr uint64_t kChannelProtocol_EventA_Ordinal = 0x52c2fa481a687dfalu;
constexpr uint64_t kChannelProtocol_MethodB_Ordinal = 0x5da1d2ed00055cealu;
constexpr uint64_t kChannelProtocol_TakeHandle_Ordinal = 0xc25674355065c28lu;
constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal = 0x7dd036a18b33b76alu;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class HandleRightsProtocol {
 public:
  using Proxy_ = ::fidl::test::protocols::HandleRightsProtocol_Proxy;
  using Stub_ = ::fidl::test::protocols::HandleRightsProtocol_Stub;
  using EventSender_ =
      ::fidl::test::protocols::HandleRightsProtocol_EventSender;
  using Sync_ = ::fidl::test::protocols::HandleRightsProtocol_Sync;
  virtual ~HandleRightsProtocol();

  virtual void NoResponseMethod(::zx::socket h) = 0;
  using ResponseMethodCallback = fit::function<void(::zx::socket)>;

  virtual void ResponseMethod(::zx::socket h,
                              ResponseMethodCallback callback) = 0;
  using AnEventCallback = fit::function<void(::zx::socket)>;
};

class HandleRightsProtocol_RequestDecoder {
 public:
  HandleRightsProtocol_RequestDecoder() = default;
  virtual ~HandleRightsProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void NoResponseMethod(::zx::socket h) = 0;
  virtual void ResponseMethod(::zx::socket h) = 0;
};

class HandleRightsProtocol_ResponseDecoder {
 public:
  HandleRightsProtocol_ResponseDecoder() = default;
  virtual ~HandleRightsProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void ResponseMethod(::zx::socket h) = 0;
  virtual void AnEvent(::zx::socket h) = 0;
};

class HandleRightsProtocol_EventSender {
 public:
  virtual ~HandleRightsProtocol_EventSender();
  virtual void AnEvent(::zx::socket h) = 0;
};

class HandleRightsProtocol_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::HandleRightsProtocol_SyncProxy;
  virtual ~HandleRightsProtocol_Sync();
  virtual zx_status_t NoResponseMethod(::zx::socket h) = 0;
  virtual zx_status_t ResponseMethod(::zx::socket h, ::zx::socket* out_h) = 0;
};

class HandleRightsProtocol_Proxy final : public ::fidl::internal::Proxy,
                                         public HandleRightsProtocol {
 public:
  explicit HandleRightsProtocol_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~HandleRightsProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void NoResponseMethod(::zx::socket h) override;
  void ResponseMethod(::zx::socket h, ResponseMethodCallback callback) override;
  AnEventCallback AnEvent;

 private:
  HandleRightsProtocol_Proxy(
      const ::fidl::test::protocols::HandleRightsProtocol_Proxy&) = delete;
  HandleRightsProtocol_Proxy& operator=(
      const ::fidl::test::protocols::HandleRightsProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class HandleRightsProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::HandleRightsProtocol_EventSender {
 public:
  typedef class ::fidl::test::protocols::HandleRightsProtocol
      HandleRightsProtocol_clazz;
  explicit HandleRightsProtocol_Stub(
      ::fidl::test::protocols::HandleRightsProtocol_Stub::
          HandleRightsProtocol_clazz* impl);
  ~HandleRightsProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void AnEvent(::zx::socket h) override;

 private:
  ::fidl::test::protocols::HandleRightsProtocol_Stub::
      HandleRightsProtocol_clazz* impl_;
};

class HandleRightsProtocol_SyncProxy
    : public ::fidl::test::protocols::HandleRightsProtocol_Sync {
 public:
  explicit HandleRightsProtocol_SyncProxy(::zx::channel channel);
  ~HandleRightsProtocol_SyncProxy() override;
  zx_status_t NoResponseMethod(::zx::socket h) override;
  zx_status_t ResponseMethod(::zx::socket h, ::zx::socket* out_h) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<HandleRightsProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithAndWithoutRequestResponse {
 public:
  using Proxy_ = ::fidl::test::protocols::WithAndWithoutRequestResponse_Proxy;
  using Stub_ = ::fidl::test::protocols::WithAndWithoutRequestResponse_Stub;
  using EventSender_ =
      ::fidl::test::protocols::WithAndWithoutRequestResponse_EventSender;
  using Sync_ = ::fidl::test::protocols::WithAndWithoutRequestResponse_Sync;
  virtual ~WithAndWithoutRequestResponse();

  virtual void NoRequestNoResponse() = 0;
  using NoRequestEmptyResponseCallback = fit::function<void()>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseCallback callback) = 0;
  using NoRequestWithResponseCallback = fit::function<void(::std::string)>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseCallback callback) = 0;

  virtual void WithRequestNoResponse(::std::string arg) = 0;
  using WithRequestEmptyResponseCallback = fit::function<void()>;

  virtual void WithRequestEmptyResponse(
      ::std::string arg, WithRequestEmptyResponseCallback callback) = 0;
  using WithRequestWithResponseCallback = fit::function<void(::std::string)>;

  virtual void WithRequestWithResponse(
      ::std::string arg, WithRequestWithResponseCallback callback) = 0;
  using OnEmptyResponseCallback = fit::function<void()>;
  using OnWithResponseCallback = fit::function<void(::std::string)>;
};

class WithAndWithoutRequestResponse_RequestDecoder {
 public:
  WithAndWithoutRequestResponse_RequestDecoder() = default;
  virtual ~WithAndWithoutRequestResponse_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void NoRequestNoResponse() = 0;
  virtual void NoRequestEmptyResponse() = 0;
  virtual void NoRequestWithResponse() = 0;
  virtual void WithRequestNoResponse(::std::string arg) = 0;
  virtual void WithRequestEmptyResponse(::std::string arg) = 0;
  virtual void WithRequestWithResponse(::std::string arg) = 0;
};

class WithAndWithoutRequestResponse_ResponseDecoder {
 public:
  WithAndWithoutRequestResponse_ResponseDecoder() = default;
  virtual ~WithAndWithoutRequestResponse_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void NoRequestEmptyResponse() = 0;
  virtual void NoRequestWithResponse(::std::string ret) = 0;
  virtual void WithRequestEmptyResponse() = 0;
  virtual void WithRequestWithResponse(::std::string ret) = 0;
  virtual void OnEmptyResponse() = 0;
  virtual void OnWithResponse(::std::string ret) = 0;
};

class WithAndWithoutRequestResponse_EventSender {
 public:
  virtual ~WithAndWithoutRequestResponse_EventSender();
  virtual void OnEmptyResponse() = 0;
  virtual void OnWithResponse(::std::string ret) = 0;
};

class WithAndWithoutRequestResponse_Sync {
 public:
  using Proxy_ =
      ::fidl::test::protocols::WithAndWithoutRequestResponse_SyncProxy;
  virtual ~WithAndWithoutRequestResponse_Sync();
  virtual zx_status_t NoRequestNoResponse() = 0;
  virtual zx_status_t NoRequestEmptyResponse() = 0;
  virtual zx_status_t NoRequestWithResponse(::std::string* out_ret) = 0;
  virtual zx_status_t WithRequestNoResponse(::std::string arg) = 0;
  virtual zx_status_t WithRequestEmptyResponse(::std::string arg) = 0;
  virtual zx_status_t WithRequestWithResponse(::std::string arg,
                                              ::std::string* out_ret) = 0;
};

class WithAndWithoutRequestResponse_Proxy final
    : public ::fidl::internal::Proxy,
      public WithAndWithoutRequestResponse {
 public:
  explicit WithAndWithoutRequestResponse_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~WithAndWithoutRequestResponse_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void NoRequestNoResponse() override;
  void NoRequestEmptyResponse(NoRequestEmptyResponseCallback callback) override;
  void NoRequestWithResponse(NoRequestWithResponseCallback callback) override;
  void WithRequestNoResponse(::std::string arg) override;
  void WithRequestEmptyResponse(
      ::std::string arg, WithRequestEmptyResponseCallback callback) override;
  void WithRequestWithResponse(
      ::std::string arg, WithRequestWithResponseCallback callback) override;
  OnEmptyResponseCallback OnEmptyResponse;
  OnWithResponseCallback OnWithResponse;

 private:
  WithAndWithoutRequestResponse_Proxy(
      const ::fidl::test::protocols::WithAndWithoutRequestResponse_Proxy&) =
      delete;
  WithAndWithoutRequestResponse_Proxy& operator=(
      const ::fidl::test::protocols::WithAndWithoutRequestResponse_Proxy&) =
      delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithAndWithoutRequestResponse_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::
          WithAndWithoutRequestResponse_EventSender {
 public:
  typedef class ::fidl::test::protocols::WithAndWithoutRequestResponse
      WithAndWithoutRequestResponse_clazz;
  explicit WithAndWithoutRequestResponse_Stub(
      ::fidl::test::protocols::WithAndWithoutRequestResponse_Stub::
          WithAndWithoutRequestResponse_clazz* impl);
  ~WithAndWithoutRequestResponse_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void OnEmptyResponse() override;
  void OnWithResponse(::std::string ret) override;

 private:
  ::fidl::test::protocols::WithAndWithoutRequestResponse_Stub::
      WithAndWithoutRequestResponse_clazz* impl_;
};

class WithAndWithoutRequestResponse_SyncProxy
    : public ::fidl::test::protocols::WithAndWithoutRequestResponse_Sync {
 public:
  explicit WithAndWithoutRequestResponse_SyncProxy(::zx::channel channel);
  ~WithAndWithoutRequestResponse_SyncProxy() override;
  zx_status_t NoRequestNoResponse() override;
  zx_status_t NoRequestEmptyResponse() override;
  zx_status_t NoRequestWithResponse(::std::string* out_ret) override;
  zx_status_t WithRequestNoResponse(::std::string arg) override;
  zx_status_t WithRequestEmptyResponse(::std::string arg) override;
  zx_status_t WithRequestWithResponse(::std::string arg,
                                      ::std::string* out_ret) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithAndWithoutRequestResponse>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class Transitional {
 public:
  using Proxy_ = ::fidl::test::protocols::Transitional_Proxy;
  using Stub_ = ::fidl::test::protocols::Transitional_Stub;
  using EventSender_ = ::fidl::test::protocols::Transitional_EventSender;
  using Sync_ = ::fidl::test::protocols::Transitional_Sync;
  virtual ~Transitional();
  using RequestCallback = fit::function<void(int64_t)>;

  virtual void Request(int64_t x, RequestCallback callback) {}

  virtual void OneWay(int64_t x) {}
  using EventCallback = fit::function<void(int64_t)>;
};

class Transitional_RequestDecoder {
 public:
  Transitional_RequestDecoder() = default;
  virtual ~Transitional_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void Request(int64_t x) = 0;
  virtual void OneWay(int64_t x) = 0;
};

class Transitional_ResponseDecoder {
 public:
  Transitional_ResponseDecoder() = default;
  virtual ~Transitional_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void Request(int64_t y) = 0;
  virtual void Event(int64_t x) = 0;
};

class Transitional_EventSender {
 public:
  virtual ~Transitional_EventSender();
  virtual void Event(int64_t x) = 0;
};

class Transitional_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::Transitional_SyncProxy;
  virtual ~Transitional_Sync();
  virtual zx_status_t Request(int64_t x, int64_t* out_y) = 0;
  virtual zx_status_t OneWay(int64_t x) = 0;
};

class Transitional_Proxy final : public ::fidl::internal::Proxy,
                                 public Transitional {
 public:
  explicit Transitional_Proxy(::fidl::internal::ProxyController* controller);
  ~Transitional_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void Request(int64_t x, RequestCallback callback) override;
  void OneWay(int64_t x) override;
  EventCallback Event;

 private:
  Transitional_Proxy(const ::fidl::test::protocols::Transitional_Proxy&) =
      delete;
  Transitional_Proxy& operator=(
      const ::fidl::test::protocols::Transitional_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class Transitional_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::Transitional_EventSender {
 public:
  typedef class ::fidl::test::protocols::Transitional Transitional_clazz;
  explicit Transitional_Stub(
      ::fidl::test::protocols::Transitional_Stub::Transitional_clazz* impl);
  ~Transitional_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void Event(int64_t x) override;

 private:
  ::fidl::test::protocols::Transitional_Stub::Transitional_clazz* impl_;
};

class Transitional_SyncProxy
    : public ::fidl::test::protocols::Transitional_Sync {
 public:
  explicit Transitional_SyncProxy(::zx::channel channel);
  ~Transitional_SyncProxy() override;
  zx_status_t Request(int64_t x, int64_t* out_y) override;
  zx_status_t OneWay(int64_t x) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<Transitional>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class MethodWithUnion {
 public:
  using Proxy_ = ::fidl::test::protocols::MethodWithUnion_Proxy;
  using Stub_ = ::fidl::test::protocols::MethodWithUnion_Stub;
  using EventSender_ = ::fidl::test::protocols::MethodWithUnion_EventSender;
  using Sync_ = ::fidl::test::protocols::MethodWithUnion_Sync;
  virtual ~MethodWithUnion();

  virtual void UnionMethod(::fidl::test::protocols::TheUnion u) = 0;
};

class MethodWithUnion_RequestDecoder {
 public:
  MethodWithUnion_RequestDecoder() = default;
  virtual ~MethodWithUnion_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void UnionMethod(::fidl::test::protocols::TheUnion u) = 0;
};

class MethodWithUnion_ResponseDecoder {
 public:
  MethodWithUnion_ResponseDecoder() = default;
  virtual ~MethodWithUnion_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
};

class MethodWithUnion_EventSender {
 public:
  virtual ~MethodWithUnion_EventSender();
};

class MethodWithUnion_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::MethodWithUnion_SyncProxy;
  virtual ~MethodWithUnion_Sync();
  virtual zx_status_t UnionMethod(::fidl::test::protocols::TheUnion u) = 0;
};

class MethodWithUnion_Proxy final : public ::fidl::internal::Proxy,
                                    public MethodWithUnion {
 public:
  explicit MethodWithUnion_Proxy(::fidl::internal::ProxyController* controller);
  ~MethodWithUnion_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void UnionMethod(::fidl::test::protocols::TheUnion u) override;

 private:
  MethodWithUnion_Proxy(const ::fidl::test::protocols::MethodWithUnion_Proxy&) =
      delete;
  MethodWithUnion_Proxy& operator=(
      const ::fidl::test::protocols::MethodWithUnion_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class MethodWithUnion_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::MethodWithUnion_EventSender {
 public:
  typedef class ::fidl::test::protocols::MethodWithUnion MethodWithUnion_clazz;
  explicit MethodWithUnion_Stub(
      ::fidl::test::protocols::MethodWithUnion_Stub::MethodWithUnion_clazz*
          impl);
  ~MethodWithUnion_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::fidl::test::protocols::MethodWithUnion_Stub::MethodWithUnion_clazz* impl_;
};

class MethodWithUnion_SyncProxy
    : public ::fidl::test::protocols::MethodWithUnion_Sync {
 public:
  explicit MethodWithUnion_SyncProxy(::zx::channel channel);
  ~MethodWithUnion_SyncProxy() override;
  zx_status_t UnionMethod(::fidl::test::protocols::TheUnion u) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<MethodWithUnion>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithProtocolEnds {
 public:
  using Proxy_ = ::fidl::test::protocols::WithProtocolEnds_Proxy;
  using Stub_ = ::fidl::test::protocols::WithProtocolEnds_Stub;
  using EventSender_ = ::fidl::test::protocols::WithProtocolEnds_EventSender;
  using Sync_ = ::fidl::test::protocols::WithProtocolEnds_Sync;
  virtual ~WithProtocolEnds();
  using ClientEndsCallback = fit::function<void(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>)>;

  virtual void ClientEnds(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol> in,
      ClientEndsCallback callback) = 0;
  using ServerEndsCallback = fit::function<void(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>)>;

  virtual void ServerEnds(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
          in,
      ServerEndsCallback callback) = 0;
  using StructContainingEndsCallback =
      fit::function<void(::fidl::test::protocols::ProtocolEnds)>;

  virtual void StructContainingEnds(::fidl::test::protocols::ProtocolEnds in,
                                    StructContainingEndsCallback callback) = 0;
};

class WithProtocolEnds_RequestDecoder {
 public:
  WithProtocolEnds_RequestDecoder() = default;
  virtual ~WithProtocolEnds_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void ClientEnds(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>
          in) = 0;
  virtual void ServerEnds(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
          in) = 0;
  virtual void StructContainingEnds(
      ::fidl::test::protocols::ProtocolEnds in) = 0;
};

class WithProtocolEnds_ResponseDecoder {
 public:
  WithProtocolEnds_ResponseDecoder() = default;
  virtual ~WithProtocolEnds_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void ClientEnds(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>
          out) = 0;
  virtual void ServerEnds(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
          out) = 0;
  virtual void StructContainingEnds(
      ::fidl::test::protocols::ProtocolEnds out) = 0;
};

class WithProtocolEnds_EventSender {
 public:
  virtual ~WithProtocolEnds_EventSender();
};

class WithProtocolEnds_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::WithProtocolEnds_SyncProxy;
  virtual ~WithProtocolEnds_Sync();
  virtual zx_status_t ClientEnds(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol> in,
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>*
          out_out) = 0;
  virtual zx_status_t ServerEnds(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
          in,
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>*
          out_out) = 0;
  virtual zx_status_t StructContainingEnds(
      ::fidl::test::protocols::ProtocolEnds in,
      ::fidl::test::protocols::ProtocolEnds* out_out) = 0;
};

class WithProtocolEnds_Proxy final : public ::fidl::internal::Proxy,
                                     public WithProtocolEnds {
 public:
  explicit WithProtocolEnds_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~WithProtocolEnds_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void ClientEnds(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol> in,
      ClientEndsCallback callback) override;
  void ServerEnds(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
          in,
      ServerEndsCallback callback) override;
  void StructContainingEnds(::fidl::test::protocols::ProtocolEnds in,
                            StructContainingEndsCallback callback) override;

 private:
  WithProtocolEnds_Proxy(
      const ::fidl::test::protocols::WithProtocolEnds_Proxy&) = delete;
  WithProtocolEnds_Proxy& operator=(
      const ::fidl::test::protocols::WithProtocolEnds_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithProtocolEnds_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::WithProtocolEnds_EventSender {
 public:
  typedef class ::fidl::test::protocols::WithProtocolEnds
      WithProtocolEnds_clazz;
  explicit WithProtocolEnds_Stub(
      ::fidl::test::protocols::WithProtocolEnds_Stub::WithProtocolEnds_clazz*
          impl);
  ~WithProtocolEnds_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::fidl::test::protocols::WithProtocolEnds_Stub::WithProtocolEnds_clazz* impl_;
};

class WithProtocolEnds_SyncProxy
    : public ::fidl::test::protocols::WithProtocolEnds_Sync {
 public:
  explicit WithProtocolEnds_SyncProxy(::zx::channel channel);
  ~WithProtocolEnds_SyncProxy() override;
  zx_status_t ClientEnds(
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol> in,
      ::fidl::InterfaceHandle<::fidl::test::protocols::DiscoverableProtocol>*
          out_out) override;
  zx_status_t ServerEnds(
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>
          in,
      ::fidl::InterfaceRequest<::fidl::test::protocols::DiscoverableProtocol>*
          out_out) override;
  zx_status_t StructContainingEnds(
      ::fidl::test::protocols::ProtocolEnds in,
      ::fidl::test::protocols::ProtocolEnds* out_out) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithProtocolEnds>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ManyParameters {
 public:
  using Proxy_ = ::fidl::test::protocols::ManyParameters_Proxy;
  using Stub_ = ::fidl::test::protocols::ManyParameters_Stub;
  using EventSender_ = ::fidl::test::protocols::ManyParameters_EventSender;
  using Sync_ = ::fidl::test::protocols::ManyParameters_Sync;
  virtual ~ManyParameters();

  virtual void Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15) = 0;
};

class ManyParameters_RequestDecoder {
 public:
  ManyParameters_RequestDecoder() = default;
  virtual ~ManyParameters_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15) = 0;
};

class ManyParameters_ResponseDecoder {
 public:
  ManyParameters_ResponseDecoder() = default;
  virtual ~ManyParameters_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
};

class ManyParameters_EventSender {
 public:
  virtual ~ManyParameters_EventSender();
};

class ManyParameters_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::ManyParameters_SyncProxy;
  virtual ~ManyParameters_Sync();
  virtual zx_status_t Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5,
                              bool p6, bool p7, bool p8, bool p9, bool p10,
                              bool p11, bool p12, bool p13, bool p14,
                              bool p15) = 0;
};

class ManyParameters_Proxy final : public ::fidl::internal::Proxy,
                                   public ManyParameters {
 public:
  explicit ManyParameters_Proxy(::fidl::internal::ProxyController* controller);
  ~ManyParameters_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7,
               bool p8, bool p9, bool p10, bool p11, bool p12, bool p13,
               bool p14, bool p15) override;

 private:
  ManyParameters_Proxy(const ::fidl::test::protocols::ManyParameters_Proxy&) =
      delete;
  ManyParameters_Proxy& operator=(
      const ::fidl::test::protocols::ManyParameters_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class ManyParameters_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::ManyParameters_EventSender {
 public:
  typedef class ::fidl::test::protocols::ManyParameters ManyParameters_clazz;
  explicit ManyParameters_Stub(
      ::fidl::test::protocols::ManyParameters_Stub::ManyParameters_clazz* impl);
  ~ManyParameters_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::fidl::test::protocols::ManyParameters_Stub::ManyParameters_clazz* impl_;
};

class ManyParameters_SyncProxy
    : public ::fidl::test::protocols::ManyParameters_Sync {
 public:
  explicit ManyParameters_SyncProxy(::zx::channel channel);
  ~ManyParameters_SyncProxy() override;
  zx_status_t Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                      bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                      bool p13, bool p14, bool p15) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<ManyParameters>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class WithErrorSyntax {
 public:
  using Proxy_ = ::fidl::test::protocols::WithErrorSyntax_Proxy;
  using Stub_ = ::fidl::test::protocols::WithErrorSyntax_Stub;
  using EventSender_ = ::fidl::test::protocols::WithErrorSyntax_EventSender;
  using Sync_ = ::fidl::test::protocols::WithErrorSyntax_Sync;
  virtual ~WithErrorSyntax();
  using ResponseAsStructCallback = fit::function<void(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result)>;

  virtual void ResponseAsStruct(ResponseAsStructCallback callback) = 0;
  using ErrorAsPrimitiveCallback = fit::function<void(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result)>;

  virtual void ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) = 0;
  using ErrorAsEnumCallback = fit::function<void(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result)>;

  virtual void ErrorAsEnum(ErrorAsEnumCallback callback) = 0;
  using HandleInResultCallback = fit::function<void(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result)>;

  virtual void HandleInResult(HandleInResultCallback callback) = 0;
};

class WithErrorSyntax_RequestDecoder {
 public:
  WithErrorSyntax_RequestDecoder() = default;
  virtual ~WithErrorSyntax_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void ResponseAsStruct() = 0;
  virtual void ErrorAsPrimitive() = 0;
  virtual void ErrorAsEnum() = 0;
  virtual void HandleInResult() = 0;
};

class WithErrorSyntax_ResponseDecoder {
 public:
  WithErrorSyntax_ResponseDecoder() = default;
  virtual ~WithErrorSyntax_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void ResponseAsStruct(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result
          result) = 0;
  virtual void ErrorAsPrimitive(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result
          result) = 0;
  virtual void ErrorAsEnum(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result result) = 0;
  virtual void HandleInResult(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result
          result) = 0;
};

class WithErrorSyntax_EventSender {
 public:
  virtual ~WithErrorSyntax_EventSender();
};

class WithErrorSyntax_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::WithErrorSyntax_SyncProxy;
  virtual ~WithErrorSyntax_Sync();
  virtual zx_status_t ResponseAsStruct(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result*
          out_result) = 0;
  virtual zx_status_t ErrorAsPrimitive(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result*
          out_result) = 0;
  virtual zx_status_t ErrorAsEnum(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result*
          out_result) = 0;
  virtual zx_status_t HandleInResult(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result*
          out_result) = 0;
};

class WithErrorSyntax_Proxy final : public ::fidl::internal::Proxy,
                                    public WithErrorSyntax {
 public:
  explicit WithErrorSyntax_Proxy(::fidl::internal::ProxyController* controller);
  ~WithErrorSyntax_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void ResponseAsStruct(ResponseAsStructCallback callback) override;
  void ErrorAsPrimitive(ErrorAsPrimitiveCallback callback) override;
  void ErrorAsEnum(ErrorAsEnumCallback callback) override;
  void HandleInResult(HandleInResultCallback callback) override;

 private:
  WithErrorSyntax_Proxy(const ::fidl::test::protocols::WithErrorSyntax_Proxy&) =
      delete;
  WithErrorSyntax_Proxy& operator=(
      const ::fidl::test::protocols::WithErrorSyntax_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class WithErrorSyntax_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::WithErrorSyntax_EventSender {
 public:
  typedef class ::fidl::test::protocols::WithErrorSyntax WithErrorSyntax_clazz;
  explicit WithErrorSyntax_Stub(
      ::fidl::test::protocols::WithErrorSyntax_Stub::WithErrorSyntax_clazz*
          impl);
  ~WithErrorSyntax_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::fidl::test::protocols::WithErrorSyntax_Stub::WithErrorSyntax_clazz* impl_;
};

class WithErrorSyntax_SyncProxy
    : public ::fidl::test::protocols::WithErrorSyntax_Sync {
 public:
  explicit WithErrorSyntax_SyncProxy(::zx::channel channel);
  ~WithErrorSyntax_SyncProxy() override;
  zx_status_t ResponseAsStruct(
      ::fidl::test::protocols::WithErrorSyntax_ResponseAsStruct_Result*
          out_result) override;
  zx_status_t ErrorAsPrimitive(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsPrimitive_Result*
          out_result) override;
  zx_status_t ErrorAsEnum(
      ::fidl::test::protocols::WithErrorSyntax_ErrorAsEnum_Result* out_result)
      override;
  zx_status_t HandleInResult(
      ::fidl::test::protocols::WithErrorSyntax_HandleInResult_Result*
          out_result) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<WithErrorSyntax>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class DiscoverableProtocol {
 public:
  using Proxy_ = ::fidl::test::protocols::DiscoverableProtocol_Proxy;
  using Stub_ = ::fidl::test::protocols::DiscoverableProtocol_Stub;
  using EventSender_ =
      ::fidl::test::protocols::DiscoverableProtocol_EventSender;
  using Sync_ = ::fidl::test::protocols::DiscoverableProtocol_Sync;
  static const char Name_[];
  virtual ~DiscoverableProtocol();

  virtual void Method() = 0;
};

class DiscoverableProtocol_RequestDecoder {
 public:
  DiscoverableProtocol_RequestDecoder() = default;
  virtual ~DiscoverableProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void Method() = 0;
};

class DiscoverableProtocol_ResponseDecoder {
 public:
  DiscoverableProtocol_ResponseDecoder() = default;
  virtual ~DiscoverableProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
};

class DiscoverableProtocol_EventSender {
 public:
  virtual ~DiscoverableProtocol_EventSender();
};

class DiscoverableProtocol_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::DiscoverableProtocol_SyncProxy;
  virtual ~DiscoverableProtocol_Sync();
  virtual zx_status_t Method() = 0;
};

class DiscoverableProtocol_Proxy final : public ::fidl::internal::Proxy,
                                         public DiscoverableProtocol {
 public:
  explicit DiscoverableProtocol_Proxy(
      ::fidl::internal::ProxyController* controller);
  ~DiscoverableProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void Method() override;

 private:
  DiscoverableProtocol_Proxy(
      const ::fidl::test::protocols::DiscoverableProtocol_Proxy&) = delete;
  DiscoverableProtocol_Proxy& operator=(
      const ::fidl::test::protocols::DiscoverableProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class DiscoverableProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::DiscoverableProtocol_EventSender {
 public:
  typedef class ::fidl::test::protocols::DiscoverableProtocol
      DiscoverableProtocol_clazz;
  explicit DiscoverableProtocol_Stub(
      ::fidl::test::protocols::DiscoverableProtocol_Stub::
          DiscoverableProtocol_clazz* impl);
  ~DiscoverableProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;

 private:
  ::fidl::test::protocols::DiscoverableProtocol_Stub::
      DiscoverableProtocol_clazz* impl_;
};

class DiscoverableProtocol_SyncProxy
    : public ::fidl::test::protocols::DiscoverableProtocol_Sync {
 public:
  explicit DiscoverableProtocol_SyncProxy(::zx::channel channel);
  ~DiscoverableProtocol_SyncProxy() override;
  zx_status_t Method() override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<DiscoverableProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class ChannelProtocol {
 public:
  using Proxy_ = ::fidl::test::protocols::ChannelProtocol_Proxy;
  using Stub_ = ::fidl::test::protocols::ChannelProtocol_Stub;
  using EventSender_ = ::fidl::test::protocols::ChannelProtocol_EventSender;
  using Sync_ = ::fidl::test::protocols::ChannelProtocol_Sync;
  virtual ~ChannelProtocol();

  virtual void MethodA(int64_t a, int64_t b) = 0;
  using EventACallback = fit::function<void(int64_t, int64_t)>;
  using MethodBCallback = fit::function<void(int64_t)>;

  virtual void MethodB(int64_t a, int64_t b, MethodBCallback callback) = 0;
  using TakeHandleCallback = fit::function<void()>;

  virtual void TakeHandle(::zx::handle h, TakeHandleCallback callback) = 0;
  using MutateSocketCallback = fit::function<void(::zx::socket)>;

  virtual void MutateSocket(::zx::socket a, MutateSocketCallback callback) = 0;
};

class ChannelProtocol_RequestDecoder {
 public:
  ChannelProtocol_RequestDecoder() = default;
  virtual ~ChannelProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void MethodA(int64_t a, int64_t b) = 0;
  virtual void MethodB(int64_t a, int64_t b) = 0;
  virtual void TakeHandle(::zx::handle h) = 0;
  virtual void MutateSocket(::zx::socket a) = 0;
};

class ChannelProtocol_ResponseDecoder {
 public:
  ChannelProtocol_ResponseDecoder() = default;
  virtual ~ChannelProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void EventA(int64_t a, int64_t b) = 0;
  virtual void MethodB(int64_t result) = 0;
  virtual void TakeHandle() = 0;
  virtual void MutateSocket(::zx::socket b) = 0;
};

class ChannelProtocol_EventSender {
 public:
  virtual ~ChannelProtocol_EventSender();
  virtual void EventA(int64_t a, int64_t b) = 0;
};

class ChannelProtocol_Sync {
 public:
  using Proxy_ = ::fidl::test::protocols::ChannelProtocol_SyncProxy;
  virtual ~ChannelProtocol_Sync();
  virtual zx_status_t MethodA(int64_t a, int64_t b) = 0;
  virtual zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) = 0;
  virtual zx_status_t TakeHandle(::zx::handle h) = 0;
  virtual zx_status_t MutateSocket(::zx::socket a, ::zx::socket* out_b) = 0;
};

class ChannelProtocol_Proxy final : public ::fidl::internal::Proxy,
                                    public ChannelProtocol {
 public:
  explicit ChannelProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~ChannelProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  void MethodA(int64_t a, int64_t b) override;
  EventACallback EventA;
  void MethodB(int64_t a, int64_t b, MethodBCallback callback) override;
  void TakeHandle(::zx::handle h, TakeHandleCallback callback) override;
  void MutateSocket(::zx::socket a, MutateSocketCallback callback) override;

 private:
  ChannelProtocol_Proxy(const ::fidl::test::protocols::ChannelProtocol_Proxy&) =
      delete;
  ChannelProtocol_Proxy& operator=(
      const ::fidl::test::protocols::ChannelProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class ChannelProtocol_Stub final
    : public ::fidl::internal::Stub,
      public ::fidl::test::protocols::ChannelProtocol_EventSender {
 public:
  typedef class ::fidl::test::protocols::ChannelProtocol ChannelProtocol_clazz;
  explicit ChannelProtocol_Stub(
      ::fidl::test::protocols::ChannelProtocol_Stub::ChannelProtocol_clazz*
          impl);
  ~ChannelProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void EventA(int64_t a, int64_t b) override;

 private:
  ::fidl::test::protocols::ChannelProtocol_Stub::ChannelProtocol_clazz* impl_;
};

class ChannelProtocol_SyncProxy
    : public ::fidl::test::protocols::ChannelProtocol_Sync {
 public:
  explicit ChannelProtocol_SyncProxy(::zx::channel channel);
  ~ChannelProtocol_SyncProxy() override;
  zx_status_t MethodA(int64_t a, int64_t b) override;
  zx_status_t MethodB(int64_t a, int64_t b, int64_t* out_result) override;
  zx_status_t TakeHandle(::zx::handle h) override;
  zx_status_t MutateSocket(::zx::socket a, ::zx::socket* out_b) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<ChannelProtocol>;
};
#endif  // __Fuchsia__

}  // namespace protocols
}  // namespace test
}  // namespace fidl
