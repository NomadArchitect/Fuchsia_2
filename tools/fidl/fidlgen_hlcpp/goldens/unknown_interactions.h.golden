// WARNING: This file is machine generated by fidlgen.

#pragma once

#include "lib/fidl/cpp/internal/header.h"

namespace test {
namespace unknowninteractions {

//
// Domain objects declarations
//

class UnknownInteractionsProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsProtocol_StrictEventErr_Response;

class UnknownInteractionsProtocol_StrictEventErr_Result;

class UnknownInteractionsProtocolStrictEventErrRequest;

class UnknownInteractionsProtocol_FlexibleTwoWay_Response;

class UnknownInteractionsProtocol_FlexibleTwoWay_Result;

class UnknownInteractionsProtocolFlexibleTwoWayTopResponse;

class UnknownInteractionsProtocol_FlexibleTwoWayErr_Response;

class UnknownInteractionsProtocol_FlexibleTwoWayErr_Result;

class UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse;

class UnknownInteractionsProtocol_FlexibleEventErr_Response;

class UnknownInteractionsProtocol_FlexibleEventErr_Result;

class UnknownInteractionsProtocolFlexibleEventErrRequest;

#ifdef __Fuchsia__

class UnknownInteractionsProtocol;
using UnknownInteractionsProtocolHandle = ::fidl::InterfaceHandle<UnknownInteractionsProtocol>;
#endif  // __Fuchsia__

class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse;

class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsClosedProtocol_StrictEventErr_Response;

class UnknownInteractionsClosedProtocol_StrictEventErr_Result;

class UnknownInteractionsClosedProtocolStrictEventErrRequest;

#ifdef __Fuchsia__

class UnknownInteractionsClosedProtocol;
using UnknownInteractionsClosedProtocolHandle = ::fidl::InterfaceHandle<UnknownInteractionsClosedProtocol>;
#endif  // __Fuchsia__

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsAjarProtocol_StrictEventErr_Response;

class UnknownInteractionsAjarProtocol_StrictEventErr_Result;

class UnknownInteractionsAjarProtocolStrictEventErrRequest;

class UnknownInteractionsAjarProtocol_FlexibleEventErr_Response;

class UnknownInteractionsAjarProtocol_FlexibleEventErr_Result;

class UnknownInteractionsAjarProtocolFlexibleEventErrRequest;

#ifdef __Fuchsia__

class UnknownInteractionsAjarProtocol;
using UnknownInteractionsAjarProtocolHandle = ::fidl::InterfaceHandle<UnknownInteractionsAjarProtocol>;
#endif  // __Fuchsia__

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse;

class UnknownInteractionsProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Response>;

class UnknownInteractionsProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsProtocol_StrictTwoWayErr_Result(UnknownInteractionsProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsProtocol_StrictTwoWayErr_Result&&);

  static UnknownInteractionsProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>;

  UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictTwoWayErr_Result>;

class UnknownInteractionsProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictTwoWayErrTopResponse>;

class UnknownInteractionsProtocol_StrictEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_StrictEventErr_Response() = default;
  explicit UnknownInteractionsProtocol_StrictEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_StrictEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_StrictEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Response>;

class UnknownInteractionsProtocol_StrictEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_StrictEventErr_Result();
  ~UnknownInteractionsProtocol_StrictEventErr_Result();

  UnknownInteractionsProtocol_StrictEventErr_Result(UnknownInteractionsProtocol_StrictEventErr_Result&&);
  UnknownInteractionsProtocol_StrictEventErr_Result& operator=(UnknownInteractionsProtocol_StrictEventErr_Result&&);

  static UnknownInteractionsProtocol_StrictEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response&&);
  static UnknownInteractionsProtocol_StrictEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_StrictEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_StrictEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_StrictEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_StrictEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_StrictEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>;

  UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_StrictEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_StrictEventErr_Result>;

class UnknownInteractionsProtocolStrictEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolStrictEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolStrictEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolStrictEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolStrictEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolStrictEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolStrictEventErrRequest>;

class UnknownInteractionsProtocol_FlexibleTwoWay_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleTwoWay_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleTwoWay_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_FlexibleTwoWay_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWay_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWay_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWay_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleTwoWay_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Response>;

class UnknownInteractionsProtocol_FlexibleTwoWay_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWay_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWay_Result();

  UnknownInteractionsProtocol_FlexibleTwoWay_Result(UnknownInteractionsProtocol_FlexibleTwoWay_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWay_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWay_Result&&);

  static UnknownInteractionsProtocol_FlexibleTwoWay_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWay_Result WithTransportErr(::fidl::internal::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,      // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWay_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWay_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWay_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kTransportErr; }

  ::fidl::internal::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kTransportErr);
    return transport_err_;
  }

  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWay_Result& set_transport_err(::fidl::internal::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response response_;
    ::fidl::internal::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWay_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWay_Result>;

class UnknownInteractionsProtocolFlexibleTwoWayTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayTopResponse>;

class UnknownInteractionsProtocol_FlexibleTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_FlexibleTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>;

class UnknownInteractionsProtocol_FlexibleTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result();
  ~UnknownInteractionsProtocol_FlexibleTwoWayErr_Result();

  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(UnknownInteractionsProtocol_FlexibleTwoWayErr_Result&&);
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& operator=(UnknownInteractionsProtocol_FlexibleTwoWayErr_Result&&);

  static UnknownInteractionsProtocol_FlexibleTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayErr_Result WithErr(int32_t&&);
  static UnknownInteractionsProtocol_FlexibleTwoWayErr_Result WithTransportErr(::fidl::internal::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,      // 0x1
    kErr = 2,           // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr; }

  ::fidl::internal::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr);
    return transport_err_;
  }

  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& set_transport_err(::fidl::internal::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>;

  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response response_;
    int32_t err_;
    ::fidl::internal::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>;

class UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>;

class UnknownInteractionsProtocol_FlexibleEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsProtocol_FlexibleEventErr_Response() = default;
  explicit UnknownInteractionsProtocol_FlexibleEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsProtocol_FlexibleEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocol_FlexibleEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Response>;

class UnknownInteractionsProtocol_FlexibleEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsProtocol_FlexibleEventErr_Result();
  ~UnknownInteractionsProtocol_FlexibleEventErr_Result();

  UnknownInteractionsProtocol_FlexibleEventErr_Result(UnknownInteractionsProtocol_FlexibleEventErr_Result&&);
  UnknownInteractionsProtocol_FlexibleEventErr_Result& operator=(UnknownInteractionsProtocol_FlexibleEventErr_Result&&);

  static UnknownInteractionsProtocol_FlexibleEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response&&);
  static UnknownInteractionsProtocol_FlexibleEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsProtocol_FlexibleEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocol_FlexibleEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsProtocol_FlexibleEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsProtocol_FlexibleEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsProtocol_FlexibleEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>;

  UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsProtocol_FlexibleEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsProtocol_FlexibleEventErr_Result>;

class UnknownInteractionsProtocolFlexibleEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsProtocolFlexibleEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsProtocolFlexibleEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsProtocolFlexibleEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsProtocolFlexibleEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsProtocolFlexibleEventErrRequest>;

#ifdef __Fuchsia__

class UnknownInteractionsProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictOneWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleOneWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayErr(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
};

namespace _internal {
__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable;
__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable;
__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable;

__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable;

}  // namespace _internal
class UnknownInteractionsProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWay(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEvent(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEvent(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>;

class UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result&&);

  static UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>;

  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>;

class UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>;

class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response() = default;
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>;

class UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result&&);

  static UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result WithTransportErr(::fidl::internal::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,      // 0x1
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kTransportErr; }

  ::fidl::internal::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kTransportErr);
    return transport_err_;
  }

  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& set_transport_err(::fidl::internal::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>;

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response response_;
    ::fidl::internal::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>;

class UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response() = default;
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>;

class UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result();
  ~UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result();

  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result&&);
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& operator=(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result&&);

  static UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result WithErr(int32_t&&);
  static UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result WithTransportErr(::fidl::internal::TransportErr&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,      // 0x1
    kErr = 2,           // 0x2
    kTransportErr = 3,  // 0x3
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& set_err(int32_t value);

  bool is_transport_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr; }

  ::fidl::internal::TransportErr& transport_err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr);
    return transport_err_;
  }

  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(is_transport_err());
    return transport_err_;
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& set_transport_err(::fidl::internal::TransportErr value);

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>;

  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response response_;
    int32_t err_;
    ::fidl::internal::TransportErr transport_err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>;

class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>;

class UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result&&);

  static UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>;

  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>;

class UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>;

class UnknownInteractionsClosedProtocol_StrictEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedProtocol_StrictEventErr_Response() = default;
  explicit UnknownInteractionsClosedProtocol_StrictEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsClosedProtocol_StrictEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocol_StrictEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Response>;

class UnknownInteractionsClosedProtocol_StrictEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedProtocol_StrictEventErr_Result();
  ~UnknownInteractionsClosedProtocol_StrictEventErr_Result();

  UnknownInteractionsClosedProtocol_StrictEventErr_Result(UnknownInteractionsClosedProtocol_StrictEventErr_Result&&);
  UnknownInteractionsClosedProtocol_StrictEventErr_Result& operator=(UnknownInteractionsClosedProtocol_StrictEventErr_Result&&);

  static UnknownInteractionsClosedProtocol_StrictEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response&&);
  static UnknownInteractionsClosedProtocol_StrictEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedProtocol_StrictEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocol_StrictEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>;

  UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsClosedProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedProtocol_StrictEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocol_StrictEventErr_Result>;

class UnknownInteractionsClosedProtocolStrictEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsClosedProtocolStrictEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedProtocolStrictEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedProtocolStrictEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedProtocolStrictEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsClosedProtocolStrictEventErrRequest>;

#ifdef __Fuchsia__

class UnknownInteractionsClosedProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictOneWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
};

namespace _internal {
__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable;

}  // namespace _internal
class UnknownInteractionsClosedProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEvent(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>;

class UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result&&);

  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>;

  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>;

class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>;

class UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result&&);

  static UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>;

  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>;

class UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>;

class UnknownInteractionsAjarProtocol_StrictEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_StrictEventErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_StrictEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarProtocol_StrictEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_StrictEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Response>;

class UnknownInteractionsAjarProtocol_StrictEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_StrictEventErr_Result();
  ~UnknownInteractionsAjarProtocol_StrictEventErr_Result();

  UnknownInteractionsAjarProtocol_StrictEventErr_Result(UnknownInteractionsAjarProtocol_StrictEventErr_Result&&);
  UnknownInteractionsAjarProtocol_StrictEventErr_Result& operator=(UnknownInteractionsAjarProtocol_StrictEventErr_Result&&);

  static UnknownInteractionsAjarProtocol_StrictEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response&&);
  static UnknownInteractionsAjarProtocol_StrictEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_StrictEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_StrictEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>;

  UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsAjarProtocol_StrictEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_StrictEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_StrictEventErr_Result>;

class UnknownInteractionsAjarProtocolStrictEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolStrictEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolStrictEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolStrictEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolStrictEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolStrictEventErrRequest>;

class UnknownInteractionsAjarProtocol_FlexibleEventErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Response() = default;
  explicit UnknownInteractionsAjarProtocol_FlexibleEventErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarProtocol_FlexibleEventErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>;

class UnknownInteractionsAjarProtocol_FlexibleEventErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result();
  ~UnknownInteractionsAjarProtocol_FlexibleEventErr_Result();

  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(UnknownInteractionsAjarProtocol_FlexibleEventErr_Result&&);
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& operator=(UnknownInteractionsAjarProtocol_FlexibleEventErr_Result&&);

  static UnknownInteractionsAjarProtocol_FlexibleEventErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response&&);
  static UnknownInteractionsAjarProtocol_FlexibleEventErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>;

  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsAjarProtocol_FlexibleEventErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarProtocol_FlexibleEventErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>;

class UnknownInteractionsAjarProtocolFlexibleEventErrRequest final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventErrRequest> New() { return ::std::make_unique<UnknownInteractionsAjarProtocolFlexibleEventErrRequest>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarProtocolFlexibleEventErrRequest* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarProtocolFlexibleEventErrRequest* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarProtocolFlexibleEventErrRequestPtr = ::std::unique_ptr<UnknownInteractionsAjarProtocolFlexibleEventErrRequest>;

#ifdef __Fuchsia__

class UnknownInteractionsAjarProtocol_RequestEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictOneWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleOneWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
};

namespace _internal {
__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable;

__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable;

__LOCAL extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable;

}  // namespace _internal
class UnknownInteractionsAjarProtocol_ResponseEncoder {
 public:
  static ::fidl::HLCPPOutgoingMessage StrictTwoWay(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictTwoWayErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEvent(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage StrictEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEvent(::fidl::MessageEncoder* _encoder) {
    return _encoder->GetMessage();
  }
  static ::fidl::HLCPPOutgoingMessage FlexibleEventErr(::fidl::MessageEncoder* _encoder, ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) {
    fidl_trace(WillHLCPPEncode);

    _encoder->Alloc(16);
    ::fidl::Encode(_encoder, result, 0 + sizeof(fidl_message_header_t));

    fidl_trace(DidHLCPPEncode, &::test::unknowninteractions::_internal::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable, _encoder->GetPtr<const char>(0), _encoder->CurrentLength(), _encoder->CurrentHandleCount());

    return _encoder->GetMessage();
  }
};
#endif  // __Fuchsia__

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response final {
 public:
  static const fidl_type_t* FidlType;
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response() = default;
  explicit UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response(uint8_t v) : __reserved(std::move(v)) {}
  uint8_t ResultValue_() { return std::move(__reserved); }
  explicit UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response(::std::tuple<> _value_tuple) {
  }
  operator ::std::tuple<>() && {
    return std::make_tuple();
  }

  uint8_t __reserved = 0u;

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>;

class UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result final {
 public:
  static const fidl_type_t* FidlType;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result();
  ~UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result();

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result&&);
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& operator=(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result&&);

  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result WithResponse(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response&&);
  static UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result WithErr(int32_t&&);

  enum __attribute__((enum_extensibility(closed))) Tag : fidl_xunion_tag_t {

    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
    Invalid = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>(); }

  void Encode(::fidl::Encoder* encoder, size_t offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* value, size_t offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* result) const;

  bool has_invalid_tag() const {
    return tag_ == Invalid;
  }

  bool is_response() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse; }

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& response() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse);
    return response_;
  }

  const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& response() const {
    ZX_ASSERT(is_response());
    return response_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response value);

  bool is_err() const { return tag_ == ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kErr; }

  int32_t& err() {
    EnsureStorageInitialized(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kErr);
    return err_;
  }

  const int32_t& err() const {
    ZX_ASSERT(is_err());
    return err_;
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& set_err(int32_t value);

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag Which() const {
    return ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag(tag_);
  }

  // You probably want to use Which() method instead of Ordinal(). Use Ordinal() only when you need
  // access to the raw integral ordinal value.
  fidl_xunion_tag_t Ordinal() const {
    return tag_;
  }

  friend ::fidl::Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>;

  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>&& result) {
    ZX_ASSERT(!result.is_pending());
    if (result.is_ok()) {
      set_response(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response{});
    } else {
      set_err(result.take_error());
    }
  }
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::ok_result<void>&& result)
      : UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::error_result<int32_t>&& result)
      : UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result(fpromise::result<void, int32_t>(std::move(result))) {}
  operator fpromise::result<void, int32_t>() && {
    if (is_err()) {
      return fpromise::error(err());
    }
    return fpromise::ok();
  }

 private:
  void Destroy();
  void EnsureStorageInitialized(::fidl_xunion_tag_t tag);

  ::fidl_xunion_tag_t tag_ = static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid);
  union {
    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response response_;
    int32_t err_;
  };
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* result) {
  return value.Clone(result);
}

using UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResultPtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse final {
 public:
  static const fidl_type_t* FidlType;

  ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result result{};

  static inline ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> New() { return ::std::make_unique<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>(); }

  void Encode(::fidl::Encoder* _encoder, size_t _offset,
              cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt);
  static void Decode(::fidl::Decoder* _decoder, UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* value, size_t _offset);
  zx_status_t Clone(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* result) const;
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& _value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* _result) {
  return _value.Clone(_result);
}

using UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponsePtr = ::std::unique_ptr<UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>;

}  // namespace unknowninteractions
}  // namespace test
namespace fidl {
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                   !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response> : public internal::BoolConstant<
                                                                                                                  !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest> : public internal::BoolConstant<
                                                                                                               !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolStrictEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response> : public internal::BoolConstant<
                                                                                                                  !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public internal::BoolConstant<
                                                                                                                   !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                     !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                      !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response> : public internal::BoolConstant<
                                                                                                                    !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest> : public internal::BoolConstant<
                                                                                                                 !HasPadding<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsProtocolFlexibleEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                         !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                          !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_StrictTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> : public internal::BoolConstant<
                                                                                                                        !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public internal::BoolConstant<
                                                                                                                         !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWay_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                           !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);
      case ::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result::Tag::kTransportErr:
        return ::fidl::Equals(_lhs.transport_err_, _rhs.transport_err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                            !HasPadding<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                         !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                          !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response> : public internal::BoolConstant<
                                                                                                                        !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public internal::BoolConstant<
                                                                                                                     !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedProtocolStrictEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                               !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                                !HasPadding<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                       !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                        !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response> : public internal::BoolConstant<
                                                                                                                      !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public internal::BoolConstant<
                                                                                                                   !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolStrictEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> : public internal::BoolConstant<
                                                                                                                        !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public internal::BoolConstant<
                                                                                                                     !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarProtocolFlexibleEventErrRequest& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response, 1> {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> : public internal::BoolConstant<
                                                                                                                             !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response>::value && IsMemcpyCompatible<uint8_t>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Response& _rhs) const {
    if (!::fidl::Equals(_lhs.__reserved, _rhs.__reserved)) {
      return false;
    }
    return true;
  }
};
template <>
struct IsFidlXUnion<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> : public std::true_type {};

template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result, 16> {};

template <>
struct CodingTraits<std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>> {
  static constexpr size_t inline_size_v2 = 16;

  static void Encode(Encoder* encoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset,
                     cpp17::optional<::fidl::HandleInformation> maybe_handle_info = cpp17::nullopt) {
    auto&& p_xunion = *value;
    if (p_xunion) {
      p_xunion->Encode(encoder, offset);
    }
  }

  static void Decode(Decoder* _decoder, std::unique_ptr<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>* value, size_t offset) {
    fidl_xunion_t* encoded = _decoder->GetPtr<fidl_xunion_t>(offset);
    if (encoded->tag == 0) {
      value->reset(nullptr);
      return;
    }

    value->reset(new ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result);

    ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Decode(_decoder, value->get(), offset);
  }
};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result& _rhs) const {
    if (_lhs.Ordinal() != _rhs.Ordinal()) {
      return false;
    }

    switch (_lhs.Ordinal()) {
      case static_cast<fidl_xunion_tag_t>(::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::Invalid):
        return true;
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kResponse:
        return ::fidl::Equals(_lhs.response_, _rhs.response_);
      case ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result::Tag::kErr:
        return ::fidl::Equals(_lhs.err_, _rhs.err_);

      default:
        return false;
    }
  }
};
template <>
struct CodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>
    : public EncodableCodingTraits<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, 16> {};

template <>
struct HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};

template <>
struct IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public internal::BoolConstant<
                                                                                                                              !HasPadding<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>::value && IsMemcpyCompatible<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_Result>::value> {};

inline zx_status_t Clone(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& value,
                         ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* result) {
  return ::test::unknowninteractions::Clone(value, result);
}

template <>
struct Equality<::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> {
  bool operator()(const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& _lhs, const ::test::unknowninteractions::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse& _rhs) const {
    if (!::fidl::Equals(_lhs.result, _rhs.result)) {
      return false;
    }
    return true;
  }
};

//
// Proxies and stubs declarations
//
}  // namespace fidl
namespace test {
namespace unknowninteractions {
#ifdef __Fuchsia__

using UnknownInteractionsProtocolPtr = ::fidl::InterfacePtr<UnknownInteractionsProtocol>;
class UnknownInteractionsProtocol_Proxy;
class UnknownInteractionsProtocol_Stub;
class UnknownInteractionsProtocol_EventSender;
class UnknownInteractionsProtocol_Sync;
using UnknownInteractionsProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<UnknownInteractionsProtocol>;
class UnknownInteractionsProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kUnknownInteractionsProtocol_StrictOneWay_Ordinal = 0x4e7273b964d117a6lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleOneWay_Ordinal = 0x818bb3a7a910446lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWay_Ordinal = 0x734c996b0f37b942lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictTwoWayErr_Ordinal = 0x6d1c6002c51bb967lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWay_Ordinal = 0x4a5bb3397008b7clu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleTwoWayErr_Ordinal = 0x61240f878cc37c07lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEvent_Ordinal = 0x9842669255c4fc1lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_StrictEventErr_Ordinal = 0x3d956048f723bc6dlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_StrictEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEvent_Ordinal = 0x61bb1fab7d767866lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsProtocol_FlexibleEventErr_Ordinal = 0x4bda3e6fb22bb5a9lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsProtocol_FlexibleEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using UnknownInteractionsClosedProtocolPtr = ::fidl::InterfacePtr<UnknownInteractionsClosedProtocol>;
class UnknownInteractionsClosedProtocol_Proxy;
class UnknownInteractionsClosedProtocol_Stub;
class UnknownInteractionsClosedProtocol_EventSender;
class UnknownInteractionsClosedProtocol_Sync;
using UnknownInteractionsClosedProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<UnknownInteractionsClosedProtocol>;
class UnknownInteractionsClosedProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictOneWay_Ordinal = 0x59282385962da24lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWay_Ordinal = 0x5eda305d6b22f1f7lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictTwoWayErr_Ordinal = 0x4fa35d5433db4d3alu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEvent_Ordinal = 0xa8ee6ee302f693blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsClosedProtocol_StrictEventErr_Ordinal = 0x12b105b1430a1201lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsClosedProtocol_StrictEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

using UnknownInteractionsAjarProtocolPtr = ::fidl::InterfacePtr<UnknownInteractionsAjarProtocol>;
class UnknownInteractionsAjarProtocol_Proxy;
class UnknownInteractionsAjarProtocol_Stub;
class UnknownInteractionsAjarProtocol_EventSender;
class UnknownInteractionsAjarProtocol_Sync;
using UnknownInteractionsAjarProtocolSyncPtr = ::fidl::SynchronousInterfacePtr<UnknownInteractionsAjarProtocol>;
class UnknownInteractionsAjarProtocol_SyncProxy;

namespace internal {
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictOneWay_Ordinal = 0xd4663d6b2b5048blu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleOneWay_Ordinal = 0x2275b8171ae4834flu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleOneWay_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWay_Ordinal = 0x50e66d328336038lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWay_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictTwoWayErr_Ordinal = 0x5b47637577c69006lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictTwoWayErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEvent_Ordinal = 0x6022ae999e9dc2b0lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_StrictEventErr_Ordinal = 0x715bfcab27f735edlu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_StrictEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kStrictMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEvent_Ordinal = 0x11c9ba570ce71df3lu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEvent_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
constexpr uint64_t kUnknownInteractionsAjarProtocol_FlexibleEventErr_Ordinal = 0x4fbe0d51e074e5bclu;
constexpr ::fidl::MessageDynamicFlags kUnknownInteractionsAjarProtocol_FlexibleEventErr_DynamicFlags = ::fidl::MessageDynamicFlags::kFlexibleMethod;
}  // namespace internal
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class UnknownInteractionsProtocol {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsProtocol_Proxy;
  using Stub_ = ::test::unknowninteractions::UnknownInteractionsProtocol_Stub;
  using EventSender_ = ::test::unknowninteractions::UnknownInteractionsProtocol_EventSender;
  using Sync_ = ::test::unknowninteractions::UnknownInteractionsProtocol_Sync;
  virtual ~UnknownInteractionsProtocol();

  virtual void StrictOneWay() = 0;

  virtual void FlexibleOneWay() = 0;
  using StrictTwoWayCallback =
      fit::function<void()>;

  virtual void StrictTwoWay(StrictTwoWayCallback callback) = 0;
  using StrictTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result)>;

  virtual void StrictTwoWayErr(StrictTwoWayErrCallback callback) = 0;
  using FlexibleTwoWayCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result)>;

  virtual void FlexibleTwoWay(FlexibleTwoWayCallback callback) = 0;
  using FlexibleTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result)>;

  virtual void FlexibleTwoWayErr(FlexibleTwoWayErrCallback callback) = 0;
  using StrictEventCallback =
      fit::function<void()>;
  using StrictEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result)>;
  using FlexibleEventCallback =
      fit::function<void()>;
  using FlexibleEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result)>;
};

class UnknownInteractionsProtocol_RequestDecoder {
 public:
  UnknownInteractionsProtocol_RequestDecoder() = default;
  virtual ~UnknownInteractionsProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void StrictOneWay() = 0;
  virtual void FlexibleOneWay() = 0;
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayErr() = 0;
  virtual void FlexibleTwoWay() = 0;
  virtual void FlexibleTwoWayErr() = 0;
};

class UnknownInteractionsProtocol_ResponseDecoder {
 public:
  UnknownInteractionsProtocol_ResponseDecoder() = default;
  virtual ~UnknownInteractionsProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result result) = 0;
  virtual void FlexibleTwoWay(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result result) = 0;
  virtual void FlexibleTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result result) = 0;
  virtual void StrictEvent() = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result) = 0;
};

class UnknownInteractionsProtocol_EventSender {
 public:
  virtual ~UnknownInteractionsProtocol_EventSender();
  virtual void StrictEvent() = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result) = 0;
};

class UnknownInteractionsProtocol_Sync {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsProtocol_SyncProxy;
  virtual ~UnknownInteractionsProtocol_Sync();
  virtual zx_status_t StrictOneWay() = 0;
  virtual zx_status_t FlexibleOneWay() = 0;
  virtual zx_status_t StrictTwoWay() = 0;
  virtual zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWay(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* out_result) = 0;
  virtual zx_status_t FlexibleTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* out_result) = 0;
};

class UnknownInteractionsProtocol_Proxy final : public ::fidl::internal::Proxy, public UnknownInteractionsProtocol {
 public:
  explicit UnknownInteractionsProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~UnknownInteractionsProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictOneWay
  void StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleOneWay
  void FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWay
  void StrictTwoWay(StrictTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayErr
  void StrictTwoWayErr(StrictTwoWayErrCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWay
  void FlexibleTwoWay(FlexibleTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayErr
  void FlexibleTwoWayErr(FlexibleTwoWayErrCallback callback) override;
  StrictEventCallback StrictEvent;
  StrictEventErrCallback StrictEventErr;
  FlexibleEventCallback FlexibleEvent;
  FlexibleEventErrCallback FlexibleEventErr;

 private:
  UnknownInteractionsProtocol_Proxy(const ::test::unknowninteractions::UnknownInteractionsProtocol_Proxy&) = delete;
  UnknownInteractionsProtocol_Proxy& operator=(const ::test::unknowninteractions::UnknownInteractionsProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class UnknownInteractionsProtocol_Stub final : public ::fidl::internal::Stub, public ::test::unknowninteractions::UnknownInteractionsProtocol_EventSender {
 public:
  typedef class ::test::unknowninteractions::UnknownInteractionsProtocol UnknownInteractionsProtocol_clazz;
  explicit UnknownInteractionsProtocol_Stub(::test::unknowninteractions::UnknownInteractionsProtocol_Stub::UnknownInteractionsProtocol_clazz* impl);
  ~UnknownInteractionsProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void StrictEvent() override;
  void StrictEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictEventErr_Result result) override;
  void FlexibleEvent() override;
  void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleEventErr_Result result) override;

 private:
  ::test::unknowninteractions::UnknownInteractionsProtocol_Stub::UnknownInteractionsProtocol_clazz* impl_;
};

class UnknownInteractionsProtocol_SyncProxy : public ::test::unknowninteractions::UnknownInteractionsProtocol_Sync {
 public:
  explicit UnknownInteractionsProtocol_SyncProxy(::zx::channel channel);
  ~UnknownInteractionsProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictOneWay
  zx_status_t StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleOneWay
  zx_status_t FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWay
  zx_status_t StrictTwoWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.StrictTwoWayErr
  zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_StrictTwoWayErr_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWay
  zx_status_t FlexibleTwoWay(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWay_Result* out_result) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsProtocol.FlexibleTwoWayErr
  zx_status_t FlexibleTwoWayErr(::test::unknowninteractions::UnknownInteractionsProtocol_FlexibleTwoWayErr_Result* out_result) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<UnknownInteractionsProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class UnknownInteractionsClosedProtocol {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Proxy;
  using Stub_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Stub;
  using EventSender_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_EventSender;
  using Sync_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Sync;
  virtual ~UnknownInteractionsClosedProtocol();

  virtual void StrictOneWay() = 0;
  using StrictTwoWayCallback =
      fit::function<void()>;

  virtual void StrictTwoWay(StrictTwoWayCallback callback) = 0;
  using StrictTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result)>;

  virtual void StrictTwoWayErr(StrictTwoWayErrCallback callback) = 0;
  using StrictEventCallback =
      fit::function<void()>;
  using StrictEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result)>;
};

class UnknownInteractionsClosedProtocol_RequestDecoder {
 public:
  UnknownInteractionsClosedProtocol_RequestDecoder() = default;
  virtual ~UnknownInteractionsClosedProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void StrictOneWay() = 0;
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayErr() = 0;
};

class UnknownInteractionsClosedProtocol_ResponseDecoder {
 public:
  UnknownInteractionsClosedProtocol_ResponseDecoder() = default;
  virtual ~UnknownInteractionsClosedProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result result) = 0;
  virtual void StrictEvent() = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result) = 0;
};

class UnknownInteractionsClosedProtocol_EventSender {
 public:
  virtual ~UnknownInteractionsClosedProtocol_EventSender();
  virtual void StrictEvent() = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result) = 0;
};

class UnknownInteractionsClosedProtocol_Sync {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsClosedProtocol_SyncProxy;
  virtual ~UnknownInteractionsClosedProtocol_Sync();
  virtual zx_status_t StrictOneWay() = 0;
  virtual zx_status_t StrictTwoWay() = 0;
  virtual zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* out_result) = 0;
};

class UnknownInteractionsClosedProtocol_Proxy final : public ::fidl::internal::Proxy, public UnknownInteractionsClosedProtocol {
 public:
  explicit UnknownInteractionsClosedProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~UnknownInteractionsClosedProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictOneWay
  void StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWay
  void StrictTwoWay(StrictTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayErr
  void StrictTwoWayErr(StrictTwoWayErrCallback callback) override;
  StrictEventCallback StrictEvent;
  StrictEventErrCallback StrictEventErr;

 private:
  UnknownInteractionsClosedProtocol_Proxy(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Proxy&) = delete;
  UnknownInteractionsClosedProtocol_Proxy& operator=(const ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class UnknownInteractionsClosedProtocol_Stub final : public ::fidl::internal::Stub, public ::test::unknowninteractions::UnknownInteractionsClosedProtocol_EventSender {
 public:
  typedef class ::test::unknowninteractions::UnknownInteractionsClosedProtocol UnknownInteractionsClosedProtocol_clazz;
  explicit UnknownInteractionsClosedProtocol_Stub(::test::unknowninteractions::UnknownInteractionsClosedProtocol_Stub::UnknownInteractionsClosedProtocol_clazz* impl);
  ~UnknownInteractionsClosedProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void StrictEvent() override;
  void StrictEventErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictEventErr_Result result) override;

 private:
  ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Stub::UnknownInteractionsClosedProtocol_clazz* impl_;
};

class UnknownInteractionsClosedProtocol_SyncProxy : public ::test::unknowninteractions::UnknownInteractionsClosedProtocol_Sync {
 public:
  explicit UnknownInteractionsClosedProtocol_SyncProxy(::zx::channel channel);
  ~UnknownInteractionsClosedProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictOneWay
  zx_status_t StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWay
  zx_status_t StrictTwoWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsClosedProtocol.StrictTwoWayErr
  zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result* out_result) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<UnknownInteractionsClosedProtocol>;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

class UnknownInteractionsAjarProtocol {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Proxy;
  using Stub_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Stub;
  using EventSender_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_EventSender;
  using Sync_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Sync;
  virtual ~UnknownInteractionsAjarProtocol();

  virtual void StrictOneWay() = 0;

  virtual void FlexibleOneWay() = 0;
  using StrictTwoWayCallback =
      fit::function<void()>;

  virtual void StrictTwoWay(StrictTwoWayCallback callback) = 0;
  using StrictTwoWayErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result)>;

  virtual void StrictTwoWayErr(StrictTwoWayErrCallback callback) = 0;
  using StrictEventCallback =
      fit::function<void()>;
  using StrictEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result)>;
  using FlexibleEventCallback =
      fit::function<void()>;
  using FlexibleEventErrCallback =
      fit::function<void(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result)>;
};

class UnknownInteractionsAjarProtocol_RequestDecoder {
 public:
  UnknownInteractionsAjarProtocol_RequestDecoder() = default;
  virtual ~UnknownInteractionsAjarProtocol_RequestDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal, bool* out_needs_response);
  virtual void StrictOneWay() = 0;
  virtual void FlexibleOneWay() = 0;
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayErr() = 0;
};

class UnknownInteractionsAjarProtocol_ResponseDecoder {
 public:
  UnknownInteractionsAjarProtocol_ResponseDecoder() = default;
  virtual ~UnknownInteractionsAjarProtocol_ResponseDecoder() = default;
  static const fidl_type_t* GetType(uint64_t ordinal);
  virtual void StrictTwoWay() = 0;
  virtual void StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result result) = 0;
  virtual void StrictEvent() = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result) = 0;
};

class UnknownInteractionsAjarProtocol_EventSender {
 public:
  virtual ~UnknownInteractionsAjarProtocol_EventSender();
  virtual void StrictEvent() = 0;
  virtual void StrictEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result) = 0;
  virtual void FlexibleEvent() = 0;
  virtual void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result) = 0;
};

class UnknownInteractionsAjarProtocol_Sync {
 public:
  using Proxy_ = ::test::unknowninteractions::UnknownInteractionsAjarProtocol_SyncProxy;
  virtual ~UnknownInteractionsAjarProtocol_Sync();
  virtual zx_status_t StrictOneWay() = 0;
  virtual zx_status_t FlexibleOneWay() = 0;
  virtual zx_status_t StrictTwoWay() = 0;
  virtual zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* out_result) = 0;
};

class UnknownInteractionsAjarProtocol_Proxy final : public ::fidl::internal::Proxy, public UnknownInteractionsAjarProtocol {
 public:
  explicit UnknownInteractionsAjarProtocol_Proxy(::fidl::internal::ProxyController* controller);
  ~UnknownInteractionsAjarProtocol_Proxy() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictOneWay
  void StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.FlexibleOneWay
  void FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWay
  void StrictTwoWay(StrictTwoWayCallback callback) override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayErr
  void StrictTwoWayErr(StrictTwoWayErrCallback callback) override;
  StrictEventCallback StrictEvent;
  StrictEventErrCallback StrictEventErr;
  FlexibleEventCallback FlexibleEvent;
  FlexibleEventErrCallback FlexibleEventErr;

 private:
  UnknownInteractionsAjarProtocol_Proxy(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Proxy&) = delete;
  UnknownInteractionsAjarProtocol_Proxy& operator=(const ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Proxy&) = delete;

  ::fidl::internal::ProxyController* controller_;
};

class UnknownInteractionsAjarProtocol_Stub final : public ::fidl::internal::Stub, public ::test::unknowninteractions::UnknownInteractionsAjarProtocol_EventSender {
 public:
  typedef class ::test::unknowninteractions::UnknownInteractionsAjarProtocol UnknownInteractionsAjarProtocol_clazz;
  explicit UnknownInteractionsAjarProtocol_Stub(::test::unknowninteractions::UnknownInteractionsAjarProtocol_Stub::UnknownInteractionsAjarProtocol_clazz* impl);
  ~UnknownInteractionsAjarProtocol_Stub() override;

  zx_status_t Dispatch_(::fidl::HLCPPIncomingMessage message,
                        ::fidl::internal::PendingResponse response) override;
  void StrictEvent() override;
  void StrictEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictEventErr_Result result) override;
  void FlexibleEvent() override;
  void FlexibleEventErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_FlexibleEventErr_Result result) override;

 private:
  ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Stub::UnknownInteractionsAjarProtocol_clazz* impl_;
};

class UnknownInteractionsAjarProtocol_SyncProxy : public ::test::unknowninteractions::UnknownInteractionsAjarProtocol_Sync {
 public:
  explicit UnknownInteractionsAjarProtocol_SyncProxy(::zx::channel channel);
  ~UnknownInteractionsAjarProtocol_SyncProxy() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictOneWay
  zx_status_t StrictOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.FlexibleOneWay
  zx_status_t FlexibleOneWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWay
  zx_status_t StrictTwoWay() override;
  // cts-coverage-fidl-name:test.unknowninteractions/UnknownInteractionsAjarProtocol.StrictTwoWayErr
  zx_status_t StrictTwoWayErr(::test::unknowninteractions::UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result* out_result) override;

 private:
  ::fidl::internal::SynchronousProxy proxy_;
  friend class ::fidl::SynchronousInterfacePtr<UnknownInteractionsAjarProtocol>;
};
#endif  // __Fuchsia__

}  // namespace unknowninteractions
}  // namespace test
