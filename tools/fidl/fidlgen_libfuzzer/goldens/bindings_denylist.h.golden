// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <test/bindingsdenylist/cpp/fidl.h>
#include <test/dependent/cpp/libfuzzer.h>

#include "lib/fidl/cpp/fuzzing/traits.h"
#include "lib/fidl/cpp/internal/header.h"
// For ::std::max_element().
#include <algorithm>
// For uint64_t.
#include <stdint.h>

namespace fuzzing {

using ShouldNeverAppearInAnyBinding9 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding9;
using ShouldNeverAppearInAnyBinding8 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding8;
using ShouldNeverAppearInAnyBinding7 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding7;
using ShouldNeverAppearInAnyBinding6 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding6;
using ShouldNeverAppearInAnyBinding5 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding5;
using ShouldNeverAppearInAnyBinding4 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding4;
using Allowed_Denied_Response =
    ::test::bindingsdenylist::Allowed_Denied_Response;
using Allowed_Denied_Result = ::test::bindingsdenylist::Allowed_Denied_Result;
using ShouldNeverAppearInAnyBinding3 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding3;
using ShouldNeverAppearInAnyBinding2 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding2;
using ShouldNeverAppearInAnyBinding1 =
    ::test::bindingsdenylist::ShouldNeverAppearInAnyBinding1;
using MemberOnlyAppearsInImportingLibrary =
    ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary;
using OnlyAppearsInImportingLibrary =
    ::test::bindingsdenylist::OnlyAppearsInImportingLibrary;
using DenyEachBinding_OnlyDenySyzkaller_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Response;
using DenyEachBinding_OnlyDenySyzkaller_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenySyzkaller_Result;
using DenyEachBinding_OnlyDenyRust_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response;
using DenyEachBinding_OnlyDenyRust_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Result;
using DenyEachBinding_OnlyDenyLibfuzzer_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Response;
using DenyEachBinding_OnlyDenyLibfuzzer_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyLibfuzzer_Result;
using DenyEachBinding_OnlyDenyGo_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response;
using DenyEachBinding_OnlyDenyGo_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Result;
using DenyEachBinding_OnlyDenyDart_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response;
using DenyEachBinding_OnlyDenyDart_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Result;
using DenyEachBinding_OnlyDenyCpp_Response =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyCpp_Response;
using DenyEachBinding_OnlyDenyCpp_Result =
    ::test::bindingsdenylist::DenyEachBinding_OnlyDenyCpp_Result;

template <>
struct MinSize<ShouldNeverAppearInAnyBinding9> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<bool>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding9> {
  static_assert(1 > 0, "xunion must have at least one member");

  ShouldNeverAppearInAnyBinding9 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding9>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ShouldNeverAppearInAnyBinding9 out;
    switch (selector % 1) {
      case 0: {
        out.set_a(Allocate<bool>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding8> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding8> {
  ShouldNeverAppearInAnyBinding8 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding8>());
    ShouldNeverAppearInAnyBinding8 out;
    const size_t slack_per_member =
        (*size - MinSize<ShouldNeverAppearInAnyBinding8>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.set_a(Allocate<bool>{}(src, &out_size));
    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding7> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding7> {
  ShouldNeverAppearInAnyBinding7 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding7>());
    ShouldNeverAppearInAnyBinding7 out;
    const size_t slack_per_member =
        (*size - MinSize<ShouldNeverAppearInAnyBinding7>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding6> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<bool>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding6> {
  static_assert(1 > 0, "xunion must have at least one member");

  ShouldNeverAppearInAnyBinding6 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding6>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ShouldNeverAppearInAnyBinding6 out;
    switch (selector % 1) {
      case 0: {
        out.set_a(Allocate<bool>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding5> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding5> {
  ShouldNeverAppearInAnyBinding5 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding5>());
    ShouldNeverAppearInAnyBinding5 out;
    const size_t slack_per_member =
        (*size - MinSize<ShouldNeverAppearInAnyBinding5>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.set_a(Allocate<bool>{}(src, &out_size));
    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding4> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding4> {
  ShouldNeverAppearInAnyBinding4 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding4>());
    ShouldNeverAppearInAnyBinding4 out;
    const size_t slack_per_member =
        (*size - MinSize<ShouldNeverAppearInAnyBinding4>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Allowed_Denied_Response> {
  operator size_t() {
    return MinSize<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding4>() +
           MinSize<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding5>() +
           MinSize<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding6>();
  }
};
template <>
struct Allocate<Allowed_Denied_Response> {
  Allowed_Denied_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Allowed_Denied_Response>());
    Allowed_Denied_Response out;
    const size_t slack_per_member =
        (*size - MinSize<Allowed_Denied_Response>()) / 3;
    size_t out_size;
    out_size =
        MinSize<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding4>() +
        slack_per_member;
    out.should_never_appear_in_any_binding_4 =
        Allocate<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding4>{}(
            src, &out_size);
    out_size =
        MinSize<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding5>() +
        slack_per_member;
    out.should_never_appear_in_any_binding_5 =
        Allocate<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding5>{}(
            src, &out_size);
    out_size =
        MinSize<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding6>() +
        slack_per_member;
    out.should_never_appear_in_any_binding_6 =
        Allocate<::test::bindingsdenylist::ShouldNeverAppearInAnyBinding6>{}(
            src, &out_size);
    return out;
  }
};
template <>
struct MinSize<Allowed_Denied_Result> {
  operator size_t() {
    size_t sizes[] = {
        0, MinSize<::test::bindingsdenylist::Allowed_Denied_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<Allowed_Denied_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  Allowed_Denied_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<Allowed_Denied_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    Allowed_Denied_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::Allowed_Denied_Response>{}(
                src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding3> {
  operator size_t() {
    size_t sizes[] = {0, MinSize<bool>()};
    return 1 + *std::max_element(sizes, sizes + 1 + 1);
  }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding3> {
  static_assert(1 > 0, "xunion must have at least one member");

  ShouldNeverAppearInAnyBinding3 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding3>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    ShouldNeverAppearInAnyBinding3 out;
    switch (selector % 1) {
      case 0: {
        out.set_a(Allocate<bool>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding2> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding2> {
  ShouldNeverAppearInAnyBinding2 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding2>());
    ShouldNeverAppearInAnyBinding2 out;
    const size_t slack_per_member =
        (*size - MinSize<ShouldNeverAppearInAnyBinding2>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.set_a(Allocate<bool>{}(src, &out_size));
    return out;
  }
};
template <>
struct MinSize<ShouldNeverAppearInAnyBinding1> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<ShouldNeverAppearInAnyBinding1> {
  ShouldNeverAppearInAnyBinding1 operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<ShouldNeverAppearInAnyBinding1>());
    ShouldNeverAppearInAnyBinding1 out;
    const size_t slack_per_member =
        (*size - MinSize<ShouldNeverAppearInAnyBinding1>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<MemberOnlyAppearsInImportingLibrary> {
  operator size_t() { return MinSize<bool>(); }
};
template <>
struct Allocate<MemberOnlyAppearsInImportingLibrary> {
  MemberOnlyAppearsInImportingLibrary operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<MemberOnlyAppearsInImportingLibrary>());
    MemberOnlyAppearsInImportingLibrary out;
    const size_t slack_per_member =
        (*size - MinSize<MemberOnlyAppearsInImportingLibrary>()) / 1;
    size_t out_size;
    out_size = MinSize<bool>() + slack_per_member;
    out.a = Allocate<bool>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<OnlyAppearsInImportingLibrary> {
  operator size_t() {
    return MinSize<
        ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>();
  }
};
template <>
struct Allocate<OnlyAppearsInImportingLibrary> {
  OnlyAppearsInImportingLibrary operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<OnlyAppearsInImportingLibrary>());
    OnlyAppearsInImportingLibrary out;
    const size_t slack_per_member =
        (*size - MinSize<OnlyAppearsInImportingLibrary>()) / 1;
    size_t out_size;
    out_size =
        MinSize<
            ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>() +
        slack_per_member;
    out.member_only_appears_in_importing_library = Allocate<
        ::test::bindingsdenylist::MemberOnlyAppearsInImportingLibrary>{}(
        src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenySyzkaller_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenySyzkaller_Response> {
  DenyEachBinding_OnlyDenySyzkaller_Response operator()(FuzzInput* src,
                                                        size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenySyzkaller_Response>());
    DenyEachBinding_OnlyDenySyzkaller_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenySyzkaller_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenySyzkaller_Result> {
  operator size_t() {
    size_t sizes[] = {0,
                      MinSize<::test::bindingsdenylist::
                                  DenyEachBinding_OnlyDenySyzkaller_Response>(),
                      MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenySyzkaller_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenySyzkaller_Result operator()(FuzzInput* src,
                                                      size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenySyzkaller_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenySyzkaller_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenySyzkaller_Response>{}(src,
                                                                       size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyRust_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyRust_Response> {
  DenyEachBinding_OnlyDenyRust_Response operator()(FuzzInput* src,
                                                   size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyRust_Response>());
    DenyEachBinding_OnlyDenyRust_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyRust_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyRust_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyRust_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyRust_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyRust_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyRust_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyRust_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyRust_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyLibfuzzer_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyLibfuzzer_Response> {
  DenyEachBinding_OnlyDenyLibfuzzer_Response operator()(FuzzInput* src,
                                                        size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyLibfuzzer_Response>());
    DenyEachBinding_OnlyDenyLibfuzzer_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyLibfuzzer_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyLibfuzzer_Result> {
  operator size_t() {
    size_t sizes[] = {0,
                      MinSize<::test::bindingsdenylist::
                                  DenyEachBinding_OnlyDenyLibfuzzer_Response>(),
                      MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyLibfuzzer_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyLibfuzzer_Result operator()(FuzzInput* src,
                                                      size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyLibfuzzer_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyLibfuzzer_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyLibfuzzer_Response>{}(src,
                                                                       size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyGo_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyGo_Response> {
  DenyEachBinding_OnlyDenyGo_Response operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyGo_Response>());
    DenyEachBinding_OnlyDenyGo_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyGo_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyGo_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyGo_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyGo_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyGo_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyGo_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyGo_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyGo_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyDart_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyDart_Response> {
  DenyEachBinding_OnlyDenyDart_Response operator()(FuzzInput* src,
                                                   size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyDart_Response>());
    DenyEachBinding_OnlyDenyDart_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyDart_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyDart_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyDart_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyDart_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyDart_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyDart_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyDart_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyDart_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyCpp_Response> {
  operator size_t() { return MinSize<int32_t>(); }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyCpp_Response> {
  DenyEachBinding_OnlyDenyCpp_Response operator()(FuzzInput* src,
                                                  size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyCpp_Response>());
    DenyEachBinding_OnlyDenyCpp_Response out;
    const size_t slack_per_member =
        (*size - MinSize<DenyEachBinding_OnlyDenyCpp_Response>()) / 1;
    size_t out_size;
    out_size = MinSize<int32_t>() + slack_per_member;
    out.b = Allocate<int32_t>{}(src, &out_size);
    return out;
  }
};
template <>
struct MinSize<DenyEachBinding_OnlyDenyCpp_Result> {
  operator size_t() {
    size_t sizes[] = {
        0,
        MinSize<
            ::test::bindingsdenylist::DenyEachBinding_OnlyDenyCpp_Response>(),
        MinSize<uint32_t>()};
    return 1 + *std::max_element(sizes, sizes + 2 + 1);
  }
};
template <>
struct Allocate<DenyEachBinding_OnlyDenyCpp_Result> {
  static_assert(2 > 0, "xunion must have at least one member");

  DenyEachBinding_OnlyDenyCpp_Result operator()(FuzzInput* src, size_t* size) {
    ZX_ASSERT(*size >= MinSize<DenyEachBinding_OnlyDenyCpp_Result>());

    uint8_t selector;
    ZX_ASSERT(src->CopyBytes(&selector, 1));
    (*size)++;

    DenyEachBinding_OnlyDenyCpp_Result out;
    switch (selector % 2) {
      case 0: {
        out.set_response(
            Allocate<::test::bindingsdenylist::
                         DenyEachBinding_OnlyDenyCpp_Response>{}(src, size));
        break;
      }
      case 1: {
        out.set_err(Allocate<uint32_t>{}(src, size));
        break;
      }
    }

    return out;
  }
};

}  // namespace fuzzing
