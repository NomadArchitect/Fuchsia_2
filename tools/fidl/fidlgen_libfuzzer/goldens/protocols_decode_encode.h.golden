// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test/protocols/llcpp/fidl.h>

// For ::fidl::fuzzing::DecoderEncoder.
#include <lib/fidl/cpp/fuzzing/decoder_encoder.h>
// For ::std::array.
#include <array>
// For ::std::pair.
#include <utility>
// For uint*_t.
#include <stdint.h>
// For ZX_ERR_INTERNAL.
#include <zircon/errors.h>
// For zx_handle_info_t and zx_status_t.
#include <zircon/types.h>
// For fidl_outgoing_msg_t.
#include <zircon/fidl.h>

namespace fuzzing {

inline constexpr ::std::array<::fidl::fuzzing::DecoderEncoder, 33>
    fidl_test_protocols_decoder_encoders = {
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          ::fidl_test_protocols::wire::
              WithErrorSyntax_ResponseAsStruct_Response::DecodedMessage decoded(
                  bytes, num_bytes);  // decoder_encoder.

          if (decoded.status() != ZX_OK) {
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              ZX_ERR_INTERNAL);
          }

          ::fidl_test_protocols::wire::
              WithErrorSyntax_ResponseAsStruct_Response* value =
                  decoded.PrimaryObject();
          ::fidl_test_protocols::wire::
              WithErrorSyntax_ResponseAsStruct_Response::OwnedEncodedMessage
                  encoded(value);

          if (encoded.status() != ZX_OK) {
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }

          [[maybe_unused]] fidl_outgoing_msg_t* message =
              encoded.GetOutgoingMessage().message();
          // TODO: Verify re-encoded message matches initial message.
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            encoded.status());
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          ::fidl_test_protocols::wire::
              WithErrorSyntax_ErrorAsPrimitive_Response::DecodedMessage decoded(
                  bytes, num_bytes);  // decoder_encoder.

          if (decoded.status() != ZX_OK) {
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              ZX_ERR_INTERNAL);
          }

          ::fidl_test_protocols::wire::
              WithErrorSyntax_ErrorAsPrimitive_Response* value =
                  decoded.PrimaryObject();
          ::fidl_test_protocols::wire::
              WithErrorSyntax_ErrorAsPrimitive_Response::OwnedEncodedMessage
                  encoded(value);

          if (encoded.status() != ZX_OK) {
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }

          [[maybe_unused]] fidl_outgoing_msg_t* message =
              encoded.GetOutgoingMessage().message();
          // TODO: Verify re-encoded message matches initial message.
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            encoded.status());
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          ::fidl_test_protocols::wire::WithErrorSyntax_ErrorAsEnum_Response::
              DecodedMessage decoded(bytes, num_bytes);  // decoder_encoder.

          if (decoded.status() != ZX_OK) {
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              ZX_ERR_INTERNAL);
          }

          ::fidl_test_protocols::wire::WithErrorSyntax_ErrorAsEnum_Response*
              value = decoded.PrimaryObject();
          ::fidl_test_protocols::wire::WithErrorSyntax_ErrorAsEnum_Response::
              OwnedEncodedMessage encoded(value);

          if (encoded.status() != ZX_OK) {
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }

          [[maybe_unused]] fidl_outgoing_msg_t* message =
              encoded.GetOutgoingMessage().message();
          // TODO: Verify re-encoded message matches initial message.
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            encoded.status());
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::Transitional::RequestRequest::DecodedMessage
              decoded(bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::Transitional::RequestRequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::Transitional::RequestRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::Transitional::RequestResponse::DecodedMessage
              decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::Transitional::RequestResponse* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::Transitional::RequestResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::Transitional::OneWayRequest::DecodedMessage
              decoded(bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::Transitional::OneWayRequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::Transitional::OneWayRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::Transitional::EventResponse::DecodedMessage
              decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::Transitional::EventResponse* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::Transitional::EventResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::ChannelProtocol::MethodARequest::DecodedMessage
              decoded(bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::MethodARequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::MethodARequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::ChannelProtocol::EventAResponse::DecodedMessage
              decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::EventAResponse* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::EventAResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::ChannelProtocol::MethodBRequest::DecodedMessage
              decoded(bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::MethodBRequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::MethodBRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::ChannelProtocol::MethodBResponse::
              DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::MethodBResponse* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::MethodBResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::ChannelProtocol::TakeHandleRequest::
              DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::TakeHandleRequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::TakeHandleRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::ChannelProtocol::TakeHandleResponse::
              DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::TakeHandleResponse* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::TakeHandleResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::ChannelProtocol::MutateSocketRequest::
              DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::MutateSocketRequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::MutateSocketRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::ChannelProtocol::MutateSocketResponse::
              DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::ChannelProtocol::MutateSocketResponse*
                value = decoded.PrimaryObject();
            ::fidl_test_protocols::ChannelProtocol::MutateSocketResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestNoResponseRequest::DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestNoResponseRequest* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestNoResponseRequest::OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponseRequest::DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponseRequest* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponseRequest::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponseResponse::DecodedMessage decoded(bytes,
                                                                     num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponseResponse* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponseResponse::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponseRequest::DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponseRequest* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponseRequest::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponseResponse::DecodedMessage decoded(bytes,
                                                                    num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponseResponse* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponseResponse::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponseRequest::DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestNoResponseRequest* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestNoResponseRequest::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponseRequest::DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponseRequest* value =
                    decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponseRequest::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponseResponse::DecodedMessage decoded(
                  bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponseResponse* value =
                    decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponseResponse::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponseRequest::DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponseRequest* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponseRequest::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponseResponse::DecodedMessage decoded(
                  bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponseResponse* value =
                    decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponseResponse::OwnedEncodedMessage encoded(
                    value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnEmptyResponseResponse::DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnEmptyResponseResponse* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnEmptyResponseResponse::OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnWithResponseResponse::DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnWithResponseResponse* value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnWithResponseResponse::OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStructRequest::
              DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStructRequest*
                value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStructRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStructResponse::
              DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStructResponse*
                value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStructResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitiveRequest::
              DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitiveRequest*
                value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitiveRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitiveResponse::
              DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitiveResponse*
                value = decoded.PrimaryObject();
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitiveResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol request.
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnumRequest::
              DecodedMessage decoded(
                  bytes, num_bytes);  // protocol_decoder_encoder (1).
          if (decoded.status()) {
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnumRequest* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnumRequest::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
        [](uint8_t* bytes, uint32_t num_bytes, zx_handle_info_t* handles,
           uint32_t num_handles) -> ::std::pair<zx_status_t, zx_status_t> {
          // Decode/re-encode protocol response.
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnumResponse::
              DecodedMessage decoded(bytes, num_bytes);
          if (decoded.status()) {
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnumResponse* value =
                decoded.PrimaryObject();
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnumResponse::
                OwnedEncodedMessage encoded(value);
            if (!encoded.status()) {
              return ::std::make_pair<zx_status_t, zx_status_t>(
                  decoded.status(), encoded.status());
            }
            [[maybe_unused]] fidl_outgoing_msg_t* message =
                encoded.GetOutgoingMessage().message();
            // TODO: Verify re-encoded message matches initial message.
            return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                              encoded.status());
          }
          return ::std::make_pair<zx_status_t, zx_status_t>(decoded.status(),
                                                            ZX_ERR_INTERNAL);
        },
};

}  // namespace fuzzing
