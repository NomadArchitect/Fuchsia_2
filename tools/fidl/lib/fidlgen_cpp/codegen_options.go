// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

package fidlgen_cpp

import (
	"flag"
	"log"
	"os"
	"strings"

	"go.fuchsia.dev/fuchsia/tools/fidl/lib/fidlgen"
)

type experiments []string

func (e *experiments) String() string {
	return strings.Join(*e, ", ")
}

func (e *experiments) Set(value string) error {
	*e = append(*e, value)
	return nil
}

// CmdlineFlags are the common command-line flags for all C++ backends.
type CmdlineFlags struct {
	// Flags

	// json is the path to the JSON IR.
	json string
	// root is the directory that bindings will be generated under.
	root string
	// clangFormatPath is the path to the clang-format binary.
	clangFormatPath string
	// Experiments is a list of experiments that are enabled.
	experiments experiments
	// legacy holds the legacy command-line flags.
	legacy *legacyCmdlineFlags

	// Configuration

	// Name is the name of the bindings being generated.
	name string
	// validExperiments is the list of supported experiments in this generator
	validExperiments []string
}

type legacyCmdlineFlags struct {
	Header      string
	Source      string
	TestBase    string
	IncludeBase string
	IncludeStem string
	OutputBase  string
	Generators  string
}

// NewCmdlineFlags returns a new instance of CmdlineFlags, which holds the
// values for flags passed on the command-line to a C++ generating fidlgen.
// |name| is the name of the binding used in @bindings_denylist and elsewhere.
// |validExperiments| is a list of experiment names that are supported.
// |legacy| enables support for deprecated, old-style fidlgen flags.
func NewCmdlineFlags(name string, validExperiments []string, legacy bool) *CmdlineFlags {
	flags := CmdlineFlags{name: name, validExperiments: validExperiments}
	flag.StringVar(&flags.json, "json", "",
		"path to the FIDL intermediate representation.")
	flag.StringVar(&flags.root, "root", "",
		"where to generate the bindings.")
	flag.StringVar(&flags.clangFormatPath, "clang-format-path", "",
		"path to the clang-format tool.")
	if len(validExperiments) > 0 {
		flag.Var(&flags.experiments, "experiment",
			"turn on an experiment, one of: "+strings.Join(validExperiments, ", "))
	}

	if legacy {
		flags.legacy = &legacyCmdlineFlags{}
		flag.StringVar(&flags.legacy.Header, "header", "",
			"DEPRECATED: the output path for the generated header. "+
				"It cannot be supplied together with --output-base.")
		flag.StringVar(&flags.legacy.Source, "source", "",
			"DEPRECATED: the output path for the generated C++ implementation. "+
				"It cannot be supplied together with --output-base.")
		flag.StringVar(&flags.legacy.TestBase, "test-base", "",
			"DEPRECATED: the output path for the generated test base header. "+
				"It cannot be supplied together with --output-base.")
		flag.StringVar(&flags.legacy.IncludeBase, "include-base", "",
			"DEPRECATED: the directory to which C and C++ includes should be relative.")
		flag.StringVar(&flags.legacy.IncludeStem, "include-stem", "",
			"DEPRECATED: [optional] the suffix after library path when referencing includes. "+
				"Includes will be of the form <my/library/{include-stem}.h>. ")
		flag.StringVar(&flags.legacy.OutputBase, "output-base", "",
			"DEPRECATED: the base file name for files generated by this generator. "+
				"It cannot be supplied together with header/source/test-base.")
		flag.StringVar(&flags.legacy.Generators, "generators", "", "unused")
	}

	return &flags
}

func (c *CmdlineFlags) ParseAndLoadIR() Root {
	flag.Parse()
	if !flag.Parsed() {
		flag.PrintDefaults()
		os.Exit(1)
	}

	// Check that --json is specified.
	if c.json == "" {
		log.Fatal("Missing required flag: --json")
	}

	// Read in JSON IR.
	// We need to do this to determine the FIDL library that we're generating.
	ir, err := fidlgen.ReadJSONIr(c.json)
	if err != nil {
		log.Fatalf("Failed to read JSON IR from %s: %v", c.json, err)
	}

	// Check that all Experiments are in validExperiments.
	// These are always going to be small lists so linear searches are fine.
	for _, e := range c.experiments {
		valid := false
		for _, v := range c.validExperiments {
			if e == v {
				valid = true
				break
			}
		}
		if !valid {
			log.Fatalf("Invalid experiment %s. Must be one of %s", e,
				strings.Join(c.validExperiments, ", "))
		}
	}

	if c.legacy != nil {
		if c.legacy.OutputBase != "" {
			if c.root != "" || c.legacy.Header != "" || c.legacy.Source != "" || c.legacy.TestBase != "" {
				log.Fatal("Can't use --output-base with --root, --header, --source or --test-base")
			}
			c.legacy.Header = c.legacy.OutputBase + ".h"
			c.legacy.Source = c.legacy.OutputBase + ".cc"
			c.legacy.TestBase = c.legacy.OutputBase + "_test_base.h"
		}

		if c.legacy.Header != "" || c.legacy.Source != "" || c.legacy.TestBase != "" ||
			c.legacy.IncludeBase != "" || c.legacy.IncludeStem != "" {
			if c.root != "" && c.legacy.OutputBase == "" {
				log.Fatal("Can't use ---header, --source, --test-base, --include-base or --include-stem with --root")
			}
			if c.legacy.IncludeBase == "" {
				log.Fatal("If --root is missing, --include-base must be supplied")
			}
			if c.legacy.IncludeStem == "" {
				// The default for HLCPP which is all that's supported in the SDK
				c.legacy.IncludeStem = "cpp/fidl"
			}

			// Validate that the legacy arguments fit a supported pattern.
			base := c.legacy.IncludeBase
			for _, l := range ir.Name.Parts() {
				base = base + "/" + string(l)
			}
			base = base + "/" + c.legacy.IncludeStem

			if c.legacy.Header != base+".h" {
				log.Fatalf("header is %v, expected \"%s.h\"",
					c.legacy.Header, base)
			}
			if c.legacy.Source != base+".cc" {
				log.Fatalf("source is %v, expected \"%s.cc\"",
					c.legacy.Source, base)
			}
			if c.legacy.TestBase != "" {
				if c.legacy.TestBase != base+"_test_base.h" {
					log.Fatalf("test-base is %v, expected \"%s_test_base.h\"",
						c.legacy.TestBase, base)
				}
			}

			// Populate the new flags from the legacy flags.
			c.root = c.legacy.IncludeBase
		}
	}

	// Check that --root is specified.
	if c.root == "" {
		log.Fatal("Missing required flag: --root")
	}

	return compileFor(ir, c.name)
}

func (c *CmdlineFlags) ExperimentEnabled(experiment string) bool {
	for _, e := range c.experiments {
		if e == experiment {
			return true
		}
	}
	return false
}
