// WARNING: This file is machine generated by fidlgen_cpp.

#pragma once

#include <fidl/test.anonymous/cpp/wire.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/codable_base.h>
#include <lib/fidl/cpp/internal/message_extensions.h>
#include <lib/fidl/cpp/internal/natural_client_messenger.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>
#include <test/anonymous/cpp/natural_types.h>

namespace test_anonymous {
class TableData;

class SomeProtocolSomeMethodRequest;

class OverrideTest;

class SomeProtocol_SomeMethod_Response;

class SomeProtocolSomeMethodTopResponse;

using UnionMember = ::test::anonymous::UnionMember;

using TableMember = ::test::anonymous::TableMember;

using SomeProtocol_SomeMethod_Error =
    ::test::anonymous::SomeProtocol_SomeMethod_Error;

using Op = ::test::anonymous::Op;

using Flags = ::test::anonymous::Flags;

using FunctionApplication = ::test::anonymous::FunctionApplication;

using Expression = ::test::anonymous::Expression;

using BitsMember = ::test::anonymous::BitsMember;

using SomeProtocol_SomeMethod_Result =
    ::test::anonymous::SomeProtocol_SomeMethod_Result;

}  // namespace test_anonymous
template <>
struct ::fidl::internal::DesignatedInitializationProxy<
    ::test_anonymous::TableData>
    final {
 public:
  uint8_t data = {};
};

namespace test_anonymous {
class TableData final : public ::fidl::internal::CodableBase<TableData> {
 private:
  friend ::fidl::internal::CodableBase<TableData>;
  TableData(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  TableData() = default;
  TableData(uint8_t data) : storage_({data}) {}
  TableData(::fidl::internal::DesignatedInitializationProxy<
            ::test_anonymous::TableData>
                storage)
      : storage_(std::move(storage)) {}
  ~TableData() = default;
  TableData(TableData&&) noexcept = default;
  TableData& operator=(TableData&&) noexcept = default;

  const uint8_t& data() const { return storage_.data; }

  uint8_t& data() { return storage_.data; }

  TableData& set_data(uint8_t _value) {
    storage_.data = std::move(_value);
    return *this;
  }

 private:
  friend struct ::fidl::CodingTraits<::test_anonymous::TableData>;

  ::fidl::internal::DesignatedInitializationProxy<::test_anonymous::TableData>
      storage_ = {};
};

}  // namespace test_anonymous
template <>
struct ::fidl::internal::DesignatedInitializationProxy<
    ::test_anonymous::SomeProtocolSomeMethodRequest>
    final {
 public:
  ::test_anonymous::UnionMember union_member = {};

  ::test_anonymous::TableMember table_member = {};
};

namespace test_anonymous {
class SomeProtocolSomeMethodRequest final
    : public ::fidl::internal::CodableBase<SomeProtocolSomeMethodRequest> {
 private:
  friend ::fidl::internal::CodableBase<SomeProtocolSomeMethodRequest>;
  SomeProtocolSomeMethodRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  SomeProtocolSomeMethodRequest() = default;
  SomeProtocolSomeMethodRequest(::test_anonymous::UnionMember union_member,
                                ::test_anonymous::TableMember table_member)
      : storage_({std::move(union_member), std::move(table_member)}) {}
  SomeProtocolSomeMethodRequest(::fidl::internal::DesignatedInitializationProxy<
                                ::test_anonymous::SomeProtocolSomeMethodRequest>
                                    storage)
      : storage_(std::move(storage)) {}
  ~SomeProtocolSomeMethodRequest() = default;
  SomeProtocolSomeMethodRequest(SomeProtocolSomeMethodRequest&&) noexcept =
      default;
  SomeProtocolSomeMethodRequest& operator=(
      SomeProtocolSomeMethodRequest&&) noexcept = default;

  const ::test_anonymous::UnionMember& union_member() const {
    return storage_.union_member;
  }

  ::test_anonymous::UnionMember& union_member() {
    return storage_.union_member;
  }

  SomeProtocolSomeMethodRequest& set_union_member(
      ::test_anonymous::UnionMember _value) {
    storage_.union_member = std::move(_value);
    return *this;
  }

  const ::test_anonymous::TableMember& table_member() const {
    return storage_.table_member;
  }

  ::test_anonymous::TableMember& table_member() {
    return storage_.table_member;
  }

  SomeProtocolSomeMethodRequest& set_table_member(
      ::test_anonymous::TableMember _value) {
    storage_.table_member = std::move(_value);
    return *this;
  }

 private:
  friend struct ::fidl::CodingTraits<
      ::test_anonymous::SomeProtocolSomeMethodRequest>;

  ::fidl::internal::DesignatedInitializationProxy<
      ::test_anonymous::SomeProtocolSomeMethodRequest>
      storage_ = {};
};

}  // namespace test_anonymous
template <>
struct ::fidl::internal::DesignatedInitializationProxy<
    ::test_anonymous::OverrideTest>
    final {
 public:
  ::test_anonymous::Op op = {};

  ::std::unique_ptr<::test_anonymous::Expression> left = {};

  ::std::unique_ptr<::test_anonymous::Expression> right = {};
};

namespace test_anonymous {
class OverrideTest final : public ::fidl::internal::CodableBase<OverrideTest> {
 private:
  friend ::fidl::internal::CodableBase<OverrideTest>;
  OverrideTest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  OverrideTest() = default;
  OverrideTest(::test_anonymous::Op op,
               ::std::unique_ptr<::test_anonymous::Expression> left,
               ::std::unique_ptr<::test_anonymous::Expression> right)
      : storage_({op, std::move(left), std::move(right)}) {}
  OverrideTest(::fidl::internal::DesignatedInitializationProxy<
               ::test_anonymous::OverrideTest>
                   storage)
      : storage_(std::move(storage)) {}
  ~OverrideTest() = default;
  OverrideTest(OverrideTest&&) noexcept = default;
  OverrideTest& operator=(OverrideTest&&) noexcept = default;

  const ::test_anonymous::Op& op() const { return storage_.op; }

  ::test_anonymous::Op& op() { return storage_.op; }

  OverrideTest& set_op(::test_anonymous::Op _value) {
    storage_.op = std::move(_value);
    return *this;
  }

  const ::std::unique_ptr<::test_anonymous::Expression>& left() const {
    return storage_.left;
  }

  ::std::unique_ptr<::test_anonymous::Expression>& left() {
    return storage_.left;
  }

  OverrideTest& set_left(
      ::std::unique_ptr<::test_anonymous::Expression> _value) {
    storage_.left = std::move(_value);
    return *this;
  }

  const ::std::unique_ptr<::test_anonymous::Expression>& right() const {
    return storage_.right;
  }

  ::std::unique_ptr<::test_anonymous::Expression>& right() {
    return storage_.right;
  }

  OverrideTest& set_right(
      ::std::unique_ptr<::test_anonymous::Expression> _value) {
    storage_.right = std::move(_value);
    return *this;
  }

 private:
  friend struct ::fidl::CodingTraits<::test_anonymous::OverrideTest>;

  ::fidl::internal::DesignatedInitializationProxy<
      ::test_anonymous::OverrideTest>
      storage_ = {};
};

}  // namespace test_anonymous
template <>
struct ::fidl::internal::DesignatedInitializationProxy<
    ::test_anonymous::SomeProtocol_SomeMethod_Response>
    final {
 public:
  ::test_anonymous::BitsMember bits_member = {};
};

namespace test_anonymous {
class SomeProtocol_SomeMethod_Response final
    : public ::fidl::internal::CodableBase<SomeProtocol_SomeMethod_Response> {
 private:
  friend ::fidl::internal::CodableBase<SomeProtocol_SomeMethod_Response>;
  SomeProtocol_SomeMethod_Response(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  SomeProtocol_SomeMethod_Response() = default;
  SomeProtocol_SomeMethod_Response(::test_anonymous::BitsMember bits_member)
      : storage_({bits_member}) {}
  SomeProtocol_SomeMethod_Response(
      ::fidl::internal::DesignatedInitializationProxy<
          ::test_anonymous::SomeProtocol_SomeMethod_Response>
          storage)
      : storage_(std::move(storage)) {}
  ~SomeProtocol_SomeMethod_Response() = default;
  SomeProtocol_SomeMethod_Response(
      SomeProtocol_SomeMethod_Response&&) noexcept = default;
  SomeProtocol_SomeMethod_Response& operator=(
      SomeProtocol_SomeMethod_Response&&) noexcept = default;

  const ::test_anonymous::BitsMember& bits_member() const {
    return storage_.bits_member;
  }

  ::test_anonymous::BitsMember& bits_member() { return storage_.bits_member; }

  SomeProtocol_SomeMethod_Response& set_bits_member(
      ::test_anonymous::BitsMember _value) {
    storage_.bits_member = std::move(_value);
    return *this;
  }

 private:
  friend struct ::fidl::CodingTraits<
      ::test_anonymous::SomeProtocol_SomeMethod_Response>;

  ::fidl::internal::DesignatedInitializationProxy<
      ::test_anonymous::SomeProtocol_SomeMethod_Response>
      storage_ = {};
};

}  // namespace test_anonymous
template <>
struct ::fidl::internal::DesignatedInitializationProxy<
    ::test_anonymous::SomeProtocolSomeMethodTopResponse>
    final {
 public:
  ::test_anonymous::SomeProtocol_SomeMethod_Result result = {};
};

namespace test_anonymous {
class SomeProtocolSomeMethodTopResponse final
    : public ::fidl::internal::CodableBase<SomeProtocolSomeMethodTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<SomeProtocolSomeMethodTopResponse>;
  SomeProtocolSomeMethodTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  SomeProtocolSomeMethodTopResponse() = default;
  SomeProtocolSomeMethodTopResponse(
      ::test_anonymous::SomeProtocol_SomeMethod_Result result)
      : storage_({std::move(result)}) {}
  SomeProtocolSomeMethodTopResponse(
      ::fidl::internal::DesignatedInitializationProxy<
          ::test_anonymous::SomeProtocolSomeMethodTopResponse>
          storage)
      : storage_(std::move(storage)) {}
  ~SomeProtocolSomeMethodTopResponse() = default;
  SomeProtocolSomeMethodTopResponse(
      SomeProtocolSomeMethodTopResponse&&) noexcept = default;
  SomeProtocolSomeMethodTopResponse& operator=(
      SomeProtocolSomeMethodTopResponse&&) noexcept = default;

  const ::test_anonymous::SomeProtocol_SomeMethod_Result& result() const {
    return storage_.result;
  }

  ::test_anonymous::SomeProtocol_SomeMethod_Result& result() {
    return storage_.result;
  }

  SomeProtocolSomeMethodTopResponse& set_result(
      ::test_anonymous::SomeProtocol_SomeMethod_Result _value) {
    storage_.result = std::move(_value);
    return *this;
  }

 private:
  friend struct ::fidl::CodingTraits<
      ::test_anonymous::SomeProtocolSomeMethodTopResponse>;

  ::fidl::internal::DesignatedInitializationProxy<
      ::test_anonymous::SomeProtocolSomeMethodTopResponse>
      storage_ = {};
};

}  // namespace test_anonymous
namespace fidl {
#ifdef __Fuchsia__
extern "C" const fidl_type_t test_anonymous_TableDataTable;

template <>
struct IsFidlType<::test_anonymous::TableData> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_anonymous::TableData> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_TableDataTable;
};

template <>
struct CodingTraits<::test_anonymous::TableData> {
  static constexpr size_t inline_size_v1_no_ee = 1;
  static constexpr size_t inline_size_v2 = 1;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::TableData* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.data, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_anonymous::TableData* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.data, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_anonymous_SomeProtocolSomeMethodRequestTable;

template <>
struct IsFidlType<::test_anonymous::SomeProtocolSomeMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_anonymous::SomeProtocolSomeMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_SomeProtocolSomeMethodRequestTable;
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocolSomeMethodRequest> {
  static constexpr size_t inline_size_v1_no_ee = 40;
  static constexpr size_t inline_size_v2 = 32;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocolSomeMethodRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.union_member,
                   offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 24
                                                                           : 16;
    ::fidl::Encode(encoder, &value->storage_.table_member,
                   offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocolSomeMethodRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.union_member, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.table_member, offset + 16);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_anonymous_OverrideTestTable;

template <>
struct IsFidlType<::test_anonymous::OverrideTest> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_anonymous::OverrideTest> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_OverrideTestTable;
};

template <>
struct CodingTraits<::test_anonymous::OverrideTest> {
  static constexpr size_t inline_size_v1_no_ee = 56;
  static constexpr size_t inline_size_v2 = 40;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::OverrideTest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.op, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.left, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 32
                                                                           : 24;
    ::fidl::Encode(encoder, &value->storage_.right, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::OverrideTest* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.op, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.left, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.right, offset + 24);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_anonymous_SomeProtocol_SomeMethod_ResponseTable;

template <>
struct IsFidlType<::test_anonymous::SomeProtocol_SomeMethod_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_anonymous::SomeProtocol_SomeMethod_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_SomeProtocol_SomeMethod_ResponseTable;
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocol_SomeMethod_Response> {
  static constexpr size_t inline_size_v1_no_ee = 4;
  static constexpr size_t inline_size_v2 = 4;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocol_SomeMethod_Response* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.bits_member,
                   offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocol_SomeMethod_Response* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.bits_member, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_anonymous_SomeProtocolSomeMethodTopResponseTable;

template <>
struct IsFidlType<::test_anonymous::SomeProtocolSomeMethodTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_anonymous::SomeProtocolSomeMethodTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_SomeProtocolSomeMethodTopResponseTable;
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocolSomeMethodTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocolSomeMethodTopResponse* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocolSomeMethodTopResponse* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl

template <>
class ::fidl::Response<::test_anonymous::SomeProtocol::SomeMethod> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_anonymous::SomeProtocol::SomeMethod>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_anonymous::SomeProtocolSomeMethodTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_anonymous::SomeProtocolSomeMethodTopResponse* operator->() {
    return &payload_;
  }
  const ::test_anonymous::SomeProtocolSomeMethodTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_anonymous::SomeProtocolSomeMethodTopResponse& operator*() {
    return payload_;
  }
  const ::test_anonymous::SomeProtocolSomeMethodTopResponse& operator*() const {
    return payload_;
  }

 private:
  ::test_anonymous::SomeProtocolSomeMethodTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_anonymous::SomeProtocol::SomeMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_anonymous::SomeProtocolSomeMethodTopResponse;
};
namespace fidl {}  // namespace fidl
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_anonymous::SomeProtocol::SomeMethod>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_anonymous::SomeProtocol::SomeMethod>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_anonymous::SomeProtocol::SomeMethod>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_anonymous::SomeProtocol> final
    : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void SomeMethod(
      ::test_anonymous::SomeProtocolSomeMethodRequest&& payload,
      ::fidl::ClientCallback<::test_anonymous::SomeProtocol::SomeMethod>&&
          _callback) const;

  void SomeMethod(
      ::test_anonymous::SomeProtocolSomeMethodRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_anonymous::SomeProtocol::SomeMethod>&& _callback) const;
};
namespace fidl {
#endif  // __Fuchsia__

}  // namespace fidl
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_anonymous::SomeProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_anonymous::SomeProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_anonymous::SomeProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_anonymous::SomeProtocol>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_anonymous::SomeProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_anonymous::SomeProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__
