// WARNING: This file is machine generated by fidlgen_cpp.

#pragma once

#include <fidl/test.protocols/cpp/natural_types.h>
#include <fidl/test.protocols/cpp/wire.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/codable_base.h>
#include <lib/fidl/cpp/internal/message_extensions.h>
#include <lib/fidl/cpp/internal/natural_client_messenger.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>

namespace fidl {

#ifdef __Fuchsia__
}  // namespace fidl

template <>
class ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::HandleRightsProtocolAnEventRequest payload)
      : payload_(std::move(payload)) {}
  Event(const Event&) noexcept = delete;
  Event& operator=(const Event&) noexcept = delete;
  ::test_protocols::HandleRightsProtocolAnEventRequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::HandleRightsProtocolAnEventRequest* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::HandleRightsProtocolAnEventRequest& operator*() {
    return payload_;
  }
  const ::test_protocols::HandleRightsProtocolAnEventRequest& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::HandleRightsProtocolAnEventRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolAnEventRequest;
};
namespace fidl {}  // namespace fidl

template <>
class ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::HandleRightsProtocol::ResponseMethod>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::HandleRightsProtocolResponseMethodTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::HandleRightsProtocolResponseMethodTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::HandleRightsProtocolResponseMethodTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::HandleRightsProtocolResponseMethodTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::HandleRightsProtocolResponseMethodTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse;
};
namespace fidl {}  // namespace fidl
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::HandleRightsProtocol::
                                          ResponseMethod>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ResponseMethod(
      ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
      ::fidl::ClientCallback<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
      const;

  void ResponseMethod(
      ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
      const;

  ::fitx::result<::fidl::Error> NoResponseMethod(
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest&& payload)
      const;
};
namespace fidl {
#endif  // __Fuchsia__

}  // namespace fidl
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::HandleRightsProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void AnEvent(
      ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::HandleRightsProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};

template <>
class ::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final
    : public ::fidl::internal::MessageBase<::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest&
  operator*() {
    return payload_;
  }
  const ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse*
      operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
      operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&)>;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::
               WithAndWithoutRequestResponseWithRequestWithResponseTopResponse
                   payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse*
      operator->() {
    return &payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse*
      operator->() const {
    return &payload_;
  }
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
      operator*() {
    return payload_;
  }
  const ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
      operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void NoRequestEmptyResponse(
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestEmptyResponse>&& _callback) const;

  void NoRequestEmptyResponse(::fidl::ClientResponseCallback<
                              ::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>&& _callback) const;

  void NoRequestWithResponse(
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>&& _callback) const;

  void NoRequestWithResponse(::fidl::ClientResponseCallback<
                             ::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>&& _callback) const;

  void WithRequestEmptyResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
              payload,
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestEmptyResponse>&& _callback) const;

  void WithRequestEmptyResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
              payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>&& _callback) const;

  void WithRequestWithResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>&& _callback) const;

  void WithRequestWithResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>&& _callback) const;

  ::fitx::result<::fidl::Error> NoRequestNoResponse() const;

  ::fitx::result<::fidl::Error> WithRequestNoResponse(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest&& payload)
      const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnEmptyResponse(
      ::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>&) {}
  virtual void OnWithResponse(
      ::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithAndWithoutRequestResponse>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<
                    ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<
          ::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Event<::test_protocols::Transitional::Event> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocols::Transitional::Event>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::TransitionalEventRequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::TransitionalEventRequest* operator->() { return &payload_; }
  const ::test_protocols::TransitionalEventRequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::TransitionalEventRequest& operator*() { return payload_; }
  const ::test_protocols::TransitionalEventRequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::TransitionalEventRequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::Transitional::Event>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalEventRequest;
};

template <>
class ::fidl::Response<::test_protocols::Transitional::Request> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::Transitional::Request>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::TransitionalRequestTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::TransitionalRequestTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::TransitionalRequestTopResponse* operator->() const {
    return &payload_;
  }
  ::test_protocols::TransitionalRequestTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::TransitionalRequestTopResponse& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::TransitionalRequestTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::Transitional::Request>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::Transitional::Request>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::Transitional::Request>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::Transitional::Request>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::Transitional> final
    : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void Request(::test_protocols::TransitionalRequestRequest&& payload,
               ::fidl::ClientCallback<::test_protocols::Transitional::Request>&&
                   _callback) const;

  void Request(
      ::test_protocols::TransitionalRequestRequest&& payload,
      ::fidl::ClientResponseCallback<::test_protocols::Transitional::Request>&&
          _callback) const;

  ::fitx::result<::fidl::Error> OneWay(
      ::test_protocols::TransitionalOneWayRequest&& payload) const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::Transitional> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void Event(::fidl::Event<::test_protocols::Transitional::Event>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::Transitional>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::Transitional>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::Transitional>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> UnionMethod(
      ::test_protocols::MethodWithUnionUnionMethodRequest&& payload) const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::MethodWithUnion> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::MethodWithUnion>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithProtocolEndsClientEndsTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithProtocolEndsClientEndsTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsClientEndsTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsClientEndsTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsClientEndsTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsClientEndsTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithProtocolEndsServerEndsTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithProtocolEndsServerEndsTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsServerEndsTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsServerEndsTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsServerEndsTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsServerEndsTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::WithProtocolEnds::StructContainingEnds>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse*
  operator->() {
    return &payload_;
  }
  const ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse&
  operator*() {
    return payload_;
  }
  const ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::WithProtocolEnds::
                                          StructContainingEnds>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ClientEnds(
      ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
          _callback) const;

  void ClientEnds(
      ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithProtocolEnds::ClientEnds>&& _callback) const;

  void ServerEnds(
      ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
          _callback) const;

  void ServerEnds(
      ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithProtocolEnds::ServerEnds>&& _callback) const;

  void StructContainingEnds(
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
      ::fidl::ClientCallback<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&& _callback)
      const;

  void StructContainingEnds(
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&& _callback)
      const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithProtocolEnds> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithProtocolEnds>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> Fifteen(
      ::test_protocols::ManyParametersFifteenRequest&& payload) const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::ManyParameters> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::ManyParameters>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ManyParameters>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxResponseAsStructTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::WithErrorSyntax::
                                          ResponseAsStruct>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::internal::MessageBase<::fidl::Response<
                ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse*
  operator->() const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse&
  operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<::test_protocols::WithErrorSyntax::
                                          ErrorAsPrimitive>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>&)>;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::WithErrorSyntaxHandleInResultTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::WithErrorSyntaxHandleInResultTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::WithErrorSyntaxHandleInResultTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::WithErrorSyntaxHandleInResultTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::WithErrorSyntaxHandleInResultTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::WithErrorSyntaxHandleInResultTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<::fidl::Error,
                     ::fidl::Response<
                         ::test_protocols::WithErrorSyntax::HandleInResult>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ResponseAsStruct(::fidl::ClientCallback<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                            _callback) const;

  void ResponseAsStruct(::fidl::ClientResponseCallback<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                            _callback) const;

  void ErrorAsPrimitive(::fidl::ClientCallback<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                            _callback) const;

  void ErrorAsPrimitive(::fidl::ClientResponseCallback<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                            _callback) const;

  void ErrorAsEnum(
      ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
          _callback) const;

  void ErrorAsEnum(
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>&& _callback) const;

  void HandleInResult(
      ::fidl::ClientCallback<
          ::test_protocols::WithErrorSyntax::HandleInResult>&& _callback) const;

  void HandleInResult(
      ::fidl::ClientResponseCallback<
          ::test_protocols::WithErrorSyntax::HandleInResult>&& _callback) const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithErrorSyntax> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithErrorSyntax>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> Method() const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::DiscoverableProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::DiscoverableProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Event<::test_protocols::ChannelProtocol::EventA> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Event<::test_protocols::ChannelProtocol::EventA>> {
 public:
  Event() = default;
  ~Event() = default;
  Event(Event&&) noexcept = default;
  Event& operator=(Event&&) noexcept = default;
  Event(::test_protocols::ChannelProtocolEventARequest payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ChannelProtocolEventARequest* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolEventARequest* operator->() const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolEventARequest& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolEventARequest& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolEventARequest payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolEventARequest;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MethodB> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::ChannelProtocolMethodBTopResponse payload)
      : payload_(std::move(payload)) {}
  ::test_protocols::ChannelProtocolMethodBTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMethodBTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMethodBTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMethodBTopResponse& operator*() const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMethodBTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::ChannelProtocol::MethodB>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>&)>;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;

 private:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::ChannelProtocol::TakeHandle>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>&)>;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::fidl::internal::MessageBase<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>> {
 public:
  Response() = default;
  ~Response() = default;
  Response(Response&&) noexcept = default;
  Response& operator=(Response&&) noexcept = default;
  Response(::test_protocols::ChannelProtocolMutateSocketTopResponse payload)
      : payload_(std::move(payload)) {}
  Response(const Response&) noexcept = delete;
  Response& operator=(const Response&) noexcept = delete;
  ::test_protocols::ChannelProtocolMutateSocketTopResponse* operator->() {
    return &payload_;
  }
  const ::test_protocols::ChannelProtocolMutateSocketTopResponse* operator->()
      const {
    return &payload_;
  }
  ::test_protocols::ChannelProtocolMutateSocketTopResponse& operator*() {
    return payload_;
  }
  const ::test_protocols::ChannelProtocolMutateSocketTopResponse& operator*()
      const {
    return payload_;
  }

 private:
  ::test_protocols::ChannelProtocolMutateSocketTopResponse payload_;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketTopResponse;
};
template <>
class ::fidl::internal::ClientCallbackTraits<
    ::test_protocols::ChannelProtocol::MutateSocket>
    final {
 public:
  ClientCallbackTraits() = delete;
  using ResultCallback = ::fit::callback<void(
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>>&)>;
  using ResponseCallback = ::fit::callback<void(
      ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>&)>;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void MethodB(
      ::test_protocols::ChannelProtocolMethodBRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
          _callback) const;

  void MethodB(
      ::test_protocols::ChannelProtocolMethodBRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::ChannelProtocol::MethodB>&& _callback) const;

  void TakeHandle(
      ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
          _callback) const;

  void TakeHandle(
      ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::ChannelProtocol::TakeHandle>&& _callback) const;

  void MutateSocket(
      ::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MutateSocket>&&
          _callback) const;

  void MutateSocket(
      ::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
      ::fidl::ClientResponseCallback<
          ::test_protocols::ChannelProtocol::MutateSocket>&& _callback) const;

  ::fitx::result<::fidl::Error> MethodA(
      ::test_protocols::ChannelProtocolMethodARequest&& payload) const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::ChannelProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void EventA(
      ::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::ChannelProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__
