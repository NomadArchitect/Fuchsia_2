// WARNING: This file is machine generated by fidlgen_cpp.

#include <test/protocols/cpp/fidl_v2.h>

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
        ::fidl::ClientCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>,
          ::fidl::ClientCallback<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_HandleRightsProtocolResponseMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(
        ::test_protocols::HandleRightsProtocolNoResponseMethodRequest&& payload)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded =
              ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->AnEvent(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestEmptyResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(::fidl::ClientResponseCallback<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(::fidl::ClientResponseCallback<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
                payload,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestEmptyResponse>&& _callback)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
                payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest&&
                payload,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest&&
                payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse()
    const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestNoResponseRequest&& payload)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded = ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::
                  OnEmptyResponse>::DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnEmptyResponse(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded = ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnWithResponse(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;
[[maybe_unused]] constexpr inline uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;
[[maybe_unused]] constexpr inline uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::test_protocols::TransitionalRequestRequest&& payload,
    ::fidl::ClientCallback<::test_protocols::Transitional::Request>&& _callback)
    const {
  ::fidl::Encoder _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_TransitionalRequestRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::Transitional::Request>,
          ::fidl::ClientCallback<::test_protocols::Transitional::Request>>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::test_protocols::TransitionalRequestRequest&& payload,
    ::fidl::ClientResponseCallback<::test_protocols::Transitional::Request>&&
        _callback) const {
  ::fidl::Encoder _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::test_protocols_TransitionalRequestRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::Transitional::Request>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::Transitional::Request>>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::OneWay(
    ::test_protocols::TransitionalOneWayRequest&& payload) const {
  ::fidl::Encoder _encoder{::test_protocols::kTransitional_OneWay_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::test_protocols_TransitionalOneWayRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fitx::result<::fidl::Error,
                     ::fidl::Event<::test_protocols::Transitional::Event>>
          decoded = ::fidl::Event<::test_protocols::Transitional::Event>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->Event(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::test_protocols::MethodWithUnionUnionMethodRequest&& payload) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_MethodWithUnionUnionMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsClientEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::ClientEnds>>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::ClientEnds>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsClientEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::ClientEnds>>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsServerEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::ServerEnds>>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::ServerEnds>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsServerEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::ServerEnds>>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
        ::fidl::ClientCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithProtocolEndsStructContainingEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>::Fifteen(
    ::test_protocols::ManyParametersFifteenRequest&& payload) const {
  ::fidl::Encoder _encoder{::test_protocols::kManyParameters_Fifteen_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_ManyParametersFifteenRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxResponseAsStructRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientResponseCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxResponseAsStructRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientResponseCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsEnumRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxErrorAsEnumRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxHandleInResultRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::HandleInResult>>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientResponseCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_WithErrorSyntaxHandleInResultRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::HandleInResult>>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kDiscoverableProtocol_Method_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_DiscoverableProtocolMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;
[[maybe_unused]] constexpr inline uint64_t
    kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::test_protocols::ChannelProtocolMethodBRequest&& payload,
            ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
                _callback) const {
  ::fidl::Encoder _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_ChannelProtocolMethodBRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>,
          ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::test_protocols::ChannelProtocolMethodBRequest&& payload,
            ::fidl::ClientResponseCallback<
                ::test_protocols::ChannelProtocol::MethodB>&& _callback) const {
  ::fidl::Encoder _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_ChannelProtocolMethodBRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::MethodB>>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_ChannelProtocolTakeHandleRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>,
          ::fidl::ClientCallback<
              ::test_protocols::ChannelProtocol::TakeHandle>>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::ChannelProtocol::TakeHandle>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_ChannelProtocolTakeHandleRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::TakeHandle>>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
                 ::fidl::ClientCallback<
                     ::test_protocols::ChannelProtocol::MutateSocket>&&
                     _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_ChannelProtocolMutateSocketRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>,
          ::fidl::ClientCallback<
              ::test_protocols::ChannelProtocol::MutateSocket>>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
                 ::fidl::ClientResponseCallback<
                     ::test_protocols::ChannelProtocol::MutateSocket>&&
                     _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      &::test_protocols::
          test_protocols_ChannelProtocolMutateSocketRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::MutateSocket>>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::MethodA(
    ::test_protocols::ChannelProtocolMethodARequest&& payload) const {
  ::fidl::Encoder _encoder{::test_protocols::kChannelProtocol_MethodA_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test_protocols::
          test_protocols_ChannelProtocolMethodARequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fitx::result<::fidl::Error,
                     ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>
          decoded = ::fidl::Event<::test_protocols::ChannelProtocol::EventA>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->EventA(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__
