// WARNING: This file is machine generated by fidlgen_cpp.

#include <test/protocols/cpp/fidl_v2.h>

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_HandleInResult_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_HandleInResult_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_HandleInResult_Response>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntax_HandleInResult_Response::
    WithErrorSyntax_HandleInResult_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::handle>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxHandleInResultTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxHandleInResultTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntaxHandleInResultTopResponse::
    WithErrorSyntaxHandleInResultTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_HandleInResult_Result>(&decoder,
                                                                   0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolResponseMethodTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolResponseMethodTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::HandleRightsProtocolResponseMethodTopResponse::
    HandleRightsProtocolResponseMethodTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolResponseMethodRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolResponseMethodRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolResponseMethodRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::HandleRightsProtocolResponseMethodRequest::
    HandleRightsProtocolResponseMethodRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolNoResponseMethodRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolNoResponseMethodRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::HandleRightsProtocolNoResponseMethodRequest::
    HandleRightsProtocolNoResponseMethodRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolAnEventRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolAnEventRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolAnEventRequest>::Encode(&encoder,
                                                                    this,
                                                                    offset);
}

::test_protocols::HandleRightsProtocolAnEventRequest::
    HandleRightsProtocolAnEventRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolTakeHandleRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolTakeHandleRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolTakeHandleRequest>::Encode(&encoder,
                                                                  this, offset);
}

::test_protocols::ChannelProtocolTakeHandleRequest::
    ChannelProtocolTakeHandleRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::handle>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMutateSocketTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::ChannelProtocolMutateSocketTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolMutateSocketTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::ChannelProtocolMutateSocketTopResponse::
    ChannelProtocolMutateSocketTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMutateSocketRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::ChannelProtocolMutateSocketRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolMutateSocketRequest>::Encode(&encoder,
                                                                    this,
                                                                    offset);
}

::test_protocols::ChannelProtocolMutateSocketRequest::
    ChannelProtocolMutateSocketRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsServerEndsTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithProtocolEndsServerEndsTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsServerEndsTopResponse>::Encode(&encoder,
                                                                       this,
                                                                       offset);
}

::test_protocols::WithProtocolEndsServerEndsTopResponse::
    WithProtocolEndsServerEndsTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>(
          &decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsServerEndsRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithProtocolEndsServerEndsRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsServerEndsRequest>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::WithProtocolEndsServerEndsRequest::
    WithProtocolEndsServerEndsRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::InterfaceRequest<::test::protocols::DiscoverableProtocol>>(
          &decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsClientEndsTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithProtocolEndsClientEndsTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsClientEndsTopResponse>::Encode(&encoder,
                                                                       this,
                                                                       offset);
}

::test_protocols::WithProtocolEndsClientEndsTopResponse::
    WithProtocolEndsClientEndsTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>(
          &decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsClientEndsRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithProtocolEndsClientEndsRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsClientEndsRequest>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::WithProtocolEndsClientEndsRequest::
    WithProtocolEndsClientEndsRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::InterfaceHandle<::test::protocols::DiscoverableProtocol>>(
          &decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntax_ResponseAsStruct_Response::
    WithErrorSyntax_ResponseAsStruct_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8),
                ::fidl::DecodeAs<int64_t>(&decoder, 16)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntaxResponseAsStructTopResponse::
    WithErrorSyntaxResponseAsStructTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response::
    WithErrorSyntax_ErrorAsPrimitive_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<uint8_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse::
    WithErrorSyntaxErrorAsPrimitiveTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>::Encode(&encoder,
                                                                      this,
                                                                      offset);
}

::test_protocols::WithErrorSyntax_ErrorAsEnum_Response::
    WithErrorSyntax_ErrorAsEnum_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<uint8_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseRequest::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::
                    WithAndWithoutRequestResponseWithRequestWithResponseRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest::
    WithAndWithoutRequestResponseWithRequestWithResponseRequest(
        ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestNoResponseRequest::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::
                    WithAndWithoutRequestResponseWithRequestNoResponseRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest::
    WithAndWithoutRequestResponseWithRequestNoResponseRequest(
        ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
        ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::
    WithAndWithoutRequestResponseOnWithResponseRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::
              WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::
    WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::TransitionalRequestTopResponse::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::TransitionalRequestTopResponse, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::TransitionalRequestTopResponse>::Encode(&encoder, this,
                                                                offset);
}

::test_protocols::TransitionalRequestTopResponse::
    TransitionalRequestTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::TransitionalRequestRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::TransitionalRequestRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::TransitionalRequestRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::TransitionalRequestRequest::TransitionalRequestRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::TransitionalOneWayRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::TransitionalOneWayRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::TransitionalOneWayRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::TransitionalOneWayRequest::TransitionalOneWayRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::TransitionalEventRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::TransitionalEventRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::TransitionalEventRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::TransitionalEventRequest::TransitionalEventRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::MethodWithUnionUnionMethodRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::MethodWithUnionUnionMethodRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::MethodWithUnionUnionMethodRequest>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::MethodWithUnionUnionMethodRequest::
    MethodWithUnionUnionMethodRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::test_protocols::TheUnion>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::SyscallProtocolMethodCRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::SyscallProtocolMethodCRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<::test_protocols::SyscallProtocolMethodCRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::SyscallProtocolMethodCRequest::SyscallProtocolMethodCRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ProtocolEnds::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<::test_protocols::ProtocolEnds,
                                           ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::ProtocolEnds>::Encode(&encoder, this,
                                                               offset);
}

::test_protocols::ProtocolEnds::ProtocolEnds(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::fidl::InterfaceHandle<
                    ::test::protocols::DiscoverableProtocol>>(&decoder, 0),
                ::fidl::DecodeAs<::fidl::InterfaceRequest<
                    ::test::protocols::DiscoverableProtocol>>(&decoder, 4),
                ::fidl::DecodeAs<::fidl::InterfaceHandle<
                    ::test::protocols::DiscoverableProtocol>>(&decoder, 8),
                ::fidl::DecodeAs<::fidl::InterfaceRequest<
                    ::test::protocols::DiscoverableProtocol>>(&decoder, 12)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithProtocolEndsStructContainingEndsTopResponse::
    WithProtocolEndsStructContainingEndsTopResponse(::fidl::Decoder& decoder)
    : storage_(
          {::fidl::DecodeAs<::test_protocols::ProtocolEnds>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsStructContainingEndsRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithProtocolEndsStructContainingEndsRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithProtocolEndsStructContainingEndsRequest::
    WithProtocolEndsStructContainingEndsRequest(::fidl::Decoder& decoder)
    : storage_(
          {::fidl::DecodeAs<::test_protocols::ProtocolEnds>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ManyParametersFifteenRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::ManyParametersFifteenRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::ManyParametersFifteenRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ManyParametersFifteenRequest::ManyParametersFifteenRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<bool>(&decoder, 0),
                ::fidl::DecodeAs<bool>(&decoder, 1),
                ::fidl::DecodeAs<bool>(&decoder, 2),
                ::fidl::DecodeAs<bool>(&decoder, 3),
                ::fidl::DecodeAs<bool>(&decoder, 4),
                ::fidl::DecodeAs<bool>(&decoder, 5),
                ::fidl::DecodeAs<bool>(&decoder, 6),
                ::fidl::DecodeAs<bool>(&decoder, 7),
                ::fidl::DecodeAs<bool>(&decoder, 8),
                ::fidl::DecodeAs<bool>(&decoder, 9),
                ::fidl::DecodeAs<bool>(&decoder, 10),
                ::fidl::DecodeAs<bool>(&decoder, 11),
                ::fidl::DecodeAs<bool>(&decoder, 12),
                ::fidl::DecodeAs<bool>(&decoder, 13),
                ::fidl::DecodeAs<bool>(&decoder, 14)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>::Encode(&encoder,
                                                                       this,
                                                                       offset);
}

::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse::
    WithErrorSyntaxErrorAsEnumTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>(&decoder, 0)}) {
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMethodBTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolMethodBTopResponse, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolMethodBTopResponse>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::ChannelProtocolMethodBTopResponse::
    ChannelProtocolMethodBTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMethodBRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolMethodBRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<::test_protocols::ChannelProtocolMethodBRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ChannelProtocolMethodBRequest::ChannelProtocolMethodBRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMethodARequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolMethodARequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<::test_protocols::ChannelProtocolMethodARequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ChannelProtocolMethodARequest::ChannelProtocolMethodARequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolEventARequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::ChannelProtocolEventARequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::ChannelProtocolEventARequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ChannelProtocolEventARequest::ChannelProtocolEventARequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
        ::fidl::ClientCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>,
          ::fidl::ClientCallback<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::test_protocols::HandleRightsProtocolResponseMethodRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolResponseMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(
        ::test_protocols::HandleRightsProtocolNoResponseMethodRequest&& payload)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_HandleRightsProtocolNoResponseMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded =
              ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>::
                  DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->AnEvent(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestEmptyResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(::fidl::ClientResponseCallback<
                           ::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestEmptyResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(::fidl::ClientResponseCallback<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
                payload,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestEmptyResponse>&& _callback)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&
                payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestEmptyResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest&&
                payload,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
          ::fidl::ClientCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest&&
                payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse()
    const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestNoResponseRequest&& payload)
        const {
  ::fidl::Encoder _encoder{
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded = ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::
                  OnEmptyResponse>::DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnEmptyResponse(decoded.value());
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fitx::result<
          ::fidl::Error,
          ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded = ::fidl::Event<
              ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->OnWithResponse(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;
[[maybe_unused]] constexpr inline uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;
[[maybe_unused]] constexpr inline uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::test_protocols::TransitionalRequestRequest&& payload,
    ::fidl::ClientCallback<::test_protocols::Transitional::Request>&& _callback)
    const {
  ::fidl::Encoder _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_TransitionalRequestRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::Transitional::Request>,
          ::fidl::ClientCallback<::test_protocols::Transitional::Request>>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::test_protocols::TransitionalRequestRequest&& payload,
    ::fidl::ClientResponseCallback<::test_protocols::Transitional::Request>&&
        _callback) const {
  ::fidl::Encoder _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_TransitionalRequestRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::Transitional::Request>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::Transitional::Request>>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::OneWay(
    ::test_protocols::TransitionalOneWayRequest&& payload) const {
  ::fidl::Encoder _encoder{::test_protocols::kTransitional_OneWay_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_TransitionalOneWayRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fitx::result<::fidl::Error,
                     ::fidl::Event<::test_protocols::Transitional::Event>>
          decoded = ::fidl::Event<::test_protocols::Transitional::Event>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->Event(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::test_protocols::MethodWithUnionUnionMethodRequest&& payload) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_MethodWithUnionUnionMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::ClientEnds>>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::test_protocols::WithProtocolEndsClientEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::ClientEnds>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsClientEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::ClientEnds>>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::ServerEnds>>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::test_protocols::WithProtocolEndsServerEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::ServerEnds>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsServerEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::ServerEnds>>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
        ::fidl::ClientCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>,
          ::fidl::ClientCallback<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::test_protocols::WithProtocolEndsStructContainingEndsRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithProtocolEndsStructContainingEndsRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>::Fifteen(
    ::test_protocols::ManyParametersFifteenRequest&& payload) const {
  ::fidl::Encoder _encoder{::test_protocols::kManyParameters_Fifteen_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_ManyParametersFifteenRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxResponseAsStructRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientResponseCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxResponseAsStructRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientResponseCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsEnumRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientResponseCallback<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxErrorAsEnumRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxHandleInResultRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::fidl::ClientCallback<
              ::test_protocols::WithErrorSyntax::HandleInResult>>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientResponseCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_WithErrorSyntaxHandleInResultRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::WithErrorSyntax::HandleInResult>>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kDiscoverableProtocol_Method_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_DiscoverableProtocolMethodRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(_encoder));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;
[[maybe_unused]] constexpr inline uint64_t
    kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::test_protocols::ChannelProtocolMethodBRequest&& payload,
            ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
                _callback) const {
  ::fidl::Encoder _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>,
          ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::test_protocols::ChannelProtocolMethodBRequest&& payload,
            ::fidl::ClientResponseCallback<
                ::test_protocols::ChannelProtocol::MethodB>&& _callback) const {
  ::fidl::Encoder _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodBRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::MethodB>>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
        ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
            _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolTakeHandleRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>,
          ::fidl::ClientCallback<
              ::test_protocols::ChannelProtocol::TakeHandle>>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::test_protocols::ChannelProtocolTakeHandleRequest&& payload,
        ::fidl::ClientResponseCallback<
            ::test_protocols::ChannelProtocol::TakeHandle>&& _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolTakeHandleRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::TakeHandle>>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
                 ::fidl::ClientCallback<
                     ::test_protocols::ChannelProtocol::MutateSocket>&&
                     _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>,
          ::fidl::ClientCallback<
              ::test_protocols::ChannelProtocol::MutateSocket>>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(::test_protocols::ChannelProtocolMutateSocketRequest&& payload,
                 ::fidl::ClientResponseCallback<
                     ::test_protocols::ChannelProtocol::MutateSocket>&&
                     _callback) const {
  ::fidl::Encoder _encoder{
      ::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMutateSocketRequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)),
      ::fidl::internal::MakeResponseContext<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>,
          ::fidl::ClientResponseCallback<
              ::test_protocols::ChannelProtocol::MutateSocket>>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::MethodA(
    ::test_protocols::ChannelProtocolMethodARequest&& payload) const {
  ::fidl::Encoder _encoder{::test_protocols::kChannelProtocol_MethodA_Ordinal};
  ::fidl::Result result = messenger().OneWay(
      &::test::protocols::_internal::
          test_protocols_ChannelProtocolMethodARequestMessageTable,
      ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
          _encoder, std::move(payload)));
  return ::fidl::internal::ToFitxResult(result);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fitx::result<::fidl::Error,
                     ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>
          decoded = ::fidl::Event<::test_protocols::ChannelProtocol::EventA>::
              DecodeTransactional(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        event_handler()->EventA(decoded.value());
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__
