// WARNING: This file is machine generated by fidlgen.

  #pragma once

  #include <cinttypes>

  #include <lib/fidl/cpp/wire/internal/transport_err.h>
  #include <lib/fidl/llcpp/array.h>
  #include <lib/fidl/llcpp/envelope.h>
  #include <lib/fidl/llcpp/message_storage.h>
  #include <lib/fidl/llcpp/message.h>
  #include <lib/fidl/llcpp/object_view.h>
  #include <lib/fidl/llcpp/string_view.h>
  #include <lib/fidl/llcpp/traits.h>
  #include <lib/fidl/llcpp/wire_types.h>
  #include <lib/stdcompat/optional.h>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>
    
#endif  // __Fuchsia__


  #include <fidl/test.unknowninteractions/cpp/markers.h>
  #include <fidl/test.unknowninteractions/cpp/common_types.h>
  

  namespace test_unknowninteractions {

  
  
  
namespace wire {
struct UnknownInteractionsProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsProtocolStrictTwoWayErrTopResponse;

struct UnknownInteractionsProtocolStrictEventErrResponse;

struct UnknownInteractionsProtocolStrictEventErrRequest;

struct UnknownInteractionsProtocolFlexibleTwoWayResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayTopResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

struct UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse;

struct UnknownInteractionsProtocolFlexibleEventErrResponse;

struct UnknownInteractionsProtocolFlexibleEventErrRequest;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse;

struct UnknownInteractionsClosedProtocolStrictEventErrResponse;

struct UnknownInteractionsClosedProtocolStrictEventErrRequest;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse;

struct UnknownInteractionsAjarProtocolStrictEventErrResponse;

struct UnknownInteractionsAjarProtocolStrictEventErrRequest;

struct UnknownInteractionsAjarProtocolFlexibleEventErrResponse;

struct UnknownInteractionsAjarProtocolFlexibleEventErrRequest;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse;
  
  

class UnknownInteractionsProtocolStrictTwoWayErrResult;

class UnknownInteractionsProtocolStrictEventErrResult;

class UnknownInteractionsProtocolFlexibleTwoWayResult;

class UnknownInteractionsProtocolFlexibleTwoWayErrResult;

class UnknownInteractionsProtocolFlexibleEventErrResult;

class UnknownInteractionsDriverProtocolStrictTwoWayErrResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayResult;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;

class UnknownInteractionsClosedProtocolStrictTwoWayErrResult;

class UnknownInteractionsClosedProtocolStrictEventErrResult;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;

class UnknownInteractionsAjarProtocolStrictTwoWayErrResult;

class UnknownInteractionsAjarProtocolStrictEventErrResult;

class UnknownInteractionsAjarProtocolFlexibleEventErrResult;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventErr_ResponseTable;

struct UnknownInteractionsProtocolStrictEventErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWay_ResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayErr_ResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventErr_ResponseTable;

struct UnknownInteractionsProtocolFlexibleEventErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventErr_ResponseTable;

struct UnknownInteractionsClosedProtocolStrictEventErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventErr_ResponseTable;

struct UnknownInteractionsAjarProtocolStrictEventErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventErr_ResponseTable;

struct UnknownInteractionsAjarProtocolFlexibleEventErrResponse {

    uint8_t __reserved = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse {

    uint8_t __reserved = {};
};
    
  
  


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse;

  UnknownInteractionsProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictTwoWayErrResult(const UnknownInteractionsProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult(UnknownInteractionsProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_StrictEventErr_ResultTable;

class UnknownInteractionsProtocolStrictEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse;

  UnknownInteractionsProtocolStrictEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolStrictEventErrResult(const UnknownInteractionsProtocolStrictEventErrResult&) = default;
  UnknownInteractionsProtocolStrictEventErrResult& operator=(const UnknownInteractionsProtocolStrictEventErrResult&) = default;
  UnknownInteractionsProtocolStrictEventErrResult(UnknownInteractionsProtocolStrictEventErrResult&&) = default;
  UnknownInteractionsProtocolStrictEventErrResult& operator=(UnknownInteractionsProtocolStrictEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolStrictEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse val) {
    UnknownInteractionsProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolStrictEventErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWay_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse;

  UnknownInteractionsProtocolFlexibleTwoWayResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayResult(const UnknownInteractionsProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult(UnknownInteractionsProtocolFlexibleTwoWayResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse val) {
    UnknownInteractionsProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayErr_ResultTable;

class UnknownInteractionsProtocolFlexibleTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse;

  UnknownInteractionsProtocolFlexibleTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleTwoWayErrResult(const UnknownInteractionsProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult& operator=(const UnknownInteractionsProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult(UnknownInteractionsProtocolFlexibleTwoWayErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleTwoWayErrResult& operator=(UnknownInteractionsProtocolFlexibleTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse val) {
    UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsProtocolFlexibleTwoWayErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventErr_ResultTable;

class UnknownInteractionsProtocolFlexibleEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse;

  UnknownInteractionsProtocolFlexibleEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsProtocolFlexibleEventErrResult(const UnknownInteractionsProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventErrResult& operator=(const UnknownInteractionsProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsProtocolFlexibleEventErrResult(UnknownInteractionsProtocolFlexibleEventErrResult&&) = default;
  UnknownInteractionsProtocolFlexibleEventErrResult& operator=(UnknownInteractionsProtocolFlexibleEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsProtocolFlexibleEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse val) {
    UnknownInteractionsProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsProtocolFlexibleEventErrResult WithErr(int32_t val) {
    UnknownInteractionsProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult(UnknownInteractionsDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult(UnknownInteractionsDriverProtocolFlexibleTwoWayResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResultTable;

class UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse;

  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult(const UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult& operator=(const UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&&) = default;
  UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult& operator=(UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_transport_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr; }
  
  static UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult WithTransportErr(::fidl::internal::TransportErr val) {
    UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr;
    result.envelope_.As<::fidl::internal::TransportErr>().set_data(std::move(val));
    return result;
  }


  ::fidl::internal::TransportErr& transport_err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  const ::fidl::internal::TransportErr& transport_err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal::kTransportErr);
    return envelope_.As<::fidl::internal::TransportErr>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
    kTransportErr = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse;

  UnknownInteractionsClosedProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictTwoWayErrResult(const UnknownInteractionsClosedProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsClosedProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult(UnknownInteractionsClosedProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsClosedProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsClosedProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventErr_ResultTable;

class UnknownInteractionsClosedProtocolStrictEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse;

  UnknownInteractionsClosedProtocolStrictEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedProtocolStrictEventErrResult(const UnknownInteractionsClosedProtocolStrictEventErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventErrResult& operator=(const UnknownInteractionsClosedProtocolStrictEventErrResult&) = default;
  UnknownInteractionsClosedProtocolStrictEventErrResult(UnknownInteractionsClosedProtocolStrictEventErrResult&&) = default;
  UnknownInteractionsClosedProtocolStrictEventErrResult& operator=(UnknownInteractionsClosedProtocolStrictEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedProtocolStrictEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse val) {
    UnknownInteractionsClosedProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedProtocolStrictEventErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse;

  UnknownInteractionsAjarProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictTwoWayErrResult(const UnknownInteractionsAjarProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsAjarProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult(UnknownInteractionsAjarProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsAjarProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsAjarProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventErr_ResultTable;

class UnknownInteractionsAjarProtocolStrictEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse;

  UnknownInteractionsAjarProtocolStrictEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolStrictEventErrResult(const UnknownInteractionsAjarProtocolStrictEventErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventErrResult& operator=(const UnknownInteractionsAjarProtocolStrictEventErrResult&) = default;
  UnknownInteractionsAjarProtocolStrictEventErrResult(UnknownInteractionsAjarProtocolStrictEventErrResult&&) = default;
  UnknownInteractionsAjarProtocolStrictEventErrResult& operator=(UnknownInteractionsAjarProtocolStrictEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolStrictEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse val) {
    UnknownInteractionsAjarProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolStrictEventErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolStrictEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventErr_ResultTable;

class UnknownInteractionsAjarProtocolFlexibleEventErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse;

  UnknownInteractionsAjarProtocolFlexibleEventErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarProtocolFlexibleEventErrResult(const UnknownInteractionsAjarProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventErrResult& operator=(const UnknownInteractionsAjarProtocolFlexibleEventErrResult&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventErrResult(UnknownInteractionsAjarProtocolFlexibleEventErrResult&&) = default;
  UnknownInteractionsAjarProtocolFlexibleEventErrResult& operator=(UnknownInteractionsAjarProtocolFlexibleEventErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse val) {
    UnknownInteractionsAjarProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarProtocolFlexibleEventErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarProtocolFlexibleEventErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResultTable;

class UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult {
  public:
  using Response = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse;

  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult() : ordinal_(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid), envelope_{} {}

  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult(const UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult& operator=(const UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&&) = default;
  UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult& operator=(UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  bool has_invalid_tag() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::Invalid; }

  bool is_response() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult WithResponse(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse;
    result.envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().set_data(std::move(val));
    return result;
  }


  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& response() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().get_data();
  }
  const ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse& response() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kResponse);
    return envelope_.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>().get_data();
  }

  bool is_err() const { return ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr; }
  
  static UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult WithErr(int32_t val) {
    UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result;
    result.ordinal_ = ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr;
    result.envelope_.As<int32_t>().set_data(std::move(val));
    return result;
  }


  int32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal::kErr);
    return envelope_.As<int32_t>().get_data();
  }
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};
  
  
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable;

struct UnknownInteractionsProtocolStrictEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable;

struct UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable;

struct UnknownInteractionsProtocolFlexibleEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponseTable;

struct UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable;

struct UnknownInteractionsClosedProtocolStrictEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable;

struct UnknownInteractionsAjarProtocolStrictEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable;

struct UnknownInteractionsAjarProtocolFlexibleEventErrRequest {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult result = {};
};
    
    


extern "C" const fidl_type_t test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponseTable;

struct UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse {
  using Result = test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult;

    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult result = {};
};

  }  // namespace wire
}  // namespace test_unknowninteractions
namespace fidl {

  
  
  


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_StrictEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolStrictEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWay_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocol_FlexibleEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsProtocolFlexibleEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWay_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocol_FlexibleTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocol_StrictEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedProtocolStrictEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_StrictEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolStrictEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocol_FlexibleEventErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarProtocolFlexibleEventErrRequestTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrRequest));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocol_StrictTwoWayErr_ResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 1;
  static constexpr uint32_t kPrimarySizeV1 = 1;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, __reserved) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 1;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse));
    } else {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(encoder, &value->__reserved, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<uint8_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
    if (*position.As<uint8_t>() != 0) {
      decoder->SetError(kCodingErrorInvalidPaddingBytes);
    }
  }
};


// TODO(fxbug.dev/95833) Remove this.
template<>
struct DeprecatedCTypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>{
  static constexpr const fidl_type_t* kType = &::test_unknowninteractions::wire::test_unknowninteractions_UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponseTable;
};

template<>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
template <>
struct IsStruct<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>);
static_assert(offsetof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, result) == 0);
static_assert(sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse) == TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse>::kPrimarySize);

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr auto kMembers = std::make_tuple(::fidl::internal::WireStructMemberCodingInfo<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>());
  static constexpr bool kHasPadding = false;
  using Base = WireStructCodingTraitsBase<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>;
  static constexpr bool is_memcpy_compatible = Base::is_memcpy_compatible;

  static void Encode(
    internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (is_memcpy_compatible) {
      memcpy(position.As<void>(), value, sizeof(::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrTopResponse));
    } else {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Encode(encoder, &value->result, position + 0, recursion_depth);
    }
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    if constexpr (!Base::are_members_memcpy_compatible) {
      internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, fidl::internal::WireCodingConstraintUnion<false>, IsRecursive>::Decode(
        decoder, position + 0, recursion_depth);
    }
  }
};
  
  


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 3: // ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr
        encode_fn = ::fidl::internal::MakeEncodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        inline_size = ::fidl::internal::WireCodingTraits<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult::Tag::kTransportErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<::fidl::internal::TransportErr, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsDriverProtocolFlexibleTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsClosedDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolStrictEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarProtocolFlexibleEventErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};


template <>
struct TypeTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> {
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]]
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
template <>
struct IsUnion<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult> : public std::true_type {};
static_assert(std::is_standard_layout_v<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult>);

template <typename Constraint, bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, Constraint, IsRecursive> {
  static constexpr size_t inline_size = 16;
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::WireEncoder* encoder, ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl_xunion_v2_t* u = reinterpret_cast<fidl_xunion_v2_t*>(value);

    if (unlikely(u->tag == 0)) {
      if constexpr (Constraint::is_optional) {
        *position.As<fidl_xunion_v2_t>() = {};
        return;
      }
      encoder->SetError(kCodingErrorInvalidUnionTag);
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(encoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    *position.As<fidl_xunion_tag_t>() = u->tag;

    
    size_t inline_size;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    ::fidl::internal::EncodeFn<IsRecursive> encode_fn;
    switch (u->tag) {
      case 1: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse
        encode_fn = ::fidl::internal::MakeEncodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case 2: // ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr
        encode_fn = ::fidl::internal::MakeEncodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        encode_fn = nullptr;
        break;
    }
    WireEncodeEnvelope(inline_size, encode_fn, encoder, &u->envelope, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }

  static void Decode(internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag tag = *position.As<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag>();
    if (unlikely(static_cast<uint64_t>(tag) == 0)) {
      if constexpr (!Constraint::is_optional) {
        decoder->SetError(kCodingErrorInvalidUnionTag);
        return;
      }
      static_assert(sizeof(fidl_envelope_v2_t) == sizeof(uint64_t));
      if (*(position + sizeof(fidl_xunion_tag_t)).As<uint64_t>() != 0) {
        decoder->SetError(kCodingErrorZeroTagButNonZeroEnvelope);
      }
      return;
    }

    RecursionDepth<IsRecursive> inner_depth = recursion_depth.Add(decoder, 1);
    if (!inner_depth.IsValid()) {
      return;
    }

    
    size_t inline_size;
    switch (tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        inline_size = ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        inline_size = ::fidl::internal::WireCodingTraits<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>::inline_size;
        break;
      default:
        inline_size = 0;
        break;
    }
    DecodeFn<IsRecursive> decode_fn;
    switch(tag) {
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kResponse:
        decode_fn = ::fidl::internal::MakeDecodeFn<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResponse, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      case ::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult::Tag::kErr:
        decode_fn = ::fidl::internal::MakeDecodeFn<int32_t, fidl::internal::WireCodingConstraintEmpty, IsRecursive>();
        break;
      default:
        decode_fn = nullptr;
        break;
    }
    ::fidl::internal::WireDecodeStrictEnvelope(inline_size, decode_fn, decoder, position + sizeof(fidl_xunion_tag_t), inner_depth);
  }
};

// Top-level union.
template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public ::fidl::internal::WireCodingTraits<::test_unknowninteractions::wire::UnknownInteractionsAjarDriverProtocolStrictTwoWayErrResult, ::fidl::internal::WireCodingConstraintUnion<false>, IsRecursive> {};

  }  // namespace fidl
