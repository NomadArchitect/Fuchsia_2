{{/*
// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Protocol:Interface:MessagingHeader" }}
{{- range .ClientMethods }}
  {{- template "MethodRequestDeclaration" . }}
{{- end }}

{{- range .TwoWayMethods }}
  {{- template "Method:CompleterBase:MessagingHeader" . }}
{{- end }}

template<>
class {{ .NaturalServer }} : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  {{ .NaturalServer.Self }}() = default;
  virtual ~{{ .NaturalServer.Self }}() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = {{ .Wire }};

{{ "" }}
  {{- range .ClientMethods }}
  using {{ .NaturalRequestAlias.Self }} = {{ .NaturalRequest }};
  using {{ .NaturalCompleterAlias.Self }} = {{ .NaturalCompleter }};

  {{ .Docs }}
  virtual void {{ .Name }}(
      {{- .NaturalRequestAlias.Self }}& request, {{ .NaturalCompleterArg }}& completer
  )
    {{- if .Transitional -}}
      { completer.Close(ZX_ERR_NOT_SUPPORTED); }
    {{- else -}}
      = 0;
    {{- end }}
{{ "" }}
  {{- end }}

  private:
  {{- /* Note that this implementation is snake_case to avoid name conflicts. */}}
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) final;
};
{{- end }}



{{- define "Protocol:Interface:Source" }}
{{- range .ClientMethods }}
  {{- template "MethodRequestDefinition" . }}
{{- end }}

{{- range .TwoWayMethods }}
  {{- template "Method:CompleterBase:MessagingSource" . }}
{{- end }}
{{- end }}
