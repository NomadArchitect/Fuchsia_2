{{/*
// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Method:Result:WireMessagingHeader" }}
{{- EnsureNamespace "" }}
template<>
class [[nodiscard]] {{ .WireResult }} final : public ::fidl::Status {
  public:
    {{ .WireResult.Self }}(::{{ .Transport.Namespace }}::UnownedClientEnd<{{ .Protocol }}> client,
        {{ .WireTransactionalRequest }}* request);
   {{- if .HasResponse }}
    {{ .WireResult.Self }}(::{{ .Transport.Namespace }}::UnownedClientEnd<{{ .Protocol }}> client,
        {{ .WireTransactionalRequest }}* request, zx_time_t _deadline);
   {{- end }}
   explicit {{ .WireResult.Self }}(const ::fidl::Status& result) : ::fidl::Status(result) {}
   {{ .WireResult.Self }}({{ .WireResult.Self }}&&) = delete;
   {{ .WireResult.Self }}(const {{ .WireResult.Self }}&) = delete;
   {{ .WireResult.Self }}* operator=({{ .WireResult.Self }}&&) = delete;
   {{ .WireResult.Self }}* operator=(const {{ .WireResult.Self }}&) = delete;
   {{- if and .HasResponse .Response.IsResource }}
   ~{{ .WireResult.Self }}() {
     if (ok()) {
     Unwrap()->_CloseHandles();
     }
   }
   {{- else }}
   ~{{ .WireResult.Self }}() = default;
   {{- end }}
   {{- if .HasResponse }}

   {{- if .ResponseArgs }}
   {{ .WireResponse }}* Unwrap() {
     ZX_DEBUG_ASSERT(ok());
     return reinterpret_cast<{{ .WireResponse }}*>(bytes_.data() + sizeof(fidl_message_header_t));
   }
   const {{ .WireResponse }}* Unwrap() const {
     ZX_DEBUG_ASSERT(ok());
     return reinterpret_cast<const {{ .WireResponse }}*>(bytes_.data() + sizeof(fidl_message_header_t));
   }

   {{ .WireResultBase }}* Unwrap_NEW() {
     {{- if .Result }}
       return &result_.value();
     {{- else }}
       ZX_DEBUG_ASSERT(ok());
       return reinterpret_cast<{{ .WireResponse }}*>(bytes_.data() + sizeof(fidl_message_header_t));
     {{- end }}
   }
   const {{ .WireResultBase }}* Unwrap_NEW() const {
     {{- if .Result }}
       return &result_.value();
     {{- else }}
       ZX_DEBUG_ASSERT(ok());
       return reinterpret_cast<const {{ .WireResponse }}*>(bytes_.data() + sizeof(fidl_message_header_t));
     {{- end }}
   }

   {{ .WireResponse }}& value() { return *Unwrap(); }
   const {{ .WireResponse }}& value() const { return *Unwrap(); }

   {{ .WireResultBase }}& value_NEW() { return *Unwrap_NEW(); }
   const {{ .WireResultBase }}& value_NEW() const { return *Unwrap_NEW(); }

   {{ .WireResponse }}* operator->() { return &value(); }
   const {{ .WireResponse }}* operator->() const { return &value(); }

   {{ .WireResponse }}& operator*() { return value(); }
   const {{ .WireResponse }}& operator*() const { return value(); }
   {{- end }}
   {{- end }}

  private:
   {{- if .HasResponse }}
   {{ .Response.ClientAllocationV1.BackingBufferType }} bytes_;
   {{- end }}
   {{- if .Result }}
   std::optional<{{ .WireResultBase }}> result_ = std::nullopt;
   {{- end }}
};
{{- end }}






{{- define "Method:Result:WireMessagingSource" }}
{{- IfdefFuchsia -}}
{{- EnsureNamespace "" }}
{{ .WireResult }}::{{ .WireResult.Self }}(
    ::{{ .Transport.Namespace }}::UnownedClientEnd<{{ .Protocol }}> client,
    {{ .WireTransactionalRequest }}* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<{{ .WireTransactionalRequest }}, {{ .Transport.Type }}> request_message(
      ::fidl::internal::AllowUnownedInputRef{},
      request);
  auto& outgoing = request_message.GetOutgoingMessage();
  {{- if .HasResponse }}
  outgoing.Call<{{ .WireTransactionalResponse }}>(
    client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  {{- else }}
  outgoing.Write(client.handle());
  {{- end }}
  SetStatus(outgoing);
  {{- if .Result }}
    if (ok()) {
      auto* raw_response = reinterpret_cast<{{ .WireResponse }} *>(
          bytes_.data() + sizeof(fidl_message_header_t));
      if (raw_response->result.is_err()) {
        result_ = fitx::error(raw_response->result.err());
      } else if (raw_response->result.is_response()) {
        result_ = fitx::ok(
          {{- if .Result.ValueParameters -}}
            &(raw_response->result.response())
          {{- end -}}
        );
      }
    }
  {{- end }}
}
  {{- if .HasResponse }}

{{ .WireResult }}::{{ .WireResult.Self }}(
    ::{{ .Transport.Namespace }}::UnownedClientEnd<{{ .Protocol }}> client,
    {{ .WireTransactionalRequest }}* request, zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<{{ .WireTransactionalRequest }}, {{ .Transport.Type }}> request_message(
      ::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<{{ .WireTransactionalResponse }}>(
    client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()), fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
  {{- if .Result }}
    if (ok()) {
      auto* raw_response = reinterpret_cast<{{ .WireResponse }} *>(
          bytes_.data() + sizeof(fidl_message_header_t));
      if (raw_response->result.is_err()) {
        result_ = fitx::error(raw_response->result.err());
      } else if (raw_response->result.is_response()) {
        result_ = fitx::ok(
          {{- if .Result.ValueParameters -}}
            &(raw_response->result.response())
          {{- end -}}
        );
      }
    }
  {{- end }}
}
  {{- end }}
{{- EndifFuchsia -}}
{{- end }}

