{{/*
// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Protocol:SyncClient:MessagingHeader" }}
{{- EnsureNamespace "" }}
template<>
class {{ .WireSyncClient }} final : public ::fidl::internal::WireSyncClientBase<{{ . }}> {
 public:
  using ::fidl::internal::WireSyncClientBase<{{ . }}>::WireSyncClientBase;

  {{- /* TODO(fxbug.dev/85688): This is to disambiguate FIDL methods named "Bind".
         Delete them after all users switch to "->" to make calls. */}}
  using ::fidl::internal::WireSyncClientBase<{{ . }}>::Bind;

  {{- /* TODO(fxbug.dev/85688): These methods are preserved for soft migration only.
         Delete them after all users switch to "->" to make calls. */}}
  {{- range .ClientMethods }}
  {{ .Docs }}
  //{{ template "Method:ClientAllocationComment:Helper" . }}
  {{ .WireResult }} {{ .Name }}({{ RenderParams .RequestArgs }}) const {
    {{ .WireRequest }} _request{ {{ RenderForwardParams .RequestArgs }} };
    return {{ .WireResult }}(this->client_end(), &_request);
  }

  {{- /* TODO(fxbug.dev/85688): These methods are preserved for soft migration only.
         Delete them after all users switch to "->" to make calls. */}}
  {{- if or .RequestArgs .ResponseArgs }}
  {{ .Docs }}
  // Caller provides the backing storage for FIDL message via request and response buffers.
  {{ .WireUnownedResult }} {{ .Name }}(
      {{- template "Method:ClientImplSyncCallerAllocateArguments:Helper" . }}) const {
    auto _allocator = ::fidl::internal::MakeAnyBufferAllocator(_buffer_span);
    {{ .WireRequest }} _request{ {{ RenderForwardParams .RequestArgs }} };
    return {{ .WireUnownedResult }}(this->client_end(), _allocator, &_request);
  }
  {{- end }}
  {{- end }}

  {{- if .Events }}
  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the corresponding virtual
  // method defined in |SyncEventHandler|. The return status of the handler function is folded with
  // any transport-level errors and returned.
  ::fidl::Result HandleOneEvent({{ .WireSyncEventHandler }}& event_handler) const {
    return event_handler.HandleOneEvent(client_end());
  }
  {{- end }}
};
{{- end }}
