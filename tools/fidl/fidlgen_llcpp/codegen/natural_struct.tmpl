{{/*
// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
*/}}

{{- define "Struct:ForwardDeclaration:NaturalTypesHeader" }}
{{ EnsureNamespace . }}
class {{ .Name }};
{{- end }}

{{- define "Struct:NaturalTypesHeader" }}
{{ EnsureNamespace . }}
{{ if .IsResourceType }}
{{- IfdefFuchsia -}}
{{- end }}
extern "C" const fidl_type_t {{ .CodingTableType }};

{{ .Docs }}
class {{ .Name }} final : public ::fidl::internal::CodableBase<{{ .Name }}>  {
 private:
  friend ::fidl::internal::CodableBase<{{ .Name }}>;
  friend ::fidl::CodingTraits<{{ .Name }}>;
  {{ .Name }}(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload) -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    {{- range .Members }}
      {{- .Docs }}
      {{ .Type }} {{ .Name }}
      {{- if .DefaultValue.IsSet }}
        = {{ .DefaultValue }};
      {{- else }}
        {};
      {{- end }}
    {{- end }}
  };

  {{ .Name }}(Storage storage) noexcept : storage_(std::move(storage)) {}

  {{- if len .Members }}
    {{ .Name }}(
    {{- range $i, $m := .Members }}
      {{- if $i }}, {{ end }}
      {{- $m.Type }} {{ $m.Name }}
    {{- end }}) noexcept
    : storage_({
    {{- range $i, $m := .Members }}
      {{- if $i }}, {{ end }}
      .{{ $m.Name }} = std::move({{ $m.Name}})
    {{- end }}
    }) {}
  {{- end }}
  {{ .Name }}() : {{ .Name }}(Storage{}) {}

  {{ .Name }}({{ .Name }}&&) noexcept = default;
  {{ .Name }}& operator=({{ .Name }}&&) noexcept = default;
  {{- if not .IsResourceType }}
    {{ .Name }}(const {{ .Name }}& other) noexcept : {{ .Name }}(other.CloneStorage()){}
    {{ .Name }}& operator=(const {{ .Name }}& other) noexcept {
      storage_ = other.CloneStorage();
      return *this;
    }
  {{- end }}

  {{- range .Members }}
    {{ .Docs }}
    {{- if .Type.IsPrimitiveType }}
      {{ .Type }}
    {{- else }}
      const {{ .Type }} &
    {{- end }}
    {{ .Name }}() const {
      return storage_.{{ .Name }};
    }

    {{ .Docs }}
    {{ .Type }}& {{ .Name }}() {
      return storage_.{{ .Name }};
    }
  {{- end }}
 private:
  Storage storage_;
  {{- if not .IsResourceType }}
    Storage CloneStorage() const;
  {{- end }}
};

{{ if .IsResourceType }}
{{- EndifFuchsia -}}
{{- end }}
{{- end }}


{{- define "Struct:Traits:NaturalTypesHeader" }}
  {{- IfdefFuchsia -}}

  extern "C" const fidl_type_t {{ .CodingTableType }};

  {{ if .IsResourceType }}
  template <>
  struct IsResource<{{ . }}> : public std::true_type {};
  {{- end }}
  template <>
  struct IsFidlType<{{ . }}> : public std::true_type {};

  template <>
  struct {{ .TypeTraits }} final {
  public:
    static constexpr const fidl_type_t* kCodingTable = &{{ .CodingTableType }};
  };

  {{- /*
  TODO(fxbug.dev/82189): We are reusing the HLCPP coding machinery. For now this
  is the minimal to support encoding/decoding, without any optimizations. This may
  change as we gradually move to a complete natural domain object fork.
  */}}

  template <>
  struct CodingTraits<{{ . }}> {
    static constexpr size_t inline_size_v1_no_ee = {{ .TypeShapeV1.InlineSize }};
    static constexpr size_t inline_size_v2 = {{ .TypeShapeV2.InlineSize }};

    template <class EncoderImpl>
    static void Encode(EncoderImpl* encoder, {{ . }}* value, size_t offset,
                      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
      [[maybe_unused]] uint32_t field_offset;
      {{- range .Members }}
      field_offset =
          encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ?
          {{ .OffsetV1 }} : {{ .OffsetV2 }};
      ::fidl::Encode(
          encoder,
          &value->storage_.{{ .Name }},
          offset + field_offset
          {{- if .HandleInformation }}, ::fidl::HandleInformation {
            .object_type = {{ .HandleInformation.ObjectType }},
            .rights = {{ .HandleInformation.Rights }},
          }{{ end }}
      );
      {{- end }}
    }

    template <typename DecoderImpl>
    static void Decode(DecoderImpl* decoder, {{ . }}* value, size_t offset) {
      {{- range .Members }}
      ::fidl::Decode(decoder, &value->storage_.{{ .Name }}, offset + {{ .OffsetV2 }});
      {{- end }}
    }
  };

  {{- EndifFuchsia -}}
{{- end }}


{{- define "Struct:NaturalTypesSource" }}
{{- IfdefFuchsia -}}
{{- EnsureNamespace "" }}

void {{ . }}::EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<{{ . }}, ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<{{ . }}>::Encode(&encoder, this, offset);
}

{{ . }}::{{ .Name }}(::fidl::Decoder& decoder) : storage_({
    {{- range $index, $member := .Members -}}
      {{- if $index }}, {{ end -}}
      ::fidl::DecodeAs<{{ .Type }}>(&decoder, {{ .OffsetV2 }})
    {{- end -}}
}) {}

{{- EndifFuchsia -}}

{{- if not .IsResourceType }}
  {{ . }}::Storage {{ .NoLeading }}::CloneStorage() const {
    return Storage{
      {{- range $i, $m := .Members }}
        {{- if $i }}, {{ end }}
        ::fidl::internal::NaturalClone(storage_.{{ .Name }})
      {{- end }}
    };
  }
{{- end }}

{{- end }}