// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.bindingsdenylist/cpp/common_types.h>
#include <fidl/test.bindingsdenylist/cpp/markers.h>
#include <fidl/test.dependent/cpp/wire_types.h>

namespace test_bindingsdenylist {
namespace wire {
struct ShouldNeverAppearInAnyBinding7;

struct ShouldNeverAppearInAnyBinding4;

struct AllowedDeniedResponse;

struct ShouldNeverAppearInAnyBinding1;

struct MemberOnlyAppearsInImportingLibrary;

struct OnlyAppearsInImportingLibrary;

struct DenyEachBindingOnlyDenySyzkallerResponse;

struct DenyEachBindingOnlyDenyRustResponse;

struct DenyEachBindingOnlyDenyLibfuzzerResponse;

struct DenyEachBindingOnlyDenyGoResponse;

struct DenyEachBindingOnlyDenyDartResponse;

struct DenyEachBindingOnlyDenyCppResponse;

class ShouldNeverAppearInAnyBinding8;

class ShouldNeverAppearInAnyBinding5;

class ShouldNeverAppearInAnyBinding2;

class ShouldNeverAppearInAnyBinding9;

class ShouldNeverAppearInAnyBinding6;

class AllowedDeniedResult;

class ShouldNeverAppearInAnyBinding3;

class OnlyLlcpp;

class DenyEachBindingOnlyDenySyzkallerResult;

class DenyEachBindingOnlyDenyRustResult;

class DenyEachBindingOnlyDenyLibfuzzerResult;

class DenyEachBindingOnlyDenyGoResult;

class DenyEachBindingOnlyDenyDartResult;

class DenyEachBindingOnlyDenyCppResult;

extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding7Table;

struct ShouldNeverAppearInAnyBinding7 {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding7Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  static constexpr uint32_t PrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  bool a = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding4Table;

struct ShouldNeverAppearInAnyBinding4 {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding4Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  static constexpr uint32_t PrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  bool a = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding1Table;

struct ShouldNeverAppearInAnyBinding1 {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding1Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  static constexpr uint32_t PrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  bool a = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;

struct MemberOnlyAppearsInImportingLibrary {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_MemberOnlyAppearsInImportingLibraryTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  static constexpr uint32_t PrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  bool a = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;

struct OnlyAppearsInImportingLibrary {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_OnlyAppearsInImportingLibraryTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  static constexpr uint32_t PrimarySizeV1 = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;
  using MemberOnlyAppearsInImportingLibrary =
      test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary;

  ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary
      member_only_appears_in_importing_library = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;

struct DenyEachBindingOnlyDenySyzkallerResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  static constexpr uint32_t PrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  int32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;

struct DenyEachBindingOnlyDenyRustResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  static constexpr uint32_t PrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  int32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;

struct DenyEachBindingOnlyDenyLibfuzzerResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  static constexpr uint32_t PrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  int32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;

struct DenyEachBindingOnlyDenyGoResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  static constexpr uint32_t PrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  int32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;

struct DenyEachBindingOnlyDenyDartResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  static constexpr uint32_t PrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  int32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyCpp_ResponseTable;

struct DenyEachBindingOnlyDenyCppResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyCpp_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  static constexpr uint32_t PrimarySizeV1 = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 0;
  static constexpr bool HasPointer = false;

  int32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

}  // namespace wire
}  // namespace test_bindingsdenylist
template <>
struct ::fidl::WireTableFrame<
    ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>
    final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;
  ::fidl::Envelope<bool> a_;

  friend class ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8;
};

namespace test_bindingsdenylist {
namespace wire {
extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding8Table;

class ShouldNeverAppearInAnyBinding8 final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  const bool& a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }
  bool& a() {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }
  bool has_a() const { return max_ordinal_ >= 1 && frame_ptr_->a_.has_data(); }
  ShouldNeverAppearInAnyBinding8& set_a(bool elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  ShouldNeverAppearInAnyBinding8& clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    return *this;
  }

  ShouldNeverAppearInAnyBinding8() = default;
  explicit ShouldNeverAppearInAnyBinding8(::fidl::AnyArena& allocator)
      : frame_ptr_(
            ::fidl::ObjectView<::fidl::WireTableFrame<
                ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>>(
                allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit ShouldNeverAppearInAnyBinding8(
      ::fidl::ObjectView<::fidl::WireTableFrame<
          ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>>&&
          frame)
      : frame_ptr_(std::move(frame)) {}
  ~ShouldNeverAppearInAnyBinding8() = default;
  ShouldNeverAppearInAnyBinding8(
      const ShouldNeverAppearInAnyBinding8& other) noexcept = default;
  ShouldNeverAppearInAnyBinding8& operator=(
      const ShouldNeverAppearInAnyBinding8& other) noexcept = default;
  ShouldNeverAppearInAnyBinding8(
      ShouldNeverAppearInAnyBinding8&& other) noexcept = default;
  ShouldNeverAppearInAnyBinding8& operator=(
      ShouldNeverAppearInAnyBinding8&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding8Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr uint32_t MaxOutOfLineV1 = 24;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<
        ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>>(
        allocator);
  }
  void Init(
      ::fidl::ObjectView<::fidl::WireTableFrame<
          ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>>&&
          frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<
      ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>>
      frame_ptr_;
};

}  // namespace wire
}  // namespace test_bindingsdenylist
template <>
struct ::fidl::WireTableFrame<
    ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>
    final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;
  ::fidl::Envelope<bool> a_;

  friend class ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5;
};

namespace test_bindingsdenylist {
namespace wire {
extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding5Table;

class ShouldNeverAppearInAnyBinding5 final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  const bool& a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }
  bool& a() {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }
  bool has_a() const { return max_ordinal_ >= 1 && frame_ptr_->a_.has_data(); }
  ShouldNeverAppearInAnyBinding5& set_a(bool elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  ShouldNeverAppearInAnyBinding5& clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    return *this;
  }

  ShouldNeverAppearInAnyBinding5() = default;
  explicit ShouldNeverAppearInAnyBinding5(::fidl::AnyArena& allocator)
      : frame_ptr_(
            ::fidl::ObjectView<::fidl::WireTableFrame<
                ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>>(
                allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit ShouldNeverAppearInAnyBinding5(
      ::fidl::ObjectView<::fidl::WireTableFrame<
          ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>>&&
          frame)
      : frame_ptr_(std::move(frame)) {}
  ~ShouldNeverAppearInAnyBinding5() = default;
  ShouldNeverAppearInAnyBinding5(
      const ShouldNeverAppearInAnyBinding5& other) noexcept = default;
  ShouldNeverAppearInAnyBinding5& operator=(
      const ShouldNeverAppearInAnyBinding5& other) noexcept = default;
  ShouldNeverAppearInAnyBinding5(
      ShouldNeverAppearInAnyBinding5&& other) noexcept = default;
  ShouldNeverAppearInAnyBinding5& operator=(
      ShouldNeverAppearInAnyBinding5&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding5Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr uint32_t MaxOutOfLineV1 = 24;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<
        ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>>(
        allocator);
  }
  void Init(
      ::fidl::ObjectView<::fidl::WireTableFrame<
          ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>>&&
          frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<
      ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>>
      frame_ptr_;
};

}  // namespace wire
}  // namespace test_bindingsdenylist
template <>
struct ::fidl::WireTableFrame<
    ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>
    final {
 public:
  WireTableFrame() = default;
  // In its intended usage, WireTableFrame will be referenced by an ObjectView.
  // If the ObjectView is assigned before a move or copy, then it will reference
  // the old invalid object. Because this is unsafe, copies are disallowed and
  // moves are only allowed by friend classes that operate safely.
  WireTableFrame(const WireTableFrame&) = delete;
  WireTableFrame& operator=(const WireTableFrame&) = delete;

 private:
  WireTableFrame(WireTableFrame&&) noexcept = default;
  WireTableFrame& operator=(WireTableFrame&&) noexcept = default;
  ::fidl::Envelope<bool> a_;

  friend class ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2;
};

namespace test_bindingsdenylist {
namespace wire {
extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding2Table;

class ShouldNeverAppearInAnyBinding2 final {
 public:
  // Returns whether no field is set.
  bool IsEmpty() const { return max_ordinal_ == 0; }

  const bool& a() const {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }
  bool& a() {
    ZX_ASSERT(has_a());
    return frame_ptr_->a_.get_data();
  }
  bool has_a() const { return max_ordinal_ >= 1 && frame_ptr_->a_.has_data(); }
  ShouldNeverAppearInAnyBinding2& set_a(bool elem) {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.set_data(std::move(elem));
    max_ordinal_ = std::max(max_ordinal_, static_cast<uint64_t>(1));
    return *this;
  }

  ShouldNeverAppearInAnyBinding2& clear_a() {
    ZX_DEBUG_ASSERT(frame_ptr_ != nullptr);
    frame_ptr_->a_.clear_data();
    return *this;
  }

  ShouldNeverAppearInAnyBinding2() = default;
  explicit ShouldNeverAppearInAnyBinding2(::fidl::AnyArena& allocator)
      : frame_ptr_(
            ::fidl::ObjectView<::fidl::WireTableFrame<
                ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>>(
                allocator)) {}
  // This constructor allows a user controlled allocation (not using a Arena).
  // It should only be used when performance is key.
  // As soon as the frame is given to the table, it must not be used directly or
  // for another table.
  explicit ShouldNeverAppearInAnyBinding2(
      ::fidl::ObjectView<::fidl::WireTableFrame<
          ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>>&&
          frame)
      : frame_ptr_(std::move(frame)) {}
  ~ShouldNeverAppearInAnyBinding2() = default;
  ShouldNeverAppearInAnyBinding2(
      const ShouldNeverAppearInAnyBinding2& other) noexcept = default;
  ShouldNeverAppearInAnyBinding2& operator=(
      const ShouldNeverAppearInAnyBinding2& other) noexcept = default;
  ShouldNeverAppearInAnyBinding2(
      ShouldNeverAppearInAnyBinding2&& other) noexcept = default;
  ShouldNeverAppearInAnyBinding2& operator=(
      ShouldNeverAppearInAnyBinding2&& other) noexcept = default;

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding2Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr uint32_t MaxOutOfLineV1 = 24;
  static constexpr bool HasPointer = true;

  void Allocate(::fidl::AnyArena& allocator) {
    max_ordinal_ = 0;
    frame_ptr_ = ::fidl::ObjectView<::fidl::WireTableFrame<
        ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>>(
        allocator);
  }
  void Init(
      ::fidl::ObjectView<::fidl::WireTableFrame<
          ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>>&&
          frame_ptr) {
    max_ordinal_ = 0;
    frame_ptr_ = std::move(frame_ptr);
  }

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  uint64_t max_ordinal_ = 0;
  ::fidl::ObjectView<::fidl::WireTableFrame<
      ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>>
      frame_ptr_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding9Table;

class ShouldNeverAppearInAnyBinding9 {
 public:
  ShouldNeverAppearInAnyBinding9()
      : ordinal_(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  ShouldNeverAppearInAnyBinding9(const ShouldNeverAppearInAnyBinding9&) =
      default;
  ShouldNeverAppearInAnyBinding9& operator=(
      const ShouldNeverAppearInAnyBinding9&) = default;
  ShouldNeverAppearInAnyBinding9(ShouldNeverAppearInAnyBinding9&&) = default;
  ShouldNeverAppearInAnyBinding9& operator=(ShouldNeverAppearInAnyBinding9&&) =
      default;

  enum class Tag : fidl_xunion_tag_t {
    kA = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           ShouldNeverAppearInAnyBinding9::Ordinal::Invalid;
  }

  bool is_a() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           ShouldNeverAppearInAnyBinding9::Ordinal::kA;
  }
  static ShouldNeverAppearInAnyBinding9 WithA(bool val) {
    ShouldNeverAppearInAnyBinding9 result;
    result.set_a(std::move(val));
    return result;
  }

  void set_a(bool elem) {
    ordinal_ = ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9::
        Ordinal::kA;
    envelope_.As<bool>().set_data(std::move(elem));
  }

  bool& mutable_a() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              ShouldNeverAppearInAnyBinding9::Ordinal::kA);
    return envelope_.As<bool>().get_data();
  }
  const bool& a() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              ShouldNeverAppearInAnyBinding9::Ordinal::kA);
    return envelope_.As<bool>().get_data();
  }
  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9::Tag which()
      const;

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding9Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kA = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding6Table;

class ShouldNeverAppearInAnyBinding6 {
 public:
  ShouldNeverAppearInAnyBinding6()
      : ordinal_(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  ShouldNeverAppearInAnyBinding6(const ShouldNeverAppearInAnyBinding6&) =
      default;
  ShouldNeverAppearInAnyBinding6& operator=(
      const ShouldNeverAppearInAnyBinding6&) = default;
  ShouldNeverAppearInAnyBinding6(ShouldNeverAppearInAnyBinding6&&) = default;
  ShouldNeverAppearInAnyBinding6& operator=(ShouldNeverAppearInAnyBinding6&&) =
      default;

  enum class Tag : fidl_xunion_tag_t {
    kA = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           ShouldNeverAppearInAnyBinding6::Ordinal::Invalid;
  }

  bool is_a() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           ShouldNeverAppearInAnyBinding6::Ordinal::kA;
  }
  static ShouldNeverAppearInAnyBinding6 WithA(bool val) {
    ShouldNeverAppearInAnyBinding6 result;
    result.set_a(std::move(val));
    return result;
  }

  void set_a(bool elem) {
    ordinal_ = ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6::
        Ordinal::kA;
    envelope_.As<bool>().set_data(std::move(elem));
  }

  bool& mutable_a() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              ShouldNeverAppearInAnyBinding6::Ordinal::kA);
    return envelope_.As<bool>().get_data();
  }
  const bool& a() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              ShouldNeverAppearInAnyBinding6::Ordinal::kA);
    return envelope_.As<bool>().get_data();
  }
  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6::Tag which()
      const;

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding6Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kA = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t test_bindingsdenylist_Allowed_Denied_ResultTable;

class AllowedDeniedResult {
 public:
  using Response = test_bindingsdenylist::wire::AllowedDeniedResponse;

  AllowedDeniedResult()
      : ordinal_(::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::
                     Invalid),
        envelope_ {}
  {}

  AllowedDeniedResult(const AllowedDeniedResult&) = default;
  AllowedDeniedResult& operator=(const AllowedDeniedResult&) = default;
  AllowedDeniedResult(AllowedDeniedResult&&) = default;
  AllowedDeniedResult& operator=(AllowedDeniedResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ == ::test_bindingsdenylist::wire::AllowedDeniedResult::
                           Ordinal::kResponse;
  }
  static AllowedDeniedResult WithResponse(
      ::fidl::ObjectView<::test_bindingsdenylist::wire::AllowedDeniedResponse>
          val) {
    AllowedDeniedResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static AllowedDeniedResult WithResponse(::fidl::AnyArena& allocator,
                                          Args&&... args) {
    AllowedDeniedResult result;
    result.set_response(::fidl::ObjectView<
                        ::test_bindingsdenylist::wire::AllowedDeniedResponse>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<::test_bindingsdenylist::wire::AllowedDeniedResponse>
          elem) {
    ordinal_ =
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kResponse;
    envelope_.As<::test_bindingsdenylist::wire::AllowedDeniedResponse>()
        .set_data(std::move(elem));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ =
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kResponse;
    set_response(::fidl::ObjectView<
                 ::test_bindingsdenylist::wire::AllowedDeniedResponse>(
        allocator, std::forward<Args>(args)...));
  }

  ::test_bindingsdenylist::wire::AllowedDeniedResponse& mutable_response() {
    ZX_ASSERT(
        ordinal_ ==
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kResponse);
    return envelope_.As<::test_bindingsdenylist::wire::AllowedDeniedResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::AllowedDeniedResponse& response() const {
    ZX_ASSERT(
        ordinal_ ==
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kResponse);
    return envelope_.As<::test_bindingsdenylist::wire::AllowedDeniedResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kErr;
  }
  static AllowedDeniedResult WithErr(uint32_t val) {
    AllowedDeniedResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ =
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(
        ordinal_ ==
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(
        ordinal_ ==
        ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::AllowedDeniedResult::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::AllowedDeniedResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_Allowed_Denied_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 48;
  static constexpr uint32_t MaxOutOfLineV1 = 80;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::AllowedDeniedResult::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_ShouldNeverAppearInAnyBinding3Table;

class ShouldNeverAppearInAnyBinding3 {
 public:
  ShouldNeverAppearInAnyBinding3()
      : ordinal_(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3::
                     Ordinal::Invalid),
        envelope_ {}
  {}

  ShouldNeverAppearInAnyBinding3(const ShouldNeverAppearInAnyBinding3&) =
      default;
  ShouldNeverAppearInAnyBinding3& operator=(
      const ShouldNeverAppearInAnyBinding3&) = default;
  ShouldNeverAppearInAnyBinding3(ShouldNeverAppearInAnyBinding3&&) = default;
  ShouldNeverAppearInAnyBinding3& operator=(ShouldNeverAppearInAnyBinding3&&) =
      default;

  enum class Tag : fidl_xunion_tag_t {
    kA = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           ShouldNeverAppearInAnyBinding3::Ordinal::Invalid;
  }

  bool is_a() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           ShouldNeverAppearInAnyBinding3::Ordinal::kA;
  }
  static ShouldNeverAppearInAnyBinding3 WithA(bool val) {
    ShouldNeverAppearInAnyBinding3 result;
    result.set_a(std::move(val));
    return result;
  }

  void set_a(bool elem) {
    ordinal_ = ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3::
        Ordinal::kA;
    envelope_.As<bool>().set_data(std::move(elem));
  }

  bool& mutable_a() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              ShouldNeverAppearInAnyBinding3::Ordinal::kA);
    return envelope_.As<bool>().get_data();
  }
  const bool& a() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              ShouldNeverAppearInAnyBinding3::Ordinal::kA);
    return envelope_.As<bool>().get_data();
  }
  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3::Tag which()
      const;

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_ShouldNeverAppearInAnyBinding3Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kA = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t test_bindingsdenylist_OnlyLlcppTable;

class OnlyLlcpp {
 public:
  OnlyLlcpp()
      : ordinal_(::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::Invalid),
        envelope_ {}
  {}

  OnlyLlcpp(const OnlyLlcpp&) = default;
  OnlyLlcpp& operator=(const OnlyLlcpp&) = default;
  OnlyLlcpp(OnlyLlcpp&&) = default;
  OnlyLlcpp& operator=(OnlyLlcpp&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::Invalid;
  }

  bool is_x() const {
    return ordinal_ == ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX;
  }
  static OnlyLlcpp WithX(uint32_t val) {
    OnlyLlcpp result;
    result.set_x(std::move(val));
    return result;
  }

  void set_x(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_x() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& x() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal::kX);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::OnlyLlcpp::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::OnlyLlcpp::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_OnlyLlcppTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kX = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::OnlyLlcpp::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResultTable;

class DenyEachBindingOnlyDenySyzkallerResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse;

  DenyEachBindingOnlyDenySyzkallerResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenySyzkallerResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenySyzkallerResult(
      const DenyEachBindingOnlyDenySyzkallerResult&) = default;
  DenyEachBindingOnlyDenySyzkallerResult& operator=(
      const DenyEachBindingOnlyDenySyzkallerResult&) = default;
  DenyEachBindingOnlyDenySyzkallerResult(
      DenyEachBindingOnlyDenySyzkallerResult&&) = default;
  DenyEachBindingOnlyDenySyzkallerResult& operator=(
      DenyEachBindingOnlyDenySyzkallerResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenySyzkallerResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse
          val) {
    DenyEachBindingOnlyDenySyzkallerResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse
          elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenySyzkallerResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenySyzkallerResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenySyzkallerResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenySyzkallerResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenySyzkallerResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Tag
  which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenySyzkallerResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenySyzkaller_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResultTable;

class DenyEachBindingOnlyDenyRustResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse;

  DenyEachBindingOnlyDenyRustResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyRustResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyRustResult(const DenyEachBindingOnlyDenyRustResult&) =
      default;
  DenyEachBindingOnlyDenyRustResult& operator=(
      const DenyEachBindingOnlyDenyRustResult&) = default;
  DenyEachBindingOnlyDenyRustResult(DenyEachBindingOnlyDenyRustResult&&) =
      default;
  DenyEachBindingOnlyDenyRustResult& operator=(
      DenyEachBindingOnlyDenyRustResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyRustResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::
               Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyRustResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse val) {
    DenyEachBindingOnlyDenyRustResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyRustResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyRustResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyRustResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyRustResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyRustResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyRustResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyRustResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyRustResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyRustResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyRustResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyRust_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResultTable;

class DenyEachBindingOnlyDenyLibfuzzerResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse;

  DenyEachBindingOnlyDenyLibfuzzerResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyLibfuzzerResult(
      const DenyEachBindingOnlyDenyLibfuzzerResult&) = default;
  DenyEachBindingOnlyDenyLibfuzzerResult& operator=(
      const DenyEachBindingOnlyDenyLibfuzzerResult&) = default;
  DenyEachBindingOnlyDenyLibfuzzerResult(
      DenyEachBindingOnlyDenyLibfuzzerResult&&) = default;
  DenyEachBindingOnlyDenyLibfuzzerResult& operator=(
      DenyEachBindingOnlyDenyLibfuzzerResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyLibfuzzerResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse
          val) {
    DenyEachBindingOnlyDenyLibfuzzerResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse
          elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyLibfuzzerResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyLibfuzzerResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyLibfuzzerResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::
               DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyLibfuzzerResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyLibfuzzerResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult::Tag
  which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyLibfuzzerResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyLibfuzzer_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResultTable;

class DenyEachBindingOnlyDenyGoResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse;

  DenyEachBindingOnlyDenyGoResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyGoResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyGoResult(const DenyEachBindingOnlyDenyGoResult&) =
      default;
  DenyEachBindingOnlyDenyGoResult& operator=(
      const DenyEachBindingOnlyDenyGoResult&) = default;
  DenyEachBindingOnlyDenyGoResult(DenyEachBindingOnlyDenyGoResult&&) = default;
  DenyEachBindingOnlyDenyGoResult& operator=(
      DenyEachBindingOnlyDenyGoResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyGoResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyGoResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyGoResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse val) {
    DenyEachBindingOnlyDenyGoResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
        Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyGoResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyGoResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyGoResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::
        Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyGoResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyGoResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyGo_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResultTable;

class DenyEachBindingOnlyDenyDartResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse;

  DenyEachBindingOnlyDenyDartResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyDartResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyDartResult(const DenyEachBindingOnlyDenyDartResult&) =
      default;
  DenyEachBindingOnlyDenyDartResult& operator=(
      const DenyEachBindingOnlyDenyDartResult&) = default;
  DenyEachBindingOnlyDenyDartResult(DenyEachBindingOnlyDenyDartResult&&) =
      default;
  DenyEachBindingOnlyDenyDartResult& operator=(
      DenyEachBindingOnlyDenyDartResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyDartResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::
               Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyDartResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse val) {
    DenyEachBindingOnlyDenyDartResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyDartResult::Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyDartResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyDartResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::
                DenyEachBindingOnlyDenyDartResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyDartResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyDartResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyDartResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::
        DenyEachBindingOnlyDenyDartResult::Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyDartResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyDartResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyDart_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_bindingsdenylist_DenyEachBinding_OnlyDenyCpp_ResultTable;

class DenyEachBindingOnlyDenyCppResult {
 public:
  using Response =
      test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse;

  DenyEachBindingOnlyDenyCppResult()
      : ordinal_(::test_bindingsdenylist::wire::
                     DenyEachBindingOnlyDenyCppResult::Ordinal::Invalid),
        envelope_ {}
  {}

  DenyEachBindingOnlyDenyCppResult(const DenyEachBindingOnlyDenyCppResult&) =
      default;
  DenyEachBindingOnlyDenyCppResult& operator=(
      const DenyEachBindingOnlyDenyCppResult&) = default;
  DenyEachBindingOnlyDenyCppResult(DenyEachBindingOnlyDenyCppResult&&) =
      default;
  DenyEachBindingOnlyDenyCppResult& operator=(
      DenyEachBindingOnlyDenyCppResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyCppResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyCppResult::Ordinal::kResponse;
  }
  static DenyEachBindingOnlyDenyCppResult WithResponse(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse val) {
    DenyEachBindingOnlyDenyCppResult result;
    result.set_response(std::move(val));
    return result;
  }

  void set_response(
      ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse elem) {
    ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::
        Ordinal::kResponse;
    envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse>()
        .set_data(std::move(elem));
  }

  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse>()
        .get_data();
  }
  const ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_bindingsdenylist::wire::
                           DenyEachBindingOnlyDenyCppResult::Ordinal::kErr;
  }
  static DenyEachBindingOnlyDenyCppResult WithErr(uint32_t val) {
    DenyEachBindingOnlyDenyCppResult result;
    result.set_err(std::move(val));
    return result;
  }

  void set_err(uint32_t elem) {
    ordinal_ = ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::
        Ordinal::kErr;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyCppResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_bindingsdenylist::wire::
                              DenyEachBindingOnlyDenyCppResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::Tag which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_DenyEachBinding_OnlyDenyCpp_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t PrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t MaxOutOfLineV1 = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

constexpr uint32_t kAllBindings = 0u;

extern "C" const fidl_type_t test_bindingsdenylist_Allowed_Denied_ResponseTable;

struct AllowedDeniedResponse {
  static constexpr const fidl_type_t* Type =
      &test_bindingsdenylist_Allowed_Denied_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  static constexpr uint32_t PrimarySizeV1 = 48;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr uint32_t MaxOutOfLineV1 = 32;
  static constexpr bool HasPointer = true;
  using ShouldNeverAppearInAnyBinding6 =
      test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6;
  using ShouldNeverAppearInAnyBinding5 =
      test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5;
  using ShouldNeverAppearInAnyBinding4 =
      test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4;

  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4
      should_never_appear_in_any_binding_4 = {};

  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5
      should_never_appear_in_any_binding_5 = {};

  ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6
      should_never_appear_in_any_binding_6 = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

}  // namespace wire
}  // namespace test_bindingsdenylist
namespace fidl {

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding7>
    : public std::true_type {};
template <>
struct IsStruct<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding7>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding7>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding7,
             a) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding7) ==
    ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding7::PrimarySize);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4>
    : public std::true_type {};
template <>
struct IsStruct<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4,
             a) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4) ==
    ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding4::PrimarySize);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::AllowedDeniedResponse>
    : public std::true_type {};
template <>
struct IsStruct<::test_bindingsdenylist::wire::AllowedDeniedResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::AllowedDeniedResponse>);
static_assert(offsetof(::test_bindingsdenylist::wire::AllowedDeniedResponse,
                       should_never_appear_in_any_binding_4) == 0);
static_assert(offsetof(::test_bindingsdenylist::wire::AllowedDeniedResponse,
                       should_never_appear_in_any_binding_5) == 8);
static_assert(offsetof(::test_bindingsdenylist::wire::AllowedDeniedResponse,
                       should_never_appear_in_any_binding_6) == 24);
static_assert(
    sizeof(::test_bindingsdenylist::wire::AllowedDeniedResponse) ==
    ::test_bindingsdenylist::wire::AllowedDeniedResponse::PrimarySize);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding1>
    : public std::true_type {};
template <>
struct IsStruct<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding1>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding1>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding1,
             a) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding1) ==
    ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding1::PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary,
             a) == 0);
static_assert(
    sizeof(
        ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary) ==
    ::test_bindingsdenylist::wire::MemberOnlyAppearsInImportingLibrary::
        PrimarySize);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>
    : public std::true_type {};
template <>
struct IsStruct<::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary,
             member_only_appears_in_importing_library) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary) ==
    ::test_bindingsdenylist::wire::OnlyAppearsInImportingLibrary::PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_bindingsdenylist::wire::
                                  DenyEachBindingOnlyDenySyzkallerResponse>);
static_assert(
    offsetof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResponse,
        b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::
                         DenyEachBindingOnlyDenySyzkallerResponse) ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenySyzkallerResponse::PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse,
             b) == 0);
static_assert(
    sizeof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse) ==
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResponse::
        PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_bindingsdenylist::wire::
                                  DenyEachBindingOnlyDenyLibfuzzerResponse>);
static_assert(
    offsetof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResponse,
        b) == 0);
static_assert(sizeof(::test_bindingsdenylist::wire::
                         DenyEachBindingOnlyDenyLibfuzzerResponse) ==
              ::test_bindingsdenylist::wire::
                  DenyEachBindingOnlyDenyLibfuzzerResponse::PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse,
             b) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse) ==
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResponse::
        PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse,
             b) == 0);
static_assert(
    sizeof(
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse) ==
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResponse::
        PrimarySize);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse>);
static_assert(
    offsetof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse,
             b) == 0);
static_assert(
    sizeof(::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse) ==
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResponse::
        PrimarySize);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>
    : public std::true_type {};
template <>
struct IsTable<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding8>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>
    : public std::true_type {};
template <>
struct IsTable<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding5>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>
    : public std::true_type {};
template <>
struct IsTable<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding2>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding9>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding6>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::AllowedDeniedResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::AllowedDeniedResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::AllowedDeniedResult>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::ShouldNeverAppearInAnyBinding3>);

template <>
struct IsFidlType<::test_bindingsdenylist::wire::OnlyLlcpp>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::OnlyLlcpp>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_bindingsdenylist::wire::OnlyLlcpp>);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenySyzkallerResult>);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyRustResult>);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyLibfuzzerResult>);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyGoResult>);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyDartResult>);

template <>
struct IsFidlType<
    ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_bindingsdenylist::wire::DenyEachBindingOnlyDenyCppResult>);

}  // namespace fidl
