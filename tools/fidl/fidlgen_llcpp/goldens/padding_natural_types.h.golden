// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.padding/cpp/common_types.h>
#include <fidl/test.padding/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/internal/codable_base.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_padding {
class Padding7ByteMiddle;

class Padding7ByteEnd;

class Padding6ByteMiddle;

class Padding6ByteEnd;

class Padding5ByteMiddle;

class Padding5ByteEnd;

class Padding4ByteMiddle;

class Padding4ByteEnd;

class Padding4ByteAlignmentLength12;

class Padding3ByteMiddle;

class Padding3ByteEnd;

class Padding2ByteMiddle;

class Padding2ByteEnd;

class Padding2ByteAlignmentLength6;

class Padding1ByteMiddle;

class Padding1ByteEnd;

extern "C" const fidl_type_t test_padding_Padding7ByteMiddleTable;

class Padding7ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding7ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding7ByteMiddle>;
  friend ::fidl::CodingTraits<Padding7ByteMiddle>;
  Padding7ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t a{};
    uint64_t b{};
  };

  Padding7ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding7ByteMiddle(uint8_t a, uint64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding7ByteMiddle() : Padding7ByteMiddle(Storage{}) {}

  Padding7ByteMiddle(Padding7ByteMiddle&&) noexcept = default;
  Padding7ByteMiddle& operator=(Padding7ByteMiddle&&) noexcept = default;
  Padding7ByteMiddle(const Padding7ByteMiddle& other) noexcept
      : Padding7ByteMiddle(other.CloneStorage()) {}
  Padding7ByteMiddle& operator=(const Padding7ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint64_t b() const { return storage_.b; }

  uint64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding7ByteEndTable;

class Padding7ByteEnd final
    : public ::fidl::internal::CodableBase<Padding7ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding7ByteEnd>;
  friend ::fidl::CodingTraits<Padding7ByteEnd>;
  Padding7ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint64_t a{};
    uint8_t b{};
  };

  Padding7ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding7ByteEnd(uint64_t a, uint8_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding7ByteEnd() : Padding7ByteEnd(Storage{}) {}

  Padding7ByteEnd(Padding7ByteEnd&&) noexcept = default;
  Padding7ByteEnd& operator=(Padding7ByteEnd&&) noexcept = default;
  Padding7ByteEnd(const Padding7ByteEnd& other) noexcept
      : Padding7ByteEnd(other.CloneStorage()) {}
  Padding7ByteEnd& operator=(const Padding7ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding6ByteMiddleTable;

class Padding6ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding6ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding6ByteMiddle>;
  friend ::fidl::CodingTraits<Padding6ByteMiddle>;
  Padding6ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint16_t a{};
    uint64_t b{};
  };

  Padding6ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding6ByteMiddle(uint16_t a, uint64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding6ByteMiddle() : Padding6ByteMiddle(Storage{}) {}

  Padding6ByteMiddle(Padding6ByteMiddle&&) noexcept = default;
  Padding6ByteMiddle& operator=(Padding6ByteMiddle&&) noexcept = default;
  Padding6ByteMiddle(const Padding6ByteMiddle& other) noexcept
      : Padding6ByteMiddle(other.CloneStorage()) {}
  Padding6ByteMiddle& operator=(const Padding6ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint64_t b() const { return storage_.b; }

  uint64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding6ByteEndTable;

class Padding6ByteEnd final
    : public ::fidl::internal::CodableBase<Padding6ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding6ByteEnd>;
  friend ::fidl::CodingTraits<Padding6ByteEnd>;
  Padding6ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint64_t a{};
    uint16_t b{};
  };

  Padding6ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding6ByteEnd(uint64_t a, uint16_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding6ByteEnd() : Padding6ByteEnd(Storage{}) {}

  Padding6ByteEnd(Padding6ByteEnd&&) noexcept = default;
  Padding6ByteEnd& operator=(Padding6ByteEnd&&) noexcept = default;
  Padding6ByteEnd(const Padding6ByteEnd& other) noexcept
      : Padding6ByteEnd(other.CloneStorage()) {}
  Padding6ByteEnd& operator=(const Padding6ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding5ByteMiddleTable;

class Padding5ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding5ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding5ByteMiddle>;
  friend ::fidl::CodingTraits<Padding5ByteMiddle>;
  Padding5ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint16_t a{};
    uint8_t b{};
    uint64_t c{};
  };

  Padding5ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding5ByteMiddle(uint16_t a, uint8_t b, uint64_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  Padding5ByteMiddle() : Padding5ByteMiddle(Storage{}) {}

  Padding5ByteMiddle(Padding5ByteMiddle&&) noexcept = default;
  Padding5ByteMiddle& operator=(Padding5ByteMiddle&&) noexcept = default;
  Padding5ByteMiddle(const Padding5ByteMiddle& other) noexcept
      : Padding5ByteMiddle(other.CloneStorage()) {}
  Padding5ByteMiddle& operator=(const Padding5ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

  uint64_t c() const { return storage_.c; }

  uint64_t& c() { return storage_.c; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding5ByteEndTable;

class Padding5ByteEnd final
    : public ::fidl::internal::CodableBase<Padding5ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding5ByteEnd>;
  friend ::fidl::CodingTraits<Padding5ByteEnd>;
  Padding5ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint64_t a{};
    uint16_t b{};
    uint8_t c{};
  };

  Padding5ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding5ByteEnd(uint64_t a, uint16_t b, uint8_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  Padding5ByteEnd() : Padding5ByteEnd(Storage{}) {}

  Padding5ByteEnd(Padding5ByteEnd&&) noexcept = default;
  Padding5ByteEnd& operator=(Padding5ByteEnd&&) noexcept = default;
  Padding5ByteEnd(const Padding5ByteEnd& other) noexcept
      : Padding5ByteEnd(other.CloneStorage()) {}
  Padding5ByteEnd& operator=(const Padding5ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

  uint8_t c() const { return storage_.c; }

  uint8_t& c() { return storage_.c; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding4ByteMiddleTable;

class Padding4ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding4ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding4ByteMiddle>;
  friend ::fidl::CodingTraits<Padding4ByteMiddle>;
  Padding4ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint32_t a{};
    uint64_t b{};
  };

  Padding4ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding4ByteMiddle(uint32_t a, uint64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding4ByteMiddle() : Padding4ByteMiddle(Storage{}) {}

  Padding4ByteMiddle(Padding4ByteMiddle&&) noexcept = default;
  Padding4ByteMiddle& operator=(Padding4ByteMiddle&&) noexcept = default;
  Padding4ByteMiddle(const Padding4ByteMiddle& other) noexcept
      : Padding4ByteMiddle(other.CloneStorage()) {}
  Padding4ByteMiddle& operator=(const Padding4ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint64_t b() const { return storage_.b; }

  uint64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding4ByteEndTable;

class Padding4ByteEnd final
    : public ::fidl::internal::CodableBase<Padding4ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding4ByteEnd>;
  friend ::fidl::CodingTraits<Padding4ByteEnd>;
  Padding4ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint64_t a{};
    uint32_t b{};
  };

  Padding4ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding4ByteEnd(uint64_t a, uint32_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding4ByteEnd() : Padding4ByteEnd(Storage{}) {}

  Padding4ByteEnd(Padding4ByteEnd&&) noexcept = default;
  Padding4ByteEnd& operator=(Padding4ByteEnd&&) noexcept = default;
  Padding4ByteEnd(const Padding4ByteEnd& other) noexcept
      : Padding4ByteEnd(other.CloneStorage()) {}
  Padding4ByteEnd& operator=(const Padding4ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint64_t a() const { return storage_.a; }

  uint64_t& a() { return storage_.a; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding4ByteAlignmentLength12Table;

class Padding4ByteAlignmentLength12 final
    : public ::fidl::internal::CodableBase<Padding4ByteAlignmentLength12> {
 private:
  friend ::fidl::internal::CodableBase<Padding4ByteAlignmentLength12>;
  friend ::fidl::CodingTraits<Padding4ByteAlignmentLength12>;
  Padding4ByteAlignmentLength12(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint32_t a{};
    uint8_t b{};
    uint16_t c{};
    uint16_t d{};
  };

  Padding4ByteAlignmentLength12(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  Padding4ByteAlignmentLength12(uint32_t a, uint8_t b, uint16_t c,
                                uint16_t d) noexcept
      : storage_({.a = std::move(a),
                  .b = std::move(b),
                  .c = std::move(c),
                  .d = std::move(d)}) {}
  Padding4ByteAlignmentLength12() : Padding4ByteAlignmentLength12(Storage{}) {}

  Padding4ByteAlignmentLength12(Padding4ByteAlignmentLength12&&) noexcept =
      default;
  Padding4ByteAlignmentLength12& operator=(
      Padding4ByteAlignmentLength12&&) noexcept = default;
  Padding4ByteAlignmentLength12(
      const Padding4ByteAlignmentLength12& other) noexcept
      : Padding4ByteAlignmentLength12(other.CloneStorage()) {}
  Padding4ByteAlignmentLength12& operator=(
      const Padding4ByteAlignmentLength12& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

  uint16_t c() const { return storage_.c; }

  uint16_t& c() { return storage_.c; }

  uint16_t d() const { return storage_.d; }

  uint16_t& d() { return storage_.d; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding3ByteMiddleTable;

class Padding3ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding3ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding3ByteMiddle>;
  friend ::fidl::CodingTraits<Padding3ByteMiddle>;
  Padding3ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t a{};
    uint32_t b{};
  };

  Padding3ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding3ByteMiddle(uint8_t a, uint32_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding3ByteMiddle() : Padding3ByteMiddle(Storage{}) {}

  Padding3ByteMiddle(Padding3ByteMiddle&&) noexcept = default;
  Padding3ByteMiddle& operator=(Padding3ByteMiddle&&) noexcept = default;
  Padding3ByteMiddle(const Padding3ByteMiddle& other) noexcept
      : Padding3ByteMiddle(other.CloneStorage()) {}
  Padding3ByteMiddle& operator=(const Padding3ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding3ByteEndTable;

class Padding3ByteEnd final
    : public ::fidl::internal::CodableBase<Padding3ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding3ByteEnd>;
  friend ::fidl::CodingTraits<Padding3ByteEnd>;
  Padding3ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint32_t a{};
    uint8_t b{};
  };

  Padding3ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding3ByteEnd(uint32_t a, uint8_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding3ByteEnd() : Padding3ByteEnd(Storage{}) {}

  Padding3ByteEnd(Padding3ByteEnd&&) noexcept = default;
  Padding3ByteEnd& operator=(Padding3ByteEnd&&) noexcept = default;
  Padding3ByteEnd(const Padding3ByteEnd& other) noexcept
      : Padding3ByteEnd(other.CloneStorage()) {}
  Padding3ByteEnd& operator=(const Padding3ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding2ByteMiddleTable;

class Padding2ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding2ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding2ByteMiddle>;
  friend ::fidl::CodingTraits<Padding2ByteMiddle>;
  Padding2ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint16_t a{};
    uint32_t b{};
  };

  Padding2ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding2ByteMiddle(uint16_t a, uint32_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding2ByteMiddle() : Padding2ByteMiddle(Storage{}) {}

  Padding2ByteMiddle(Padding2ByteMiddle&&) noexcept = default;
  Padding2ByteMiddle& operator=(Padding2ByteMiddle&&) noexcept = default;
  Padding2ByteMiddle(const Padding2ByteMiddle& other) noexcept
      : Padding2ByteMiddle(other.CloneStorage()) {}
  Padding2ByteMiddle& operator=(const Padding2ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint32_t b() const { return storage_.b; }

  uint32_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding2ByteEndTable;

class Padding2ByteEnd final
    : public ::fidl::internal::CodableBase<Padding2ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding2ByteEnd>;
  friend ::fidl::CodingTraits<Padding2ByteEnd>;
  Padding2ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint32_t a{};
    uint16_t b{};
  };

  Padding2ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding2ByteEnd(uint32_t a, uint16_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding2ByteEnd() : Padding2ByteEnd(Storage{}) {}

  Padding2ByteEnd(Padding2ByteEnd&&) noexcept = default;
  Padding2ByteEnd& operator=(Padding2ByteEnd&&) noexcept = default;
  Padding2ByteEnd(const Padding2ByteEnd& other) noexcept
      : Padding2ByteEnd(other.CloneStorage()) {}
  Padding2ByteEnd& operator=(const Padding2ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint32_t a() const { return storage_.a; }

  uint32_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding2ByteAlignmentLength6Table;

class Padding2ByteAlignmentLength6 final
    : public ::fidl::internal::CodableBase<Padding2ByteAlignmentLength6> {
 private:
  friend ::fidl::internal::CodableBase<Padding2ByteAlignmentLength6>;
  friend ::fidl::CodingTraits<Padding2ByteAlignmentLength6>;
  Padding2ByteAlignmentLength6(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t a{};
    uint16_t b{};
    uint8_t c{};
  };

  Padding2ByteAlignmentLength6(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  Padding2ByteAlignmentLength6(uint8_t a, uint16_t b, uint8_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  Padding2ByteAlignmentLength6() : Padding2ByteAlignmentLength6(Storage{}) {}

  Padding2ByteAlignmentLength6(Padding2ByteAlignmentLength6&&) noexcept =
      default;
  Padding2ByteAlignmentLength6& operator=(
      Padding2ByteAlignmentLength6&&) noexcept = default;
  Padding2ByteAlignmentLength6(
      const Padding2ByteAlignmentLength6& other) noexcept
      : Padding2ByteAlignmentLength6(other.CloneStorage()) {}
  Padding2ByteAlignmentLength6& operator=(
      const Padding2ByteAlignmentLength6& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

  uint8_t c() const { return storage_.c; }

  uint8_t& c() { return storage_.c; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding1ByteMiddleTable;

class Padding1ByteMiddle final
    : public ::fidl::internal::CodableBase<Padding1ByteMiddle> {
 private:
  friend ::fidl::internal::CodableBase<Padding1ByteMiddle>;
  friend ::fidl::CodingTraits<Padding1ByteMiddle>;
  Padding1ByteMiddle(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t a{};
    uint16_t b{};
  };

  Padding1ByteMiddle(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding1ByteMiddle(uint8_t a, uint16_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding1ByteMiddle() : Padding1ByteMiddle(Storage{}) {}

  Padding1ByteMiddle(Padding1ByteMiddle&&) noexcept = default;
  Padding1ByteMiddle& operator=(Padding1ByteMiddle&&) noexcept = default;
  Padding1ByteMiddle(const Padding1ByteMiddle& other) noexcept
      : Padding1ByteMiddle(other.CloneStorage()) {}
  Padding1ByteMiddle& operator=(const Padding1ByteMiddle& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t a() const { return storage_.a; }

  uint8_t& a() { return storage_.a; }

  uint16_t b() const { return storage_.b; }

  uint16_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_padding_Padding1ByteEndTable;

class Padding1ByteEnd final
    : public ::fidl::internal::CodableBase<Padding1ByteEnd> {
 private:
  friend ::fidl::internal::CodableBase<Padding1ByteEnd>;
  friend ::fidl::CodingTraits<Padding1ByteEnd>;
  Padding1ByteEnd(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint16_t a{};
    uint8_t b{};
  };

  Padding1ByteEnd(Storage storage) noexcept : storage_(std::move(storage)) {}
  Padding1ByteEnd(uint16_t a, uint8_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  Padding1ByteEnd() : Padding1ByteEnd(Storage{}) {}

  Padding1ByteEnd(Padding1ByteEnd&&) noexcept = default;
  Padding1ByteEnd& operator=(Padding1ByteEnd&&) noexcept = default;
  Padding1ByteEnd(const Padding1ByteEnd& other) noexcept
      : Padding1ByteEnd(other.CloneStorage()) {}
  Padding1ByteEnd& operator=(const Padding1ByteEnd& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint16_t a() const { return storage_.a; }

  uint16_t& a() { return storage_.a; }

  uint8_t b() const { return storage_.b; }

  uint8_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

}  // namespace test_padding
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding7ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding7ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding7ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding7ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding7ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding7ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding7ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding7ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding7ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding7ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding7ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding7ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding7ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding7ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding6ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding6ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding6ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding6ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding6ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding6ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding6ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding6ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding6ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding6ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding6ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding6ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding6ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding6ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding5ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding5ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding5ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding5ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding5ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding5ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 2
                                                                           : 2;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.c, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding5ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 2);
    ::fidl::Decode(decoder, &value->storage_.c, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding5ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding5ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding5ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding5ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding5ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding5ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 10
                                                                           : 10;
    ::fidl::Encode(encoder, &value->storage_.c, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding5ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.c, offset + 10);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding4ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding4ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding4ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding4ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding4ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding4ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding4ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding4ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding4ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding4ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding4ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding4ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding4ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding4ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding4ByteAlignmentLength12Table;

template <>
struct IsFidlType<::test_padding::Padding4ByteAlignmentLength12>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_padding::Padding4ByteAlignmentLength12>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding4ByteAlignmentLength12Table;
};

template <>
struct CodingTraits<::test_padding::Padding4ByteAlignmentLength12> {
  static constexpr size_t inline_size_v1_no_ee = 12;
  static constexpr size_t inline_size_v2 = 12;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_padding::Padding4ByteAlignmentLength12* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 6
                                                                           : 6;
    ::fidl::Encode(encoder, &value->storage_.c, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.d, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding4ByteAlignmentLength12* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 4);
    ::fidl::Decode(decoder, &value->storage_.c, offset + 6);
    ::fidl::Decode(decoder, &value->storage_.d, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding3ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding3ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding3ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding3ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding3ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding3ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding3ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 4);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding3ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding3ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding3ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding3ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding3ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding3ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding3ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 4);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding2ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding2ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding2ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding2ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding2ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding2ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding2ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 4);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding2ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding2ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding2ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding2ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding2ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding2ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding2ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 4);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding2ByteAlignmentLength6Table;

template <>
struct IsFidlType<::test_padding::Padding2ByteAlignmentLength6>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_padding::Padding2ByteAlignmentLength6>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding2ByteAlignmentLength6Table;
};

template <>
struct CodingTraits<::test_padding::Padding2ByteAlignmentLength6> {
  static constexpr size_t inline_size_v1_no_ee = 6;
  static constexpr size_t inline_size_v2 = 6;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding2ByteAlignmentLength6* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 2
                                                                           : 2;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.c, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding2ByteAlignmentLength6* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 2);
    ::fidl::Decode(decoder, &value->storage_.c, offset + 4);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding1ByteMiddleTable;

template <>
struct IsFidlType<::test_padding::Padding1ByteMiddle> : public std::true_type {
};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding1ByteMiddle> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding1ByteMiddleTable;
};

template <>
struct CodingTraits<::test_padding::Padding1ByteMiddle> {
  static constexpr size_t inline_size_v1_no_ee = 4;
  static constexpr size_t inline_size_v2 = 4;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding1ByteMiddle* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 2
                                                                           : 2;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding1ByteMiddle* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 2);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_padding_Padding1ByteEndTable;

template <>
struct IsFidlType<::test_padding::Padding1ByteEnd> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_padding::Padding1ByteEnd> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_padding_Padding1ByteEndTable;
};

template <>
struct CodingTraits<::test_padding::Padding1ByteEnd> {
  static constexpr size_t inline_size_v1_no_ee = 4;
  static constexpr size_t inline_size_v2 = 4;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_padding::Padding1ByteEnd* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 2
                                                                           : 2;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_padding::Padding1ByteEnd* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 2);
  }
};
#endif  // __Fuchsia__

}  // namespace fidl
