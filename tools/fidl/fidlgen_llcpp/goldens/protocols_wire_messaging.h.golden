// WARNING: This file is machine generated by fidlgen.

  #pragma once

  #include <fidl/test.protocols/cpp/markers.h>
  #include <fidl/test.protocols/cpp/wire_types.h>

  #include <lib/fidl/llcpp/wire_messaging.h>

  
#ifdef __Fuchsia__

    #include <lib/fidl/llcpp/client.h>
    #include <lib/fidl/llcpp/connect_service.h>
    #include <lib/fidl/llcpp/server.h>
    #include <lib/fidl/llcpp/service_handler_interface.h>
    #include <lib/fidl/llcpp/sync_call.h>
  
#endif  // __Fuchsia__


  
    
  namespace test_protocols {
  class WithAndWithoutRequestResponse;
    
  
  class Transitional;
    
  
  class WithProtocolEnds;
    
  
  class MethodWithUnion;
    
  
  class ManyParameters;
    
  
  class HandleRightsProtocol;
    
  
  class WithErrorSyntax;
    
  
  class DiscoverableProtocol;
    
  
  class ChannelProtocol;
    

    
    
    
    
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
    
    
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final { static constexpr uint64_t value = 5413654872775949227lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final { static constexpr uint64_t value = 1631193469798418024lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final { static constexpr uint64_t value = 9037369643591427517lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final { static constexpr uint64_t value = 7326057319832554103lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final { static constexpr uint64_t value = 2877322062572412767lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final { static constexpr uint64_t value = 6417226585456833969lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final { static constexpr uint64_t value = 5397663296507358806lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final { static constexpr uint64_t value = 5811598563493228968lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithAndWithoutRequestResponse> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithAndWithoutRequestResponse> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final {

  
  WireRequest() = default;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {

  
  WireRequest() = default;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {

  
  WireResponse() = default;
};



template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final {

  
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseTopResponse {

  
  explicit WireResponse(::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseTopResponse base) : ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(std::move(base)) {}
  explicit WireResponse(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseTopResponse{ .ret = std::move(ret)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseNoRequestWithResponseTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> body;
  explicit TransactionalResponse(::fidl::StringView ret)
  : body(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(ret)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest {

  
  explicit WireRequest(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest base) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest(std::move(base)) {}
  explicit WireRequest(::fidl::StringView arg) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest{ .arg = std::move(arg)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestNoResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> body;
  explicit TransactionalRequest(::fidl::StringView arg)
  : body(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(arg)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {

  
  explicit WireRequest(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest base) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(std::move(base)) {}
  explicit WireRequest(::fidl::StringView arg) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest{ .arg = std::move(arg)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> body;
  explicit TransactionalRequest(::fidl::StringView arg)
  : body(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(arg)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {

  
  WireResponse() = default;
};



template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest {

  
  explicit WireRequest(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest base) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest(std::move(base)) {}
  explicit WireRequest(::fidl::StringView arg) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest{ .arg = std::move(arg)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> body;
  explicit TransactionalRequest(::fidl::StringView arg)
  : body(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(arg)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseTopResponse {

  
  explicit WireResponse(::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseTopResponse base) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(std::move(base)) {}
  explicit WireResponse(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseTopResponse{ .ret = std::move(ret)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseWithRequestWithResponseTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> body;
  explicit TransactionalResponse(::fidl::StringView ret)
  : body(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(ret)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

  template<>
  struct ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final {

    
    WireEvent() = default;
  };



  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

  template<>
  struct ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final : public ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest {

    
    explicit WireEvent(::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest base) : ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest(std::move(base)) {}
    explicit WireEvent(::fidl::StringView ret) : ::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest{ .ret = std::move(ret)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithAndWithoutRequestResponseOnWithResponseRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse> body;
    explicit TransactionalEvent(::fidl::StringView ret)
    : body(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>(ret)) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, ret) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>, arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, arg) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, ret) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>, header) == 0);

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 4294967295;
  static constexpr uint32_t kMaxOutOfLineV1 = 4294967295;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>, ret) == 0);
#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>> {
      ::fidl::internal::InlineMessageBuffer<16> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>> {
      ::fidl::internal::InlineMessageBuffer<16> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithAndWithoutRequestResponse> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithAndWithoutRequestResponse>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::WithAndWithoutRequestResponse> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::WithAndWithoutRequestResponse>> {
   public:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithAndWithoutRequestResponse> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& operator*() const { return value(); }
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& operator*() const { return value(); }
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>> decoded_;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void OnEmptyResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* event) = 0;
    virtual void OnWithResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void OnEmptyResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>* event) override {}
    void OnWithResponse(::fidl::WireEvent<::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithAndWithoutRequestResponse> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::WithAndWithoutRequestResponse>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> NoRequestNoResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(_client_end(), &_request);
    }

    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(_client_end(), &_request);
    }

    // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> WithRequestNoResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(_client_end(), &_request);
    }

    // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(_client_end(), &_request);
    }

    // Request is heap-allocated. Response is heap-allocated.
    ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
      return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> NoRequestNoResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> WithRequestNoResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse> _request{ arg };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> _request{ arg };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> _request{ arg };
      return ::fidl::WireUnownedResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithAndWithoutRequestResponse>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply();
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::StringView ret);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply();
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::StringView ret);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::StringView ret);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;


    using NoRequestNoResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;
    using NoRequestNoResponseRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  
  virtual void NoRequestNoResponse(
    NoRequestNoResponseRequestView request, NoRequestNoResponseCompleter::Sync& completer)= 0;

    using NoRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;
    using NoRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  
  virtual void NoRequestEmptyResponse(
    NoRequestEmptyResponseRequestView request, NoRequestEmptyResponseCompleter::Sync& completer)= 0;

    using NoRequestWithResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
    using NoRequestWithResponseRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  
  virtual void NoRequestWithResponse(
    NoRequestWithResponseRequestView request, NoRequestWithResponseCompleter::Sync& completer)= 0;

    using WithRequestNoResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
    using WithRequestNoResponseRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;

  
  virtual void WithRequestNoResponse(
    WithRequestNoResponseRequestView request, WithRequestNoResponseCompleter::Sync& completer)= 0;

    using WithRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;
    using WithRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>;

  
  virtual void WithRequestEmptyResponse(
    WithRequestEmptyResponseRequestView request, WithRequestEmptyResponseCompleter::Sync& completer)= 0;

    using WithRequestWithResponseCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
    using WithRequestWithResponseRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

  
  virtual void WithRequestWithResponse(
    WithRequestWithResponseRequestView request, WithRequestWithResponseCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;
    
    
    __LOCAL extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::Request> final { static constexpr uint64_t value = 5849263021838298888lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::OneWay> final { static constexpr uint64_t value = 4336658926562441191lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::Transitional::Event> final { static constexpr uint64_t value = 8507647465196374081lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::Transitional> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::Transitional> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::Transitional>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::Transitional>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::Transitional::Request> final : public ::test_protocols::wire::TransitionalRequestRequest {

  
  explicit WireRequest(::test_protocols::wire::TransitionalRequestRequest base) : ::test_protocols::wire::TransitionalRequestRequest(std::move(base)) {}
  explicit WireRequest(int64_t x) : ::test_protocols::wire::TransitionalRequestRequest{ .x = std::move(x)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::Transitional::Request>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::Transitional::Request> body;
  explicit TransactionalRequest(int64_t x)
  : body(::fidl::WireRequest<::test_protocols::Transitional::Request>(x)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::Transitional::Request>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::Transitional::Request>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::Transitional::Request> final : public ::test_protocols::wire::TransitionalRequestTopResponse {

  
  explicit WireResponse(::test_protocols::wire::TransitionalRequestTopResponse base) : ::test_protocols::wire::TransitionalRequestTopResponse(std::move(base)) {}
  explicit WireResponse(int64_t y) : ::test_protocols::wire::TransitionalRequestTopResponse{ .y = std::move(y)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalRequestTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::Transitional::Request> body;
  explicit TransactionalResponse(int64_t y)
  : body(::fidl::WireResponse<::test_protocols::Transitional::Request>(y)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::Transitional::OneWay> final : public ::test_protocols::wire::TransitionalOneWayRequest {

  
  explicit WireRequest(::test_protocols::wire::TransitionalOneWayRequest base) : ::test_protocols::wire::TransitionalOneWayRequest(std::move(base)) {}
  explicit WireRequest(int64_t x) : ::test_protocols::wire::TransitionalOneWayRequest{ .x = std::move(x)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::Transitional::OneWay>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalOneWayRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalOneWayRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::Transitional::OneWay> body;
  explicit TransactionalRequest(int64_t x)
  : body(::fidl::WireRequest<::test_protocols::Transitional::OneWay>(x)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

  template<>
  struct ::fidl::WireEvent<::test_protocols::Transitional::Event> final : public ::test_protocols::wire::TransitionalEventRequest {

    
    explicit WireEvent(::test_protocols::wire::TransitionalEventRequest base) : ::test_protocols::wire::TransitionalEventRequest(std::move(base)) {}
    explicit WireEvent(int64_t x) : ::test_protocols::wire::TransitionalEventRequest{ .x = std::move(x)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::Transitional::Event>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::TransitionalEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::Transitional::Event> body;
    explicit TransactionalEvent(int64_t x)
    : body(::fidl::WireEvent<::test_protocols::Transitional::Event>(x)) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::Transitional::Request>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::Transitional::Request,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::Transitional::Request,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::Transitional::Request>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::Transitional::Request>, x) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::Transitional::Request>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalRequestTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::Transitional::Request>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::Transitional::Request>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::Transitional::Request>, y) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::Transitional::OneWay>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::Transitional::OneWay>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::Transitional::OneWay>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::Transitional::OneWay>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::Transitional::OneWay>, x) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::Transitional::Event>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::Transitional::Event>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_TransitionalEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::Transitional::Event>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::Transitional::Event>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::Transitional::Event>, x) == 0);
#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::Transitional::Request>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::Transitional> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::Transitional>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::Transitional> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::Transitional>> {
   public:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::Transitional> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::Transitional::Request> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::Transitional::Request> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::Transitional::Request>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::Transitional::Request>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::Transitional::Request>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::Transitional::OneWay> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void Event(::fidl::WireEvent<::test_protocols::Transitional::Event>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void Event(::fidl::WireEvent<::test_protocols::Transitional::Event>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::Transitional>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;
        void Event(::fidl::WireEvent<::test_protocols::Transitional::Event>* event) override { OnTransitionalEvent_(); }

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::Transitional> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::Transitional>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::Transitional> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::Transitional>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::Transitional::Request> Request(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
      return ::fidl::WireResult<::test_protocols::Transitional::Request>(_client_end(), &_request);
    }

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::Transitional::OneWay> OneWay(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> _request{ x };
      return ::fidl::WireResult<::test_protocols::Transitional::OneWay>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::Transitional> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::Transitional>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::Transitional::Request> Request(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::Request> _request{ x };
      return ::fidl::WireUnownedResult<::test_protocols::Transitional::Request>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay> OneWay(int64_t x) {
      ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay> _request{ x };
      return ::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::Transitional> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::Transitional::Request> : public ::fidl::internal::CompleterImplBase<::test_protocols::Transitional::Request> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(int64_t y);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::Transitional::Request> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(int64_t y);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::Transitional::Request> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::Transitional::Request> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::Transitional> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;


    using RequestCompleter = ::fidl::internal::WireCompleter<::test_protocols::Transitional::Request>;
    using RequestRequestView = ::fidl::internal::WireRequestView<::test_protocols::Transitional::Request>;

  
  virtual void Request(
    RequestRequestView request, RequestCompleter::Sync& completer){ completer.Close(ZX_ERR_NOT_SUPPORTED); }

    using OneWayCompleter = ::fidl::internal::WireCompleter<::test_protocols::Transitional::OneWay>;
    using OneWayRequestView = ::fidl::internal::WireRequestView<::test_protocols::Transitional::OneWay>;

  
  virtual void OneWay(
    OneWayRequestView request, OneWayCompleter::Sync& completer){ completer.Close(ZX_ERR_NOT_SUPPORTED); }


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsClientEndsTopResponseTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsServerEndsTopResponseTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithProtocolEnds::ClientEnds> final { static constexpr uint64_t value = 5870448041025163330lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithProtocolEnds::ServerEnds> final { static constexpr uint64_t value = 8115535094437022259lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithProtocolEnds::StructContainingEnds> final { static constexpr uint64_t value = 4076866772260025813lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithProtocolEnds> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::test_protocols::wire::WithProtocolEndsClientEndsRequest {

  
  explicit WireRequest(::test_protocols::wire::WithProtocolEndsClientEndsRequest base) : ::test_protocols::wire::WithProtocolEndsClientEndsRequest(std::move(base)) {}
  explicit WireRequest(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) : ::test_protocols::wire::WithProtocolEndsClientEndsRequest{ .in = std::move(in)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds> body;
  explicit TransactionalRequest(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in)
  : body(::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>(std::move(in))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::test_protocols::wire::WithProtocolEndsClientEndsTopResponse {

  
  explicit WireResponse(::test_protocols::wire::WithProtocolEndsClientEndsTopResponse base) : ::test_protocols::wire::WithProtocolEndsClientEndsTopResponse(std::move(base)) {}
  explicit WireResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) : ::test_protocols::wire::WithProtocolEndsClientEndsTopResponse{ .out = std::move(out)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsClientEndsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds> body;
  explicit TransactionalResponse(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out)
  : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::test_protocols::wire::WithProtocolEndsServerEndsRequest {

  
  explicit WireRequest(::test_protocols::wire::WithProtocolEndsServerEndsRequest base) : ::test_protocols::wire::WithProtocolEndsServerEndsRequest(std::move(base)) {}
  explicit WireRequest(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) : ::test_protocols::wire::WithProtocolEndsServerEndsRequest{ .in = std::move(in)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds> body;
  explicit TransactionalRequest(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in)
  : body(::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>(std::move(in))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::test_protocols::wire::WithProtocolEndsServerEndsTopResponse {

  
  explicit WireResponse(::test_protocols::wire::WithProtocolEndsServerEndsTopResponse base) : ::test_protocols::wire::WithProtocolEndsServerEndsTopResponse(std::move(base)) {}
  explicit WireResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) : ::test_protocols::wire::WithProtocolEndsServerEndsTopResponse{ .out = std::move(out)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsServerEndsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds> body;
  explicit TransactionalResponse(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out)
  : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest {

  
  explicit WireRequest(::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest base) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest(std::move(base)) {}
  explicit WireRequest(::test_protocols::wire::ProtocolEnds&& in) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest{ .in = std::move(in)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> body;
  explicit TransactionalRequest(::test_protocols::wire::ProtocolEnds&& in)
  : body(::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>(std::move(in))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse {

  
  explicit WireResponse(::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse base) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::ProtocolEnds&& out) : ::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse{ .out = std::move(out)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithProtocolEndsStructContainingEndsTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds> body;
  explicit TransactionalResponse(::test_protocols::wire::ProtocolEnds&& out)
  : body(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>(std::move(out))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ClientEnds,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ClientEnds,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ServerEnds,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::ServerEnds,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::StructContainingEnds,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithProtocolEnds::StructContainingEnds,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::WithProtocolEnds::ClientEnds>, in) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsClientEndsTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, out) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::WithProtocolEnds::ServerEnds>, in) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsServerEndsTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, out) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>, in) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 4;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, out) == 0);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>> {
      ::fidl::internal::InlineMessageBuffer<32> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithProtocolEnds> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithProtocolEnds>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::WithProtocolEnds> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::WithProtocolEnds>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithProtocolEnds> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ClientEnds>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ClientEnds>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::ServerEnds>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::ServerEnds>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<32> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithProtocolEnds::StructContainingEnds>> decoded_;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithProtocolEnds> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithProtocolEnds>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::WithProtocolEnds>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::WithProtocolEnds>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
      return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
      return ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>(_client_end(), &_request);
    }

    // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
      return ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithProtocolEnds>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ClientEnds> _request{ std::move(in) };
      return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::ServerEnds> _request{ std::move(in) };
      return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithProtocolEnds::StructContainingEnds> _request{ std::move(in) };
      return ::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::StructContainingEnds>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::ProtocolEnds&& out);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::ProtocolEnds&& out);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithProtocolEnds::StructContainingEnds> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithProtocolEnds::StructContainingEnds> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::WithProtocolEnds> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;


    using ClientEndsCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ClientEnds>;
    using ClientEndsRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithProtocolEnds::ClientEnds>;

  
  virtual void ClientEnds(
    ClientEndsRequestView request, ClientEndsCompleter::Sync& completer)= 0;

    using ServerEndsCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::ServerEnds>;
    using ServerEndsRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithProtocolEnds::ServerEnds>;

  
  virtual void ServerEnds(
    ServerEndsRequestView request, ServerEndsCompleter::Sync& completer)= 0;

    using StructContainingEndsCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithProtocolEnds::StructContainingEnds>;
    using StructContainingEndsRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithProtocolEnds::StructContainingEnds>;

  
  virtual void StructContainingEnds(
    StructContainingEndsRequestView request, StructContainingEndsCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_MethodWithUnionUnionMethodTopResponseTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::MethodWithUnion::UnionMethod> final { static constexpr uint64_t value = 4124874338266649112lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::MethodWithUnion> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod> final : public ::test_protocols::wire::MethodWithUnionUnionMethodRequest {

  
  explicit WireRequest(::test_protocols::wire::MethodWithUnionUnionMethodRequest base) : ::test_protocols::wire::MethodWithUnionUnionMethodRequest(std::move(base)) {}
  explicit WireRequest(::test_protocols::wire::TheUnion u) : ::test_protocols::wire::MethodWithUnionUnionMethodRequest{ .u = std::move(u)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod> body;
  explicit TransactionalRequest(::test_protocols::wire::TheUnion u)
  : body(::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>(u)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod> final : public ::test_protocols::wire::MethodWithUnionUnionMethodTopResponse {

  
  explicit WireResponse(::test_protocols::wire::MethodWithUnionUnionMethodTopResponse base) : ::test_protocols::wire::MethodWithUnionUnionMethodTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::TheUnion u) : ::test_protocols::wire::MethodWithUnionUnionMethodTopResponse{ .u = std::move(u)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::MethodWithUnionUnionMethodTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod> body;
  explicit TransactionalResponse(::test_protocols::wire::TheUnion u)
  : body(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>(u)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::MethodWithUnion::UnionMethod> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::MethodWithUnion::UnionMethod,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::MethodWithUnion::UnionMethod,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::MethodWithUnion::UnionMethod>, u) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_MethodWithUnionUnionMethodTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = true;
  static constexpr bool kHasEnvelope = true;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, u) == 0);
#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>> {
      ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::MethodWithUnion> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::MethodWithUnion>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::MethodWithUnion> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::MethodWithUnion>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::MethodWithUnion> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& operator*() const { return value(); }
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::MethodWithUnion::UnionMethod>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::MethodWithUnion::UnionMethod>> decoded_;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::MethodWithUnion> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::MethodWithUnion>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::MethodWithUnion>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::MethodWithUnion> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::MethodWithUnion>> {
 public:
  
    // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
    ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u) {
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
      return ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::MethodWithUnion> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::MethodWithUnion>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u) {
      ::fidl::internal::TransactionalRequest<::test_protocols::MethodWithUnion::UnionMethod> _request{ u };
      return ::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::internal::CompleterImplBase<::test_protocols::MethodWithUnion::UnionMethod> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::TheUnion u);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::TheUnion u);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::MethodWithUnion::UnionMethod> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::MethodWithUnion::UnionMethod> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::MethodWithUnion> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;


    using UnionMethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::MethodWithUnion::UnionMethod>;
    using UnionMethodRequestView = ::fidl::internal::WireRequestView<::test_protocols::MethodWithUnion::UnionMethod>;

  
  virtual void UnionMethod(
    UnionMethodRequestView request, UnionMethodCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;
    
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ManyParameters::Fifteen> final { static constexpr uint64_t value = 6423043252952467815lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::ManyParameters> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen> final : public ::test_protocols::wire::ManyParametersFifteenRequest {

  
  explicit WireRequest(::test_protocols::wire::ManyParametersFifteenRequest base) : ::test_protocols::wire::ManyParametersFifteenRequest(std::move(base)) {}
  explicit WireRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) : ::test_protocols::wire::ManyParametersFifteenRequest{ .p1 = std::move(p1), .p2 = std::move(p2), .p3 = std::move(p3), .p4 = std::move(p4), .p5 = std::move(p5), .p6 = std::move(p6), .p7 = std::move(p7), .p8 = std::move(p8), .p9 = std::move(p9), .p10 = std::move(p10), .p11 = std::move(p11), .p12 = std::move(p12), .p13 = std::move(p13), .p14 = std::move(p14), .p15 = std::move(p15)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 15;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ManyParametersFifteenRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen> body;
  explicit TransactionalRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15)
  : body(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 15 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(15 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(15 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 15;
  static constexpr uint32_t kPrimarySizeV1 = 15;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p1) == 0);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p2) == 1);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p3) == 2);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p4) == 3);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p5) == 4);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p6) == 5);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p7) == 6);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p8) == 7);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p9) == 8);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p10) == 9);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p11) == 10);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p12) == 11);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p13) == 12);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p14) == 13);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ManyParameters::Fifteen>, p15) == 14);
#ifdef __Fuchsia__
}  // namespace fidl
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ManyParameters> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ManyParameters>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::ManyParameters> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::ManyParameters>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ManyParameters> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::ManyParameters>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::ManyParameters> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::ManyParameters>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::ManyParameters>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::ManyParameters> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::ManyParameters>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen> Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
      return ::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ManyParameters> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ManyParameters>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen> Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ManyParameters::Fifteen> _request{ p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15 };
      return ::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ManyParameters>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::ManyParameters> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;


    using FifteenCompleter = ::fidl::internal::WireCompleter<::test_protocols::ManyParameters::Fifteen>;
    using FifteenRequestView = ::fidl::internal::WireRequestView<::test_protocols::ManyParameters::Fifteen>;

  
  virtual void Fifteen(
    FifteenRequestView request, FifteenCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_HandleRightsProtocolAnEventRequestTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::HandleRightsProtocol::NoResponseMethod> final { static constexpr uint64_t value = 1155044649514904573lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::HandleRightsProtocol::ResponseMethod> final { static constexpr uint64_t value = 5956276128041940295lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::HandleRightsProtocol::AnEvent> final { static constexpr uint64_t value = 476727631355490611lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::HandleRightsProtocol> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::HandleRightsProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> final : public ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest {

  
  explicit WireRequest(::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest base) : ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest(std::move(base)) {}
  explicit WireRequest(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest{ .h = std::move(h)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolNoResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> body;
  explicit TransactionalRequest(::zx::socket&& h)
  : body(::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>(std::move(h))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest {

  
  explicit WireRequest(::test_protocols::wire::HandleRightsProtocolResponseMethodRequest base) : ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest(std::move(base)) {}
  explicit WireRequest(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolResponseMethodRequest{ .h = std::move(h)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> body;
  explicit TransactionalRequest(::zx::socket&& h)
  : body(::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>(std::move(h))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse {

  
  explicit WireResponse(::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse base) : ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse(std::move(base)) {}
  explicit WireResponse(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse{ .h = std::move(h)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolResponseMethodTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod> body;
  explicit TransactionalResponse(::zx::socket&& h)
  : body(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>(std::move(h))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


  template<>
  struct ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent> final : public ::test_protocols::wire::HandleRightsProtocolAnEventRequest {

    
    explicit WireEvent(::test_protocols::wire::HandleRightsProtocolAnEventRequest base) : ::test_protocols::wire::HandleRightsProtocolAnEventRequest(std::move(base)) {}
    explicit WireEvent(::zx::socket&& h) : ::test_protocols::wire::HandleRightsProtocolAnEventRequest{ .h = std::move(h)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::HandleRightsProtocolAnEventRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent> body;
    explicit TransactionalEvent(::zx::socket&& h)
    : body(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>(std::move(h))) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }
    void _CloseHandles() {
      body._CloseHandles();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::HandleRightsProtocol::ResponseMethod,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::HandleRightsProtocol::ResponseMethod,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>, h) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>, h) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, h) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::HandleRightsProtocol::AnEvent>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_HandleRightsProtocolAnEventRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>, h) == 0);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::HandleRightsProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::HandleRightsProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 1;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::HandleRightsProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::HandleRightsProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::HandleRightsProtocol> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::HandleRightsProtocol::ResponseMethod>> decoded_;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void AnEvent(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void AnEvent(::fidl::WireEvent<::test_protocols::HandleRightsProtocol::AnEvent>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::HandleRightsProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::HandleRightsProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::HandleRightsProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::HandleRightsProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::HandleRightsProtocol>> {
 public:
  
    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> NoResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
      return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
      return ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::HandleRightsProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::HandleRightsProtocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod> NoResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::NoResponseMethod> _request{ std::move(h) };
      return ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::HandleRightsProtocol::ResponseMethod> _request{ std::move(h) };
      return ::fidl::WireUnownedResult<::test_protocols::HandleRightsProtocol::ResponseMethod>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::internal::CompleterImplBase<::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::zx::socket&& h);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::zx::socket&& h);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::HandleRightsProtocol::ResponseMethod> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::HandleRightsProtocol::ResponseMethod> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;


    using NoResponseMethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::NoResponseMethod>;
    using NoResponseMethodRequestView = ::fidl::internal::WireRequestView<::test_protocols::HandleRightsProtocol::NoResponseMethod>;

  
  virtual void NoResponseMethod(
    NoResponseMethodRequestView request, NoResponseMethodCompleter::Sync& completer)= 0;

    using ResponseMethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::HandleRightsProtocol::ResponseMethod>;
    using ResponseMethodRequestView = ::fidl::internal::WireRequestView<::test_protocols::HandleRightsProtocol::ResponseMethod>;

  
  virtual void ResponseMethod(
    ResponseMethodRequestView request, ResponseMethodCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    
    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::ResponseAsStruct> final { static constexpr uint64_t value = 268248568430741139lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final { static constexpr uint64_t value = 6930994461233198567lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::ErrorAsEnum> final { static constexpr uint64_t value = 5491891352371277635lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::WithErrorSyntax::HandleInResult> final { static constexpr uint64_t value = 1371676333068455103lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::WithErrorSyntax> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> final {

  
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse base) : ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) : ::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxResponseAsStructTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final {

  
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse base) : ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) : ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {

  
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse base) : ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) : ::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxErrorAsEnumTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult> final {

  
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};
#ifdef __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse {
  using Result = test_protocols::wire::WithErrorSyntaxHandleInResultResult;

  
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse base) : ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse(std::move(base)) {}
  explicit WireResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) : ::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::WithErrorSyntaxHandleInResultTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult> body;
  explicit TransactionalResponse(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
  : body(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>(std::move(result))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct>>;

  
  using ApplicationError = uint32_t;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;

  
  using ApplicationError = uint32_t;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>>;

  
  using ApplicationError = ::test_protocols::wire::ErrorEnum;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult>>;

  
  using ApplicationError = uint32_t;
  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::HandleInResult,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::WithErrorSyntax::HandleInResult,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 24;
  static constexpr uint32_t kMaxOutOfLineV1 = 24;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(24 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 1;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, result) == 0);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>> {
      ::fidl::internal::InlineMessageBuffer<64> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>> {
      ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>> {
      ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>> {
      ::fidl::internal::InlineMessageBuffer<48> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithErrorSyntax> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithErrorSyntax>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::WithErrorSyntax> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::WithErrorSyntax>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::WithErrorSyntax> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& value() const { return *Unwrap(); }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<64> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> decoded_;
      std::optional<::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
      auto* raw_response = &decoded_.Value()->body;
      if (raw_response->result.is_err()) {
        result_ = fitx::error(raw_response->result.err());
      } else {
        result_ = fitx::ok(&(raw_response->result.response()));
      }
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
        auto* raw_response = &decoded_.Value()->body;
        if (raw_response->result.is_err()) {
          result_ = fitx::error(raw_response->result.err());
        } else if (raw_response->result.is_response()) {
          result_ = fitx::ok(&(raw_response->result.response()));
        }
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& value() const { return *Unwrap(); }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ResponseAsStruct>> decoded_;
      std::optional<::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<uint32_t>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<uint32_t>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& value() const { return *Unwrap(); }

    ::fitx::result<uint32_t>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<uint32_t>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<48> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> decoded_;
      std::optional<::fitx::result<uint32_t>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
      auto* raw_response = &decoded_.Value()->body;
      if (raw_response->result.is_err()) {
        result_ = fitx::error(raw_response->result.err());
      } else {
        result_ = fitx::ok();
      }
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
        auto* raw_response = &decoded_.Value()->body;
        if (raw_response->result.is_err()) {
          result_ = fitx::error(raw_response->result.err());
        } else if (raw_response->result.is_response()) {
          result_ = fitx::ok();
        }
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<uint32_t>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<uint32_t>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& value() const { return *Unwrap(); }

    ::fitx::result<uint32_t>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<uint32_t>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> decoded_;
      std::optional<::fitx::result<uint32_t>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<::test_protocols::wire::ErrorEnum>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<::test_protocols::wire::ErrorEnum>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& value() const { return *Unwrap(); }

    ::fitx::result<::test_protocols::wire::ErrorEnum>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<::test_protocols::wire::ErrorEnum>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<48> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> decoded_;
      std::optional<::fitx::result<::test_protocols::wire::ErrorEnum>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
      auto* raw_response = &decoded_.Value()->body;
      if (raw_response->result.is_err()) {
        result_ = fitx::error(raw_response->result.err());
      } else {
        result_ = fitx::ok();
      }
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
        auto* raw_response = &decoded_.Value()->body;
        if (raw_response->result.is_err()) {
          result_ = fitx::error(raw_response->result.err());
        } else if (raw_response->result.is_response()) {
          result_ = fitx::ok();
        }
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<::test_protocols::wire::ErrorEnum>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<::test_protocols::wire::ErrorEnum>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& value() const { return *Unwrap(); }

    ::fitx::result<::test_protocols::wire::ErrorEnum>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<::test_protocols::wire::ErrorEnum>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>> decoded_;
      std::optional<::fitx::result<::test_protocols::wire::ErrorEnum>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& value() const { return *Unwrap(); }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<48> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> decoded_;
      std::optional<::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>> result_ = std::nullopt;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
      auto* raw_response = &decoded_.Value()->body;
      if (raw_response->result.is_err()) {
        result_ = fitx::error(raw_response->result.err());
      } else {
        result_ = fitx::ok(&(raw_response->result.response()));
      }
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
        auto* raw_response = &decoded_.Value()->body;
        if (raw_response->result.is_err()) {
          result_ = fitx::error(raw_response->result.err());
        } else if (raw_response->result.is_response()) {
          result_ = fitx::ok(&(raw_response->result.response()));
        }
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>* Unwrap_NEW() {
        return &result_.value();
    }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>* Unwrap_NEW() const {
        return &result_.value();
    }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& value() const { return *Unwrap(); }

    ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>& value_NEW() { return *Unwrap_NEW(); }
    const ::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::WithErrorSyntax::HandleInResult>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::WithErrorSyntax::HandleInResult>> decoded_;
      std::optional<::fitx::result<uint32_t, ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>> result_ = std::nullopt;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::WithErrorSyntax> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::WithErrorSyntax>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::WithErrorSyntax>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::WithErrorSyntax>> {
 public:
  
    // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
      return ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::WithErrorSyntax>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ResponseAsStruct> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult() {
      ::fidl::internal::TransactionalRequest<::test_protocols::WithErrorSyntax::HandleInResult> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result);
  void ReplySuccess(int64_t a, int64_t b, int64_t c);
  void ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result);
  void ReplySuccess(int64_t a, int64_t b, int64_t c);
  void ReplyError(uint32_t error);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ResponseAsStruct> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ResponseAsStruct> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result);
  void ReplySuccess();
  void ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result);
  void ReplySuccess();
  void ReplyError(uint32_t error);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  void ReplySuccess();
  void ReplyError(::test_protocols::wire::ErrorEnum error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  void ReplySuccess();
  void ReplyError(::test_protocols::wire::ErrorEnum error);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::internal::CompleterImplBase<::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  void ReplySuccess(::zx::handle&& h);
  void ReplyError(uint32_t error);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  void ReplySuccess(::zx::handle&& h);
  void ReplyError(uint32_t error);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::WithErrorSyntax::HandleInResult> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::WithErrorSyntax> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;


    using ResponseAsStructCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ResponseAsStruct>;
    using ResponseAsStructRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  
  virtual void ResponseAsStruct(
    ResponseAsStructRequestView request, ResponseAsStructCompleter::Sync& completer)= 0;

    using ErrorAsPrimitiveCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
    using ErrorAsPrimitiveRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  
  virtual void ErrorAsPrimitive(
    ErrorAsPrimitiveRequestView request, ErrorAsPrimitiveCompleter::Sync& completer)= 0;

    using ErrorAsEnumCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::ErrorAsEnum>;
    using ErrorAsEnumRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  
  virtual void ErrorAsEnum(
    ErrorAsEnumRequestView request, ErrorAsEnumCompleter::Sync& completer)= 0;

    using HandleInResultCompleter = ::fidl::internal::WireCompleter<::test_protocols::WithErrorSyntax::HandleInResult>;
    using HandleInResultRequestView = ::fidl::internal::WireRequestView<::test_protocols::WithErrorSyntax::HandleInResult>;

  
  virtual void HandleInResult(
    HandleInResultRequestView request, HandleInResultCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    
    
}  // namespace fidl
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::DiscoverableProtocol::Method> final { static constexpr uint64_t value = 3455873048082739435lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::DiscoverableProtocol> {
    static constexpr char DiscoverableName[] = "test.protocols.DiscoverableProtocol";
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::DiscoverableProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method> final {

  
  WireRequest() = default;
};



template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};

namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>, header) == 0);

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
#ifdef __Fuchsia__
}  // namespace fidl
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::DiscoverableProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::DiscoverableProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::DiscoverableProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::DiscoverableProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::DiscoverableProtocol> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::DiscoverableProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::DiscoverableProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::DiscoverableProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::DiscoverableProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::DiscoverableProtocol>> {
 public:
  
    // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method> Method() {
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
      return ::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::DiscoverableProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::DiscoverableProtocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method> Method() {
      ::fidl::internal::TransactionalRequest<::test_protocols::DiscoverableProtocol::Method> _request{  };
      return ::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;


    using MethodCompleter = ::fidl::internal::WireCompleter<::test_protocols::DiscoverableProtocol::Method>;
    using MethodRequestView = ::fidl::internal::WireRequestView<::test_protocols::DiscoverableProtocol::Method>;

  
  virtual void Method(
    MethodRequestView request, MethodCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__

    

    }  // namespace fidl
namespace test_protocols {__LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;
    
    
    __LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBTopResponseTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolTakeHandleRequestTable;
    
    __LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketRequestTable;
    __LOCAL extern "C" const fidl_type_t test_protocols_ChannelProtocolMutateSocketTopResponseTable;
}  // namespace test_protocols
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MethodA> final { static constexpr uint64_t value = 3155008840945527714lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::EventA> final { static constexpr uint64_t value = 2220452875311597006lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MethodB> final { static constexpr uint64_t value = 8903004957800778182lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::TakeHandle> final { static constexpr uint64_t value = 591935489944717925lu; };
template<>
struct ::fidl::internal::WireOrdinal<::test_protocols::ChannelProtocol::MutateSocket> final { static constexpr uint64_t value = 7411742788430590287lu; };

namespace test_protocols {
}  // namespace test_protocols
#ifdef __Fuchsia__

template<>
struct ::fidl::internal::ProtocolDetails<::test_protocols::ChannelProtocol> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template<>
struct ::fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol> final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingMessage& msg,
                                            internal::MessageStorageViewBase* storage_view,
                                            ::fidl::Transaction* txn);
  static void Dispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl, ::fidl::IncomingMessage&& msg,
                       internal::MessageStorageViewBase* storage_view,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA> final : public ::test_protocols::wire::ChannelProtocolMethodARequest {

  
  explicit WireRequest(::test_protocols::wire::ChannelProtocolMethodARequest base) : ::test_protocols::wire::ChannelProtocolMethodARequest(std::move(base)) {}
  explicit WireRequest(int64_t a, int64_t b) : ::test_protocols::wire::ChannelProtocolMethodARequest{ .a = std::move(a), .b = std::move(b)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA> body;
  explicit TransactionalRequest(int64_t a, int64_t b)
  : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>(a, b)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

  template<>
  struct ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA> final : public ::test_protocols::wire::ChannelProtocolEventARequest {

    
    explicit WireEvent(::test_protocols::wire::ChannelProtocolEventARequest base) : ::test_protocols::wire::ChannelProtocolEventARequest(std::move(base)) {}
    explicit WireEvent(int64_t a, int64_t b) : ::test_protocols::wire::ChannelProtocolEventARequest{ .a = std::move(a), .b = std::move(b)}{}
    WireEvent() = default;
  };


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolEventARequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

  template<>
  struct ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA> final {
    FIDL_ALIGNDECL
    fidl_message_header_t header;
    
    ::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA> body;
    explicit TransactionalEvent(int64_t a, int64_t b)
    : body(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>(a, b)) {
      _InitHeader();
    }
    TransactionalEvent() {
    _InitHeader();
    }

   private:
    void _InitHeader();
  };

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB> final : public ::test_protocols::wire::ChannelProtocolMethodBRequest {

  
  explicit WireRequest(::test_protocols::wire::ChannelProtocolMethodBRequest base) : ::test_protocols::wire::ChannelProtocolMethodBRequest(std::move(base)) {}
  explicit WireRequest(int64_t a, int64_t b) : ::test_protocols::wire::ChannelProtocolMethodBRequest{ .a = std::move(a), .b = std::move(b)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB> body;
  explicit TransactionalRequest(int64_t a, int64_t b)
  : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>(a, b)) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>;

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 16 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};

template<>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB> final : public ::test_protocols::wire::ChannelProtocolMethodBTopResponse {

  
  explicit WireResponse(::test_protocols::wire::ChannelProtocolMethodBTopResponse base) : ::test_protocols::wire::ChannelProtocolMethodBTopResponse(std::move(base)) {}
  explicit WireResponse(int64_t result) : ::test_protocols::wire::ChannelProtocolMethodBTopResponse{ .result = std::move(result)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMethodBTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB> body;
  explicit TransactionalResponse(int64_t result)
  : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>(result)) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 8 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle> final : public ::test_protocols::wire::ChannelProtocolTakeHandleRequest {

  
  explicit WireRequest(::test_protocols::wire::ChannelProtocolTakeHandleRequest base) : ::test_protocols::wire::ChannelProtocolTakeHandleRequest(std::move(base)) {}
  explicit WireRequest(::zx::handle&& h) : ::test_protocols::wire::ChannelProtocolTakeHandleRequest{ .h = std::move(h)}{}
  WireRequest() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolTakeHandleRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle> body;
  explicit TransactionalRequest(::zx::handle&& h)
  : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>(std::move(h))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle> final {

  
  WireResponse() = default;
};



template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  TransactionalResponse() {
    _InitHeader();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 0 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
  }
};
#ifdef __Fuchsia__


template<>
struct ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket> final : public ::test_protocols::wire::ChannelProtocolMutateSocketRequest {

  
  explicit WireRequest(::test_protocols::wire::ChannelProtocolMutateSocketRequest base) : ::test_protocols::wire::ChannelProtocolMutateSocketRequest(std::move(base)) {}
  explicit WireRequest(::zx::socket&& a) : ::test_protocols::wire::ChannelProtocolMutateSocketRequest{ .a = std::move(a)}{}
  WireRequest() = default;
  using ResponseType = ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketRequest, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket> body;
  explicit TransactionalRequest(::zx::socket&& a)
  : body(::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>(std::move(a))) {
    _InitHeader();
  }
  TransactionalRequest() {
    _InitHeader();
  }
  using ResponseType = ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>;
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__


template<>
struct ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket> final : public ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse {

  
  explicit WireResponse(::test_protocols::wire::ChannelProtocolMutateSocketTopResponse base) : ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse(std::move(base)) {}
  explicit WireResponse(::zx::socket&& b) : ::test_protocols::wire::ChannelProtocolMutateSocketTopResponse{ .b = std::move(b)}{}
  WireResponse() = default;
};


template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4;

  static void Encode(
    internal::WireEncoder* encoder, ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Encode(
      encoder, value, position, recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    fidl::internal::WireCodingTraits<::test_protocols::wire::ChannelProtocolMutateSocketTopResponse, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>::Decode(
      decoder, position, recursion_depth);
  }
};

template<>
struct ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket> final {
  FIDL_ALIGNDECL
  fidl_message_header_t header;
  
  ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket> body;
  explicit TransactionalResponse(::zx::socket&& b)
  : body(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>(std::move(b))) {
    _InitHeader();
  }
  TransactionalResponse() {
    _InitHeader();
  }
  void _CloseHandles() {
    body._CloseHandles();
  }

 private:
  void _InitHeader();
};

template <bool IsRecursive>
struct ::fidl::internal::WireCodingTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive>
  : public WireStructCodingTraitsBase<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::WireCodingConstraintEmpty, IsRecursive> {
  static constexpr size_t inline_size = 4 + sizeof(fidl_message_header_t);

  static void Encode(internal::WireEncoder* encoder, ::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>* value, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    *position.As<fidl_message_header_t>() = value->header;
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Encode(
        encoder, &value->body, position + sizeof(fidl_message_header_t), recursion_depth);
  }
  static void Decode(
    internal::WireDecoder* decoder, ::fidl::internal::WirePosition position, RecursionDepth<IsRecursive> recursion_depth) {
    WireCodingTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, WireCodingConstraintEmpty, IsRecursive>::Decode(
        decoder, position + sizeof(fidl_message_header_t), recursion_depth);
  }
};
#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MethodB,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MethodB,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::TakeHandle,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::TakeHandle,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


#ifdef __Fuchsia__



template<>
struct ::fidl::internal::WireMethodTypes<::test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket>>;

  

  using Thenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MutateSocket,
      ::fidl::unstable::OwnedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport
      >
  >;

  using BufferThenable = ::fidl::internal::WireThenableImpl<
      ::test_protocols::ChannelProtocol::MutateSocket,
      ::fidl::unstable::UnownedEncodedMessage<
          ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, ::fidl::internal::ChannelTransport
      >
  >;
};


#endif  // __Fuchsia__


namespace fidl {


template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>, a) == 0);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodA>, b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>)
    == TypeTraits<::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalEvent<::test_protocols::ChannelProtocol::EventA>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolEventARequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>)
    == TypeTraits<::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>>::kPrimarySize);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, a) == 0);
static_assert(offsetof(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>, b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(16 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 16;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>, a) == 0);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MethodB>, b) == 8);

template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(8 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMethodBTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, result) == 0);

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::TakeHandle>, h) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>> : public std::false_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(0 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>, header) == 0);

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>> {
  static constexpr const fidl_type_t* kType =
    nullptr;
  static constexpr bool kHasResponseBody = false;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 0;
  static constexpr uint32_t kPrimarySizeV1 = 0;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

template <>
struct IsFidlType<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};

static_assert(sizeof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kRequest;
};
static_assert(sizeof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::WireRequest<::test_protocols::ChannelProtocol::MutateSocket>, a) == 0);
#endif  // __Fuchsia__


template <>
struct IsFidlType<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlType<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsFidlTransactionalMessage<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::false_type {};
#ifdef __Fuchsia__
template <>
struct IsResource<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};
template <>
struct IsResource<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> : public std::true_type {};


template <>
struct TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kPrimarySizeV1 = FIDL_ALIGN(4 + sizeof(fidl_message_header_t));
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};

static_assert(sizeof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, header) == 0);
static_assert(offsetof(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>, body) == sizeof(fidl_message_header_t));

template <>
struct TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>> {
  static constexpr const fidl_type_t* kType =
    &::test_protocols::test_protocols_ChannelProtocolMutateSocketTopResponseTable;
  static constexpr bool kHasResponseBody = true;
  static constexpr uint32_t kMaxNumHandles = 1;
  static constexpr uint32_t kMaxDepth = 0;
  static constexpr uint32_t kPrimarySize = 4;
  static constexpr uint32_t kPrimarySizeV1 = 4;
  static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasFlexibleEnvelope = false;
  static constexpr bool kHasEnvelope = false;
  static constexpr bool kHasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind kMessageKind =
    ::fidl::internal::TransactionalMessageKind::kResponse;
};
static_assert(sizeof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>)
    == TypeTraits<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>>::kPrimarySize);
static_assert(offsetof(::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, b) == 0);
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace fidl
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::ChannelProtocol::TakeHandle>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>> {
      ::fidl::internal::InlineMessageBuffer<16> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> handles_storage_;
    };
    template<>
    struct ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> final
        : public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>> {
      static constexpr uint32_t kNumHandles =
          fidl::internal::ClampedHandleCount<::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>, fidl::MessageDirection::kReceiving>();

      ::std::array<zx_handle_t, kNumHandles> handles_;
      ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
    };

    template<>
    struct ::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> final
        : public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingMessageStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>> {
      ::fidl::internal::InlineMessageBuffer<24> bytes_;
      ::fidl::internal::IncomingMessageHandleStorage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> handles_storage_;
    };
  template <>
  struct ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ChannelProtocol> final :
      public ::fidl::internal::ChannelHandleStorageBase<::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ChannelProtocol>> {
   public:
    static constexpr uint32_t kNumHandles = 0;

    ::std::array<zx_handle_t, kNumHandles> handles_;
    ::std::array<fidl_channel_handle_metadata_t, kNumHandles> handle_metadata_;
  };

  template <>
  struct ::fidl::internal::IncomingEventsStorage<::test_protocols::ChannelProtocol> final :
      public ::fidl::internal::ChannelMessageStorageBase<::fidl::internal::IncomingEventsStorage<::test_protocols::ChannelProtocol>> {
   public:
    ::fidl::internal::InlineMessageBuffer<32> bytes_;
    ::fidl::internal::IncomingEventsHandleStorage<::test_protocols::ChannelProtocol> handles_storage_;
  };

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA>* request);

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MethodB>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MethodB>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
   private:
    ::fidl::internal::InlineMessageBuffer<16> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::TakeHandle>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> final : public ::fidl::Status {
 public:
  WireResult(
      ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request, std::optional<zx::time> deadline = std::nullopt
  );

  explicit WireResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult& operator=(WireResult&&) = delete;
  WireResult& operator=(const WireResult&) = delete;
  ~WireResult() = default;
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& operator*() const { return value(); }
   private:
    ::fidl::internal::InlineMessageBuffer<24> bytes_;
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> decoded_;
};

template<>
class [[nodiscard]] ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket> final : public ::fidl::Status {
 public:
    explicit WireUnownedResult(::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end, ::fidl::internal::AnyBufferAllocator& allocator, ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket>* request);
    explicit WireUnownedResult(::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>* response)
        : fidl::Status(fidl::Status::Ok()), decoded_(response) {
    }

    explicit WireUnownedResult(
        ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>>&& decoded,
        ::fidl::internal::MessageStorageViewBase* storage_view
    ) : fidl::Status(decoded) {
      if (decoded.ok()) {
        decoded_ = decoded.Take();
      }
    }

  explicit WireUnownedResult(const ::fidl::Status& result) : ::fidl::Status(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult& operator=(WireUnownedResult&&) = delete;
  WireUnownedResult& operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap() {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap() const {
      ZX_ASSERT(ok());
      return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap_NEW() {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* Unwrap_NEW() const {
        ZX_ASSERT(ok());
        return &decoded_.Value()->body;
    }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value() { return *Unwrap(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value() const { return *Unwrap(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value_NEW() { return *Unwrap_NEW(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& value_NEW() const { return *Unwrap_NEW(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* operator->() { return &value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>* operator->() const { return &value(); }

    ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& operator*() { return value(); }
    const ::fidl::WireResponse<::test_protocols::ChannelProtocol::MutateSocket>& operator*() const { return value(); }
   private:
    ::fidl::internal::DecodedValue<::fidl::internal::TransactionalResponse<::test_protocols::ChannelProtocol::MutateSocket>> decoded_;
};
template<>
class ::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol> : public ::fidl::internal::BaseEventHandlerInterface {
public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
    virtual void EventA(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* event) = 0;
};

template<>
class ::fidl::WireAsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
    void EventA(::fidl::WireEvent<::test_protocols::ChannelProtocol::EventA>* event) override {}
};


  template<>
  class ::fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>
      : public ::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>, public ::fidl::internal::SyncEventHandler {
   public:
    WireSyncEventHandler() = default;

    // Handle all possible events defined in this protocol.
    // Blocks to consume exactly one message from the channel, then call the corresponding virtual
    // method.
    ::fidl::Status HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end);
  };

template <>
class ::fidl::internal::WireEventDispatcher<::test_protocols::ChannelProtocol> final :
    public ::fidl::internal::IncomingEventDispatcher<::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>> {
 public:
  explicit WireEventDispatcher(::fidl::internal::WireEventHandlerInterface<::test_protocols::ChannelProtocol>* event_handler)
      : IncomingEventDispatcher(event_handler) {}
    ::fidl::Status DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::MessageStorageViewBase* storage_view) override;
};

// Methods to make a sync FIDL call directly on an unowned handle or a
// const reference to a |fidl::ClientEnd<::test_protocols::ChannelProtocol>|,
// avoiding setting up a client.
template<>
class ::fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol> final :
    public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireSyncClientImpl<::test_protocols::ChannelProtocol>> {
 public:
  
    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA> MethodA(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>(_client_end(), &_request);
    }

    // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(_client_end(), &_request);
    }

    // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>(_client_end(), &_request);
    }

    // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
    ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
      return ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>(_client_end(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template <>
class ::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol> final :
    public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireSyncBufferClientImpl<::test_protocols::ChannelProtocol>> {
 public:
  
    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA> MethodA(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodA> _request{ a, b };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MethodB> _request{ a, b };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::TakeHandle> _request{ std::move(h) };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>(_client_end(), _allocator(), &_request);
    }

    // Caller provides the backing storage for FIDL message via an argument to `.buffer()`.
    ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a) {
      ::fidl::internal::TransactionalRequest<::test_protocols::ChannelProtocol::MutateSocket> _request{ std::move(a) };
      return ::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>(_client_end(), _allocator(), &_request);
    }


 private:
  ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> _client_end() const {
    return ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
      _transport().get<::fidl::internal::ChannelTransport>());
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::internal::CompleterImplBase<::test_protocols::ChannelProtocol::MethodB> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(int64_t result);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(int64_t result);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MethodB> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MethodB> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::internal::CompleterImplBase<::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply();
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply();
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::TakeHandle> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::TakeHandle> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

template<>
class ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::internal::CompleterImplBase<::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  using CompleterImplBase::CompleterImplBase;

  void Reply(::zx::socket&& b);
};

template <>
class ::fidl::internal::WireBufferCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::internal::BufferCompleterImplBase {
 public:
  using BufferCompleterImplBase::BufferCompleterImplBase;

  void Reply(::zx::socket&& b);
};

template<>
class ::fidl::internal::WireCompleterBase<::test_protocols::ChannelProtocol::MutateSocket> : public ::fidl::CompleterBase, public ::fidl::internal::WireCompleterImpl<::test_protocols::ChannelProtocol::MutateSocket> {
 public:
  WireCompleterBase(::fidl::Transaction* transaction, bool owned, bool expects_reply)
      : CompleterBase(transaction, owned, expects_reply),
        WireCompleterImpl(this) {}
  WireCompleterBase(WireCompleterBase&& other) noexcept
      : CompleterBase(std::move(other)), WireCompleterImpl(this) {}
  WireCompleterBase& operator=(WireCompleterBase&& other) noexcept {
    CompleterBase::operator=(std::move(other));
    WireCompleterImpl::_set_core(this);
    return *this;
  }
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template<>
class ::fidl::WireServer<::test_protocols::ChannelProtocol> : public ::fidl::internal::IncomingMessageDispatcher {
  public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;


    using MethodACompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodA>;
    using MethodARequestView = ::fidl::internal::WireRequestView<::test_protocols::ChannelProtocol::MethodA>;

  
  virtual void MethodA(
    MethodARequestView request, MethodACompleter::Sync& completer)= 0;

    using MethodBCompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MethodB>;
    using MethodBRequestView = ::fidl::internal::WireRequestView<::test_protocols::ChannelProtocol::MethodB>;

  
  virtual void MethodB(
    MethodBRequestView request, MethodBCompleter::Sync& completer)= 0;

    using TakeHandleCompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::TakeHandle>;
    using TakeHandleRequestView = ::fidl::internal::WireRequestView<::test_protocols::ChannelProtocol::TakeHandle>;

  
  virtual void TakeHandle(
    TakeHandleRequestView request, TakeHandleCompleter::Sync& completer)= 0;

    using MutateSocketCompleter = ::fidl::internal::WireCompleter<::test_protocols::ChannelProtocol::MutateSocket>;
    using MutateSocketRequestView = ::fidl::internal::WireRequestView<::test_protocols::ChannelProtocol::MutateSocket>;

  
  virtual void MutateSocket(
    MutateSocketRequestView request, MutateSocketCompleter::Sync& completer)= 0;


  private:
  void dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::MessageStorageViewBase* storage_view) final;
};namespace fidl {
#endif  // __Fuchsia__


  
    
#ifdef __Fuchsia__
}  // namespace fidl
template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status NoRequestNoResponse();
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::Status WithRequestNoResponse(::fidl::StringView arg);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg);
    // The request and callback are allocated on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status NoRequestNoResponse();


// Caller provides the backing storage for FIDL message.
::fidl::Status WithRequestNoResponse(::fidl::StringView arg);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithAndWithoutRequestResponse> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithAndWithoutRequestResponse> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> NoRequestEmptyResponse();
  
  // Allocates 16 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> NoRequestWithResponse();
  
  // Allocates 16 bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> WithRequestEmptyResponse(::fidl::StringView arg);
  
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> WithRequestWithResponse(::fidl::StringView arg);
};namespace fidl {
#endif  // __Fuchsia__


    
}  // namespace fidl
#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::WithAndWithoutRequestResponse> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status OnEmptyResponse();


    fidl::Status OnWithResponse(::fidl::StringView ret);


};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status OneWay(int64_t x);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::Transitional::Request> Request(int64_t x);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::Transitional> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status OneWay(int64_t x);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::Transitional> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::Transitional::Request> Request(int64_t x);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::Transitional> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::Transitional> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::Transitional::Request> Request(int64_t x);
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::Transitional> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status Event(int64_t x);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::Transitional> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status Event(int64_t x);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status Event(int64_t x);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::Transitional>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status Event(int64_t x);


};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithProtocolEnds> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);
    // Allocates 32 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithProtocolEnds> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithProtocolEnds> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds> ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in);
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds> ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in);
  
  // Allocates 64 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds> StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in);
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithProtocolEnds> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::WithProtocolEnds> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 32 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::MethodWithUnion> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::MethodWithUnion> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 32 bytes of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod> UnionMethod(::test_protocols::wire::TheUnion u);
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::MethodWithUnion> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::MethodWithUnion> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ManyParameters> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::ManyParameters> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ManyParameters> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::ManyParameters> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::ManyParameters> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status NoResponseMethod(::zx::socket&& h);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status NoResponseMethod(::zx::socket&& h);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::HandleRightsProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::HandleRightsProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod> ResponseMethod(::zx::socket&& h);
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status AnEvent(::zx::socket&& h);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::HandleRightsProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status AnEvent(::zx::socket&& h);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status AnEvent(::zx::socket&& h);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status AnEvent(::zx::socket&& h);


};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithErrorSyntax> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();
    // Allocates 16 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithErrorSyntax> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;
};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithErrorSyntax> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::WithErrorSyntax> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 72 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct> ResponseAsStruct();
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> ErrorAsPrimitive();
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum> ErrorAsEnum();
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult> HandleInResult();
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::WithErrorSyntax> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::WithErrorSyntax> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 32 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status Method();
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status Method();

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;
};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::DiscoverableProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::DiscoverableProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::DiscoverableProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

};
#endif  // __Fuchsia__

    
#ifdef __Fuchsia__

template<>
class ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol> : public ::fidl::internal::ClientImplBase {
 public:
  using ClientImplBase::ClientImplBase;
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::Status MethodA(int64_t a, int64_t b);
};

template<>
class ::fidl::internal::WireWeakAsyncClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
    // Allocates 32 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b);
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h);
    // Allocates 24 bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a);
};

template<>
class ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ChannelProtocol> : public ::fidl::internal::BufferClientImplBase {
 public:
  using BufferClientImplBase::BufferClientImplBase;

// Caller provides the backing storage for FIDL message.
::fidl::Status MethodA(int64_t a, int64_t b);

};

template<>
class ::fidl::internal::WireWeakAsyncBufferClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::WireWeakOnewayBufferClientImpl<::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayBufferClientImpl::WireWeakOnewayBufferClientImpl;

// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h);


// Caller provides the backing storage for FIDL message.
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a);

};
template<>
class ::fidl::internal::WireWeakSyncClientImpl<::test_protocols::ChannelProtocol> final : public ::fidl::internal::WireWeakOnewayClientImpl<::test_protocols::ChannelProtocol> {
 public:
  using WireWeakOnewayClientImpl::WireWeakOnewayClientImpl;
  
  // Allocates 56 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB> MethodB(int64_t a, int64_t b);
  
  // Allocates 40 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle> TakeHandle(::zx::handle&& h);
  
  // Allocates 48 bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket> MutateSocket(::zx::socket&& a);
};
#endif  // __Fuchsia__


    

#ifdef __Fuchsia__
template<>
class ::fidl::internal::WireWeakEventSender<::test_protocols::ChannelProtocol> : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

    fidl::Status EventA(int64_t a, int64_t b);


};

template<>
class ::fidl::internal::WireWeakBufferEventSender<::test_protocols::ChannelProtocol> : public ::fidl::internal::WeakBufferEventSenderBase {
 public:
  using WeakBufferEventSenderBase::WeakBufferEventSenderBase;

    fidl::Status EventA(int64_t a, int64_t b);


};

template<>
class ::fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<::fidl::internal::WireEventSender<::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

    fidl::Status EventA(int64_t a, int64_t b);


};

template<>
class ::fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointBufferVeneer<::fidl::internal::WireBufferEventSender<::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointBufferVeneer::SyncEndpointBufferVeneer;

    fidl::Status EventA(int64_t a, int64_t b);


};
#endif  // __Fuchsia__


  
