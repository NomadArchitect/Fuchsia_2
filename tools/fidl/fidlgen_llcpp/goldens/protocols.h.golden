// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/internal.h>
#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/result.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/vector_view.h>
#include <lib/fidl/llcpp/wire_messaging.h>
#include <lib/fit/function.h>
#include <lib/stdcompat/optional.h>

#include <algorithm>
#include <cstddef>
#include <variant>
#ifdef __Fuchsia__
#include <lib/fidl/llcpp/client.h>
#include <lib/fidl/llcpp/client_end.h>
#include <lib/fidl/llcpp/connect_service.h>
#include <lib/fidl/llcpp/server.h>
#include <lib/fidl/llcpp/server_end.h>
#include <lib/fidl/llcpp/service_handler_interface.h>
#include <lib/fidl/llcpp/sync_call.h>
#include <lib/fidl/llcpp/transaction.h>
#include <lib/fidl/txn_header.h>
#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>

#endif  // __Fuchsia__
#include <zircon/fidl.h>

namespace fidl_test_protocols {
namespace wire {
// |Rights| is strict, hence is guaranteed to only contain
// members defined in the FIDL schema when receiving it in a message.
// Sending unknown members will fail at runtime.
class Rights final {
 public:
  constexpr Rights() = default;
  constexpr Rights(const Rights& other) = default;

  // Constructs an instance of |Rights| from an underlying primitive value,
  // preserving any bit member not defined in the FIDL schema.
  explicit constexpr Rights(uint32_t value) : value_(value) {}
  const static Rights kTransfer;
  const static Rights kDuplicate;
  const static Rights kMask;

  explicit constexpr inline operator uint32_t() const { return value_; }
  explicit constexpr inline operator bool() const {
    return static_cast<bool>(value_);
  }
  constexpr inline bool operator==(const Rights& other) const {
    return value_ == other.value_;
  }
  constexpr inline bool operator!=(const Rights& other) const {
    return value_ != other.value_;
  }
  constexpr inline Rights operator~() const;
  constexpr inline Rights operator|(const Rights& other) const;
  constexpr inline Rights operator&(const Rights& other) const;
  constexpr inline Rights operator^(const Rights& other) const;
  constexpr inline void operator|=(const Rights& other);
  constexpr inline void operator&=(const Rights& other);
  constexpr inline void operator^=(const Rights& other);

  // Constructs an instance of |Rights| from an underlying primitive value
  // if the primitive does not contain any unknown members not defined in the
  // FIDL schema. Otherwise, returns |cpp17::nullopt|.
  constexpr inline static cpp17::optional<Rights> TryFrom(uint32_t value) {
    if (value & ~kMask.value_) {
      return cpp17::nullopt;
    }
    return Rights(value & Rights::kMask.value_);
  }

  // Constructs an instance of |Rights| from an underlying primitive value,
  // clearing any bit member not defined in the FIDL schema.
  constexpr inline static Rights TruncatingUnknown(uint32_t value) {
    return Rights(value & Rights::kMask.value_);
  }

 private:
  uint32_t value_ = 0;
};
constexpr const ::fidl_test_protocols::wire::Rights Rights::kTransfer =
    ::fidl_test_protocols::wire::Rights(1u);
constexpr const ::fidl_test_protocols::wire::Rights Rights::kDuplicate =
    ::fidl_test_protocols::wire::Rights(2u);
constexpr const ::fidl_test_protocols::wire::Rights Rights::kMask =
    ::fidl_test_protocols::wire::Rights(3u);

constexpr inline ::fidl_test_protocols::wire::Rights Rights::operator~() const {
  return ::fidl_test_protocols::wire::Rights(
      static_cast<uint32_t>(~this->value_ & kMask.value_));
}

constexpr inline ::fidl_test_protocols::wire::Rights Rights::operator|(
    const ::fidl_test_protocols::wire::Rights& other) const {
  return ::fidl_test_protocols::wire::Rights(
      static_cast<uint32_t>(this->value_ | other.value_));
}

constexpr inline ::fidl_test_protocols::wire::Rights Rights::operator&(
    const ::fidl_test_protocols::wire::Rights& other) const {
  return ::fidl_test_protocols::wire::Rights(
      static_cast<uint32_t>(this->value_ & other.value_));
}

constexpr inline ::fidl_test_protocols::wire::Rights Rights::operator^(
    const ::fidl_test_protocols::wire::Rights& other) const {
  return ::fidl_test_protocols::wire::Rights(
      static_cast<uint32_t>(this->value_ ^ other.value_));
}

constexpr inline void Rights::operator|=(
    const ::fidl_test_protocols::wire::Rights& other) {
  this->value_ |= other.value_;
}

constexpr inline void Rights::operator&=(
    const ::fidl_test_protocols::wire::Rights& other) {
  this->value_ &= other.value_;
}

constexpr inline void Rights::operator^=(
    const ::fidl_test_protocols::wire::Rights& other) {
  this->value_ ^= other.value_;
}

enum class ObjType : uint32_t {

  kNone = 0u,

  kSocket = 14u,
};

struct WithErrorSyntaxHandleInResultResponse;

class WithErrorSyntaxHandleInResultResult;
}  // namespace wire
class HandleRightsProtocol;
namespace wire {
struct WithErrorSyntaxResponseAsStructResponse;

class WithErrorSyntaxResponseAsStructResult;

struct WithErrorSyntaxErrorAsPrimitiveResponse;

class WithErrorSyntaxErrorAsPrimitiveResult;

struct WithErrorSyntaxErrorAsEnumResponse;
}  // namespace wire
class WithAndWithoutRequestResponse;

class Transitional;
namespace wire {
class TheUnion;
}  // namespace wire
class MethodWithUnion;
namespace wire {
struct ProtocolEnds;
}  // namespace wire
class WithProtocolEnds;

class ManyParameters;
namespace wire {

enum class ErrorEnum : uint32_t {

  kErrFoo = 1u,

  kErrBar = 2u,
};

class WithErrorSyntaxErrorAsEnumResult;
}  // namespace wire
class WithErrorSyntax;

class DiscoverableProtocol;

class ChannelProtocol;
namespace wire {

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

class WithErrorSyntaxHandleInResultResult {
 public:
  using Response =
      fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse;

  WithErrorSyntaxHandleInResultResult()
      : ordinal_(::fidl_test_protocols::wire::
                     WithErrorSyntaxHandleInResultResult::Ordinal::Invalid),
        envelope_{} {}

  WithErrorSyntaxHandleInResultResult(
      const WithErrorSyntaxHandleInResultResult&) = default;
  WithErrorSyntaxHandleInResultResult& operator=(
      const WithErrorSyntaxHandleInResultResult&) = default;
  WithErrorSyntaxHandleInResultResult(WithErrorSyntaxHandleInResultResult&&) =
      default;
  WithErrorSyntaxHandleInResultResult& operator=(
      WithErrorSyntaxHandleInResultResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::
               Ordinal::kResponse;
  }

  static WithErrorSyntaxHandleInResultResult WithResponse(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
          val) {
    WithErrorSyntaxHandleInResultResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxHandleInResultResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxHandleInResultResult result;
    result.set_response(
        ::fidl::ObjectView<
            ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
          elem) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxHandleInResultResult::Ordinal::kResponse;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxHandleInResultResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<
            ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>(
        envelope_.data.get());
  }
  const ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse*>(
        envelope_.data.get());
  }

  bool is_err() const {
    return ordinal_ == ::fidl_test_protocols::wire::
                           WithErrorSyntaxHandleInResultResult::Ordinal::kErr;
  }

  static WithErrorSyntaxHandleInResultResult WithErr(
      ::fidl::ObjectView<uint32_t> val) {
    WithErrorSyntaxHandleInResultResult result;
    result.set_err(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxHandleInResultResult WithErr(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxHandleInResultResult result;
    result.set_err(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_err(::fidl::ObjectView<uint32_t> elem) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxHandleInResultResult::Ordinal::kErr;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_err(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxHandleInResultResult::Ordinal::kErr;
    set_err(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kErr);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::
                  Ordinal::kErr);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_HandleInResult_ResultTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  void _CloseHandles();

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};
#endif  // __Fuchsia__

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

class WithErrorSyntaxResponseAsStructResult {
 public:
  using Response =
      fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse;

  WithErrorSyntaxResponseAsStructResult()
      : ordinal_(::fidl_test_protocols::wire::
                     WithErrorSyntaxResponseAsStructResult::Ordinal::Invalid),
        envelope_{} {}

  WithErrorSyntaxResponseAsStructResult(
      const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(
      const WithErrorSyntaxResponseAsStructResult&) = default;
  WithErrorSyntaxResponseAsStructResult(
      WithErrorSyntaxResponseAsStructResult&&) = default;
  WithErrorSyntaxResponseAsStructResult& operator=(
      WithErrorSyntaxResponseAsStructResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
               Ordinal::kResponse;
  }

  static WithErrorSyntaxResponseAsStructResult WithResponse(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
          val) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxResponseAsStructResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_response(
        ::fidl::ObjectView<::fidl_test_protocols::wire::
                               WithErrorSyntaxResponseAsStructResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
          elem) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<::fidl_test_protocols::wire::
                               WithErrorSyntaxResponseAsStructResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>(
        envelope_.data.get());
  }
  const ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxResponseAsStructResult::Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse*>(
        envelope_.data.get());
  }

  bool is_err() const {
    return ordinal_ == ::fidl_test_protocols::wire::
                           WithErrorSyntaxResponseAsStructResult::Ordinal::kErr;
  }

  static WithErrorSyntaxResponseAsStructResult WithErr(
      ::fidl::ObjectView<uint32_t> val) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_err(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxResponseAsStructResult WithErr(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxResponseAsStructResult result;
    result.set_err(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_err(::fidl::ObjectView<uint32_t> elem) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxResponseAsStructResult::Ordinal::kErr;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_err(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxResponseAsStructResult::Ordinal::kErr;
    set_err(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxResponseAsStructResult::Ordinal::kErr);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxResponseAsStructResult::Ordinal::kErr);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Tag
  which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_protocols::wire::
                           WithErrorSyntaxResponseAsStructResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

class WithErrorSyntaxErrorAsPrimitiveResult {
 public:
  using Response =
      fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse;

  WithErrorSyntaxErrorAsPrimitiveResult()
      : ordinal_(::fidl_test_protocols::wire::
                     WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::Invalid),
        envelope_{} {}

  WithErrorSyntaxErrorAsPrimitiveResult(
      const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(
      const WithErrorSyntaxErrorAsPrimitiveResult&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult(
      WithErrorSyntaxErrorAsPrimitiveResult&&) = default;
  WithErrorSyntaxErrorAsPrimitiveResult& operator=(
      WithErrorSyntaxErrorAsPrimitiveResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
               Ordinal::kResponse;
  }

  static WithErrorSyntaxErrorAsPrimitiveResult WithResponse(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>
          val) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxErrorAsPrimitiveResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.set_response(
        ::fidl::ObjectView<::fidl_test_protocols::wire::
                               WithErrorSyntaxErrorAsPrimitiveResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>
          elem) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<::fidl_test_protocols::wire::
                               WithErrorSyntaxErrorAsPrimitiveResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse*>(
        envelope_.data.get());
  }
  const ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse*>(
        envelope_.data.get());
  }

  bool is_err() const {
    return ordinal_ == ::fidl_test_protocols::wire::
                           WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr;
  }

  static WithErrorSyntaxErrorAsPrimitiveResult WithErr(
      ::fidl::ObjectView<uint32_t> val) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.set_err(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxErrorAsPrimitiveResult WithErr(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxErrorAsPrimitiveResult result;
    result.set_err(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_err(::fidl::ObjectView<uint32_t> elem) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_err(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::
        WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr;
    set_err(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
  }

  uint32_t& mutable_err() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::
                  WithErrorSyntaxErrorAsPrimitiveResult::Ordinal::kErr);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Tag
  which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_protocols::wire::
                           WithErrorSyntaxErrorAsPrimitiveResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t fidl_test_protocols_TheUnionTable;

class TheUnion {
 public:
  TheUnion()
      : ordinal_(::fidl_test_protocols::wire::TheUnion::Ordinal::Invalid),
        envelope_{} {}

  TheUnion(const TheUnion&) = default;
  TheUnion& operator=(const TheUnion&) = default;
  TheUnion(TheUnion&&) = default;
  TheUnion& operator=(TheUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_protocols::wire::TheUnion::Ordinal::Invalid;
  }

  bool is_v() const {
    return ordinal_ == ::fidl_test_protocols::wire::TheUnion::Ordinal::kV;
  }

  static TheUnion WithV(::fidl::ObjectView<uint32_t> val) {
    TheUnion result;
    result.set_v(val);
    return result;
  }

  template <typename... Args>
  static TheUnion WithV(::fidl::AnyArena& allocator, Args&&... args) {
    TheUnion result;
    result.set_v(
        ::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_v(::fidl::ObjectView<uint32_t> elem) {
    ordinal_ = ::fidl_test_protocols::wire::TheUnion::Ordinal::kV;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_v(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::TheUnion::Ordinal::kV;
    set_v(::fidl::ObjectView<uint32_t>(allocator, std::forward<Args>(args)...));
  }

  uint32_t& mutable_v() {
    ZX_ASSERT(ordinal_ == ::fidl_test_protocols::wire::TheUnion::Ordinal::kV);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  const uint32_t& v() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_protocols::wire::TheUnion::Ordinal::kV);
    return *static_cast<uint32_t*>(envelope_.data.get());
  }
  ::fidl_test_protocols::wire::TheUnion::Tag which() const;

  static constexpr const fidl_type_t* Type = &fidl_test_protocols_TheUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_protocols::wire::TheUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

class WithErrorSyntaxErrorAsEnumResult {
 public:
  using Response =
      fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse;

  WithErrorSyntaxErrorAsEnumResult()
      : ordinal_(::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
                     Ordinal::Invalid),
        envelope_{} {}

  WithErrorSyntaxErrorAsEnumResult(const WithErrorSyntaxErrorAsEnumResult&) =
      default;
  WithErrorSyntaxErrorAsEnumResult& operator=(
      const WithErrorSyntaxErrorAsEnumResult&) = default;
  WithErrorSyntaxErrorAsEnumResult(WithErrorSyntaxErrorAsEnumResult&&) =
      default;
  WithErrorSyntaxErrorAsEnumResult& operator=(
      WithErrorSyntaxErrorAsEnumResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_protocols::wire::
                           WithErrorSyntaxErrorAsEnumResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ == ::fidl_test_protocols::wire::
                           WithErrorSyntaxErrorAsEnumResult::Ordinal::kResponse;
  }

  static WithErrorSyntaxErrorAsEnumResult WithResponse(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>
          val) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.set_response(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxErrorAsEnumResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.set_response(
        ::fidl::ObjectView<
            ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_response(
      ::fidl::ObjectView<
          ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>
          elem) {
    ordinal_ = ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
        Ordinal::kResponse;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_response(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
        Ordinal::kResponse;
    set_response(
        ::fidl::ObjectView<
            ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse&
  mutable_response() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
                  Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse*>(
        envelope_.data.get());
  }
  const ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
                  Ordinal::kResponse);
    return *static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse*>(
        envelope_.data.get());
  }

  bool is_err() const {
    return ordinal_ == ::fidl_test_protocols::wire::
                           WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr;
  }

  static WithErrorSyntaxErrorAsEnumResult WithErr(
      ::fidl::ObjectView<::fidl_test_protocols::wire::ErrorEnum> val) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.set_err(val);
    return result;
  }

  template <typename... Args>
  static WithErrorSyntaxErrorAsEnumResult WithErr(::fidl::AnyArena& allocator,
                                                  Args&&... args) {
    WithErrorSyntaxErrorAsEnumResult result;
    result.set_err(::fidl::ObjectView<::fidl_test_protocols::wire::ErrorEnum>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_err(
      ::fidl::ObjectView<::fidl_test_protocols::wire::ErrorEnum> elem) {
    ordinal_ = ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
        Ordinal::kErr;
    envelope_.data =
        ::fidl::ObjectView<void>::FromExternal(static_cast<void*>(elem.get()));
  }

  template <typename... Args>
  void set_err(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::
        Ordinal::kErr;
    set_err(::fidl::ObjectView<::fidl_test_protocols::wire::ErrorEnum>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_protocols::wire::ErrorEnum& mutable_err() {
    ZX_ASSERT(ordinal_ == ::fidl_test_protocols::wire::
                              WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr);
    return *static_cast<::fidl_test_protocols::wire::ErrorEnum*>(
        envelope_.data.get());
  }
  const ::fidl_test_protocols::wire::ErrorEnum& err() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_protocols::wire::
                              WithErrorSyntaxErrorAsEnumResult::Ordinal::kErr);
    return *static_cast<::fidl_test_protocols::wire::ErrorEnum*>(
        envelope_.data.get());
  }
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::Envelope<void> envelope_;
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

struct WithErrorSyntaxHandleInResultResponse {
  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  ::zx::handle h = {};

  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                          WithErrorSyntaxHandleInResultResponse* value)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                backing_buffer, backing_buffer_size, value) {}
    UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                          uint32_t backing_buffer_size,
                          WithErrorSyntaxHandleInResultResponse* value)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = backing_buffer,
              .backing_buffer_capacity = backing_buffer_size,
          }) {
      ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
      message_.Encode<WithErrorSyntaxHandleInResultResponse>(value);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(WithErrorSyntaxHandleInResultResponse* value)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), value) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WithErrorSyntaxHandleInResultResponse* value)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), value) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
    UnownedEncodedMessage message_;
  };

  class DecodedMessage final : public ::fidl::internal::DecodedMessageBase<
                                   WithErrorSyntaxHandleInResultResponse> {
   public:
    using DecodedMessageBase<
        WithErrorSyntaxHandleInResultResponse>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              ::fidl::internal::kLLCPPInMemoryWireFormatVersion,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              wire_format_version,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    DecodedMessage(const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(wire_format_version,
                         reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    WithErrorSyntaxHandleInResultResponse* PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<WithErrorSyntaxHandleInResultResponse*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };
};
#endif  // __Fuchsia__

}  // namespace wire
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolNoResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolResponseMethodResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolAnEventRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_HandleRightsProtocolAnEventEventTable;

class HandleRightsProtocol final {
  HandleRightsProtocol() = delete;

 public:
  class NoResponseMethod final {
    NoResponseMethod() = delete;
  };
  class ResponseMethod final {
    ResponseMethod() = delete;
  };
  class AnEvent final {
    AnEvent() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::HandleRightsProtocol> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::HandleRightsProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireRequest(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(h)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(h)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::socket&& h)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(h)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(h)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireRequest(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolResponseMethodRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(h)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(h)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::socket&& h)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(h)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(h)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireResponse(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolResponseMethodResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(h)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{std::move(h)};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>(
          response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::socket&& h)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(h)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(h)) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::AnEvent>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket h;
  explicit WireResponse(::zx::socket&& h) : h(std::move(h)) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_HandleRightsProtocolAnEventEventTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(h)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& h)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{std::move(h)};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::socket&& h)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(h)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& h)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(h)) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::HandleRightsProtocol::AnEvent>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::HandleRightsProtocol::AnEvent>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::HandleRightsProtocol::AnEvent>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::AnEvent>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::AnEvent>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      ::zx::socket&& h);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::socket&& h);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      ::zx::socket&& h);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      ::zx::socket&& h, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::socket&& h, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>&&
          decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*>(bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol>|, avoiding
// setting up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::HandleRightsProtocol>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          client_end)
      : client_end_(client_end) {}

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client_end,
      ::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        _client_end, std::move(h));
  }
  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::zx::socket&& h) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        client_end_, std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client_end,
      ::fidl::BufferSpan _request_buffer, ::zx::socket&& h) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(h));
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(h));
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client_end,
      ::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        _client_end, std::move(h));
  }
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        client_end_, std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          _client_end,
      ::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
                 ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
      client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::HandleRightsProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void AnEvent(
      ::fidl::WireResponse<
          ::fidl_test_protocols::HandleRightsProtocol::AnEvent>* event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::HandleRightsProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::HandleRightsProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::HandleRightsProtocol>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::HandleRightsProtocol>
    final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol>&
  client_end() const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        this->client_end(), std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>
  NoResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h));
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::zx::socket&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        this->client_end(), std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod(::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
                 ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<::fidl_test_protocols::HandleRightsProtocol>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::HandleRightsProtocol> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::zx::socket&& h);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::zx::socket&& h);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::HandleRightsProtocol;

  using NoResponseMethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(
      NoResponseMethodRequestView request,
      NoResponseMethodCompleter::Sync& _completer) = 0;

  using ResponseMethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequestView request,
                              ResponseMethodCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
namespace wire {

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

struct WithErrorSyntaxResponseAsStructResponse {
  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  int64_t a = {};

  int64_t b = {};

  int64_t c = {};

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                          WithErrorSyntaxResponseAsStructResponse* value)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                backing_buffer, backing_buffer_size, value) {}
    UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                          uint32_t backing_buffer_size,
                          WithErrorSyntaxResponseAsStructResponse* value)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = iovec_capacity,
              .backing_buffer = backing_buffer,
              .backing_buffer_capacity = backing_buffer_size,
          }) {
      ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
      message_.Encode<WithErrorSyntaxResponseAsStructResponse>(value);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(WithErrorSyntaxResponseAsStructResponse* value)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), value) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WithErrorSyntaxResponseAsStructResponse* value)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), value) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

  class DecodedMessage final : public ::fidl::internal::DecodedMessageBase<
                                   WithErrorSyntaxResponseAsStructResponse> {
   public:
    using DecodedMessageBase<
        WithErrorSyntaxResponseAsStructResponse>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              ::fidl::internal::kLLCPPInMemoryWireFormatVersion,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              wire_format_version,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    DecodedMessage(const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(wire_format_version,
                         reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    WithErrorSyntaxResponseAsStructResponse* PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<WithErrorSyntaxResponseAsStructResponse*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };
};

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

struct WithErrorSyntaxErrorAsPrimitiveResponse {
  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                          WithErrorSyntaxErrorAsPrimitiveResponse* value)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                backing_buffer, backing_buffer_size, value) {}
    UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                          uint32_t backing_buffer_size,
                          WithErrorSyntaxErrorAsPrimitiveResponse* value)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = iovec_capacity,
              .backing_buffer = backing_buffer,
              .backing_buffer_capacity = backing_buffer_size,
          }) {
      ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
      message_.Encode<WithErrorSyntaxErrorAsPrimitiveResponse>(value);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(WithErrorSyntaxErrorAsPrimitiveResponse* value)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), value) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WithErrorSyntaxErrorAsPrimitiveResponse* value)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), value) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
    UnownedEncodedMessage message_;
  };

  class DecodedMessage final : public ::fidl::internal::DecodedMessageBase<
                                   WithErrorSyntaxErrorAsPrimitiveResponse> {
   public:
    using DecodedMessageBase<
        WithErrorSyntaxErrorAsPrimitiveResponse>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              ::fidl::internal::kLLCPPInMemoryWireFormatVersion,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              wire_format_version,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    DecodedMessage(const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(wire_format_version,
                         reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    WithErrorSyntaxErrorAsPrimitiveResponse* PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<WithErrorSyntaxErrorAsPrimitiveResponse*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };
};

extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

struct WithErrorSyntaxErrorAsEnumResponse {
  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                          WithErrorSyntaxErrorAsEnumResponse* value)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                backing_buffer, backing_buffer_size, value) {}
    UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                          uint32_t backing_buffer_size,
                          WithErrorSyntaxErrorAsEnumResponse* value)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = iovec_capacity,
              .backing_buffer = backing_buffer,
              .backing_buffer_capacity = backing_buffer_size,
          }) {
      ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
      message_.Encode<WithErrorSyntaxErrorAsEnumResponse>(value);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(WithErrorSyntaxErrorAsEnumResponse* value)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), value) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WithErrorSyntaxErrorAsEnumResponse* value)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), value) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
    UnownedEncodedMessage message_;
  };

  class DecodedMessage final : public ::fidl::internal::DecodedMessageBase<
                                   WithErrorSyntaxErrorAsEnumResponse> {
   public:
    using DecodedMessageBase<
        WithErrorSyntaxErrorAsEnumResponse>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              ::fidl::internal::kLLCPPInMemoryWireFormatVersion,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              wire_format_version,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    DecodedMessage(const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(wire_format_version,
                         reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    WithErrorSyntaxErrorAsEnumResponse* PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<WithErrorSyntaxErrorAsEnumResponse*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };
};

}  // namespace wire
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestNoResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestEmptyResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnEmptyResponseEventTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseEventTable;

class WithAndWithoutRequestResponse final {
  WithAndWithoutRequestResponse() = delete;

 public:
  class NoRequestNoResponse final {
    NoRequestNoResponse() = delete;
  };
  class NoRequestEmptyResponse final {
    NoRequestEmptyResponse() = delete;
  };
  class NoRequestWithResponse final {
    NoRequestWithResponse() = delete;
  };
  class WithRequestNoResponse final {
    WithRequestNoResponse() = delete;
  };
  class WithRequestEmptyResponse final {
    WithRequestEmptyResponse() = delete;
  };
  class WithRequestWithResponse final {
    WithRequestWithResponse() = delete;
  };
  class OnEmptyResponse final {
    OnEmptyResponse() = delete;
  };
  class OnWithResponse final {
    OnWithResponse() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithAndWithoutRequestResponse>*
          impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithAndWithoutRequestResponse>*
          impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestNoResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestNoResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestNoResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponse>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponse>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestEmptyResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView ret;
  explicit WireResponse(::fidl::StringView ret) : ret(ret) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView ret)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, ret) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView ret)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{ret};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl::StringView ret)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), ret) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::StringView ret)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), ret) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponse>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponse>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
        backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                NoRequestWithResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView arg;
  explicit WireRequest(::fidl::StringView arg) : arg(arg) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView arg)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, arg) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView arg)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{arg};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl::StringView arg)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), arg) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::StringView arg)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), arg) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
        backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestNoResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView arg;
  explicit WireRequest(::fidl::StringView arg) : arg(arg) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView arg)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, arg) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView arg)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{arg};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl::StringView arg)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), arg) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::StringView arg)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), arg) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
        backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView arg;
  explicit WireRequest(::fidl::StringView arg) : arg(arg) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView arg)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, arg) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView arg)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{arg};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl::StringView arg)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), arg) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::StringView arg)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), arg) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
        backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView ret;
  explicit WireResponse(::fidl::StringView ret) : ret(ret) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView ret)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, ret) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView ret)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{ret};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl::StringView ret)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), ret) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::StringView ret)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), ret) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
        backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnEmptyResponse>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnEmptyResponse>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnEmptyResponse>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnEmptyResponse>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnEmptyResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            OnEmptyResponse>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnEmptyResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::StringView ret;
  explicit WireResponse(::fidl::StringView ret) : ret(ret) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithAndWithoutRequestResponseOnWithResponseEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView ret)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, ret) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::fidl::StringView ret)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{ret};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnWithResponse>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnWithResponse>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl::StringView ret)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), ret) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::StringView ret)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), ret) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<::fidl_test_protocols::
                                 WithAndWithoutRequestResponse::OnWithResponse>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<::fidl_test_protocols::
                                 WithAndWithoutRequestResponse::OnWithResponse>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
        backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithAndWithoutRequestResponse::
                OnWithResponse>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              OnWithResponse>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           NoRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                          ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client,
                      ::fidl::StringView arg);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::StringView arg);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                          ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client,
                      ::fidl::StringView arg);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             ::fidl::StringView arg, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::StringView arg, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestEmptyResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireResult(::fidl::UnownedClientEnd<
                          ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client,
                      ::fidl::StringView arg);
  WireResult(::fidl::UnownedClientEnd<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse>
                 _client,
             ::fidl::StringView arg, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::StringView arg, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                           WithRequestWithResponse>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireCaller<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final {
 public:
  explicit WireCaller(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          client_end)
      : client_end_(client_end) {}

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse(::fidl::UnownedClientEnd<
                      ::fidl_test_protocols::WithAndWithoutRequestResponse>
                          _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>(_client_end);
  }
  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>(client_end_);
  }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>
  NoRequestEmptyResponse(::fidl::UnownedClientEnd<
                         ::fidl_test_protocols::WithAndWithoutRequestResponse>
                             _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>(_client_end);
  }
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>
  NoRequestEmptyResponse() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>(client_end_);
  }

  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse(::fidl::UnownedClientEnd<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse>
                            _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(_client_end);
  }
  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>
  NoRequestWithResponse() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(client_end_);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(_client_end, _response_buffer.data,
                                   _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse(::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(client_end_, _response_buffer.data,
                                   _response_buffer.capacity);
  }

  // Request is heap-allocated.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>
  WithRequestNoResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(_client_end, arg);
  }
  // Request is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestNoResponse>
  WithRequestNoResponse(::fidl::StringView arg) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(client_end_, arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>
  WithRequestNoResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(_client_end, _request_buffer.data,
                                   _request_buffer.capacity, arg);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>
  WithRequestNoResponse(::fidl::BufferSpan _request_buffer,
                        ::fidl::StringView arg) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(client_end_, _request_buffer.data,
                                   _request_buffer.capacity, arg);
  }

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(_client_end, arg);
  }
  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(client_end_, arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(
        _client_end, _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::BufferSpan _request_buffer,
                           ::fidl::StringView arg,
                           ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(
        client_end_, _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Request is heap-allocated. Response is heap-allocated.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(_client_end, arg);
  }
  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(client_end_, arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          _client_end,
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(
        _client_end, _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse(::fidl::BufferSpan _request_buffer,
                          ::fidl::StringView arg,
                          ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(
        client_end_, _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
      client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void OnEmptyResponse(
      ::fidl::WireResponse<::fidl_test_protocols::
                               WithAndWithoutRequestResponse::OnEmptyResponse>*
          event) {}
  virtual void OnWithResponse(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>*
          event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>
          client_end);
};
template <>
class ::fidl::WireSyncClient<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
          client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  client_end() const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
  NoRequestNoResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestNoResponse>(this->client_end());
  }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>
  NoRequestEmptyResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestEmptyResponse>(this->client_end());
  }

  // Allocates 16 bytes of request buffer on the stack. Response is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>
  NoRequestWithResponse() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            NoRequestWithResponse>(this->client_end(), _response_buffer.data,
                                   _response_buffer.capacity);
  }

  // Request is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestNoResponse>
  WithRequestNoResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(this->client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>
  WithRequestNoResponse(::fidl::BufferSpan _request_buffer,
                        ::fidl::StringView arg) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestNoResponse>(this->client_end(), _request_buffer.data,
                                   _request_buffer.capacity, arg);
  }

  // Allocates 16 bytes of response buffer on the stack. Request is
  // heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(this->client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse(::fidl::BufferSpan _request_buffer,
                           ::fidl::StringView arg,
                           ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestEmptyResponse>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Request is heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>
  WithRequestWithResponse(::fidl::StringView arg) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(this->client_end(), arg);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse(::fidl::BufferSpan _request_buffer,
                          ::fidl::StringView arg,
                          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithAndWithoutRequestResponse::
            WithRequestWithResponse>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, arg,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
      client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::fidl::StringView ret);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::fidl::StringView ret);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse> : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse> : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::fidl::StringView ret);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::fidl::StringView ret);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol =
      ::fidl_test_protocols::WithAndWithoutRequestResponse;

  using NoRequestNoResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestNoResponse>;
  using NoRequestNoResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestNoResponse>;

  virtual void NoRequestNoResponse(
      NoRequestNoResponseRequestView request,
      NoRequestNoResponseCompleter::Sync& _completer) = 0;

  using NoRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>;
  using NoRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseRequestView request,
      NoRequestEmptyResponseCompleter::Sync& _completer) = 0;

  using NoRequestWithResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>;
  using NoRequestWithResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseRequestView request,
      NoRequestWithResponseCompleter::Sync& _completer) = 0;

  using WithRequestNoResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>;
  using WithRequestNoResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestNoResponse>;

  virtual void WithRequestNoResponse(
      WithRequestNoResponseRequestView request,
      WithRequestNoResponseCompleter::Sync& _completer) = 0;

  using WithRequestEmptyResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;
  using WithRequestEmptyResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(
      WithRequestEmptyResponseRequestView request,
      WithRequestEmptyResponseCompleter::Sync& _completer) = 0;

  using WithRequestWithResponseCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>;
  using WithRequestWithResponseRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>;

  virtual void WithRequestWithResponse(
      WithRequestWithResponseRequestView request,
      WithRequestWithResponseCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalRequestRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalRequestResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalOneWayResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalEventRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_TransitionalEventEventTable;

class Transitional final {
  Transitional() = delete;

 public:
  class Request final {
    Request() = delete;
  };
  class OneWay final {
    OneWay() = delete;
  };
  class Event final {
    Event() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<::fidl_test_protocols::Transitional> {
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::Transitional>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::Transitional>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::Transitional>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request> final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t x;
  explicit WireRequest(int64_t x) : x(x) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_TransitionalRequestRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t x)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, x) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t x)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{x};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t x)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), x) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t x)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), x) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<
            ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::Transitional::Request>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<
          ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t y;
  explicit WireResponse(int64_t y) : y(y) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_TransitionalRequestResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t y)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, y) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t y)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{y};
      message_.Encode<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>(
          response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t y)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), y) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t y)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), y) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::Transitional::Request>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay> final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t x;
  explicit WireRequest(int64_t x) : x(x) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_TransitionalOneWayRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t x)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, x) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t x)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{x};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t x)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), x) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t x)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), x) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<
            ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::Transitional::OneWay>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<
          ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event> final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t x;
  explicit WireResponse(int64_t x) : x(x) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::fidl_test_protocols_TransitionalEventEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t x)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, x) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t x)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{x};
      message_.Encode<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>(
          response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t x)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), x) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t x)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), x) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<
            ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Event>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      int64_t x);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      int64_t x, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t x,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>&&
          decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>* Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*>(
        bytes_);
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>& value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      int64_t x);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t x);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a |fidl::ClientEnd<::fidl_test_protocols::Transitional>|,
// avoiding setting up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::Transitional> final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> client_end)
      : client_end_(client_end) {}

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::Transitional::Request>
  Request(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client_end,
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::Request>(
        _client_end, x);
  }
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> Request(
      int64_t x) && {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::Request>(
        client_end_, x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client_end,
      ::fidl::BufferSpan _request_buffer, int64_t x,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::Request>(
        _client_end, _request_buffer.data, _request_buffer.capacity, x,
        _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request(::fidl::BufferSpan _request_buffer, int64_t x,
          ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::Request>(
        client_end_, _request_buffer.data, _request_buffer.capacity, x,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client_end,
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay>(
        _client_end, x);
  }
  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      int64_t x) && {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay>(
        client_end_, x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay>
  OneWay(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> _client_end,
      ::fidl::BufferSpan _request_buffer, int64_t x) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::OneWay>(
        _client_end, _request_buffer.data, _request_buffer.capacity, x);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      ::fidl::BufferSpan _request_buffer, int64_t x) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::OneWay>(
        client_end_, _request_buffer.data, _request_buffer.capacity, x);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::Transitional> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void Event(
      ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>* event) {
  }
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::Transitional>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::Transitional>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::Transitional> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::Transitional> client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::Transitional> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::Transitional> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::Transitional>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::Transitional>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> Request(
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::Request>(
        this->client_end(), x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request(::fidl::BufferSpan _request_buffer, int64_t x,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::Request>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, x,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      int64_t x) {
    return ::fidl::WireResult<::fidl_test_protocols::Transitional::OneWay>(
        this->client_end(), x);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::OneWay> OneWay(
      ::fidl::BufferSpan _request_buffer, int64_t x) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::Transitional::OneWay>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, x);
  }

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<::fidl_test_protocols::Transitional>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::Transitional> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::Transitional::Request>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(int64_t y);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, int64_t y);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::Transitional::Request>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::Transitional>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::Transitional;

  using RequestCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::Transitional::Request>;
  using RequestRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::Transitional::Request>;

  virtual void Request(RequestRequestView request,
                       RequestCompleter::Sync& _completer) {
    _completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

  using OneWayCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::Transitional::OneWay>;
  using OneWayRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequestView request,
                      OneWayCompleter::Sync& _completer) {
    _completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_MethodWithUnionUnionMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_MethodWithUnionUnionMethodResponseTable;

class MethodWithUnion final {
  MethodWithUnion() = delete;

 public:
  class UnionMethod final {
    UnionMethod() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::MethodWithUnion> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::MethodWithUnion>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::MethodWithUnion>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::MethodWithUnion>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::TheUnion u;
  explicit WireRequest(::fidl_test_protocols::wire::TheUnion u) : u(u) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_MethodWithUnionUnionMethodRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr uint32_t AltPrimarySize = 40;
  static constexpr uint32_t AltMaxOutOfLine = 8;
  static constexpr bool HasFlexibleEnvelope = true;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size,
                          ::fidl_test_protocols::wire::TheUnion u)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, u) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size,
                          ::fidl_test_protocols::wire::TheUnion u)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{u};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl_test_protocols::wire::TheUnion u)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), u) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::TheUnion u)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), u) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::MethodWithUnion::UnionMethod>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::MethodWithUnion::UnionMethod>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion> _client,
      ::fidl_test_protocols::wire::TheUnion u);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::MethodWithUnion::UnionMethod>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl_test_protocols::wire::TheUnion u);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::MethodWithUnion>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion>
          client_end)
      : client_end_(client_end) {}

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion>
                  _client_end,
              ::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(_client_end, u);
  }
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl_test_protocols::wire::TheUnion u) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(client_end_, u);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion>
                  _client_end,
              ::fidl::BufferSpan _request_buffer,
              ::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(
        _client_end, _request_buffer.data, _request_buffer.capacity, u);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl::BufferSpan _request_buffer,
              ::fidl_test_protocols::wire::TheUnion u) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(
        client_end_, _request_buffer.data, _request_buffer.capacity, u);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion> client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::MethodWithUnion> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::MethodWithUnion>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::MethodWithUnion>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::MethodWithUnion> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::MethodWithUnion>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::MethodWithUnion> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(this->client_end(),
                                                             u);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::MethodWithUnion::UnionMethod>
  UnionMethod(::fidl::BufferSpan _request_buffer,
              ::fidl_test_protocols::wire::TheUnion u) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, u);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::MethodWithUnion> client_end_;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::MethodWithUnion>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::MethodWithUnion;

  using UnionMethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequestView request,
                           UnionMethodCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
namespace wire {

#ifdef __Fuchsia__

extern "C" const fidl_type_t fidl_test_protocols_ProtocolEndsTable;

struct ProtocolEnds {
  static constexpr const fidl_type_t* Type =
      &fidl_test_protocols_ProtocolEndsTable;
  static constexpr uint32_t MaxNumHandles = 4;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> client = {};

  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> server = {};

  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> client_opt =
      {};

  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> server_opt =
      {};

  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                          ProtocolEnds* value)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                backing_buffer, backing_buffer_size, value) {}
    UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                          uint32_t backing_buffer_size, ProtocolEnds* value)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = backing_buffer,
              .backing_buffer_capacity = backing_buffer_size,
          }) {
      ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
      message_.Encode<ProtocolEnds>(value);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(ProtocolEnds* value)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), value) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ProtocolEnds* value)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), value) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }

   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<ProtocolEnds> {
   public:
    using DecodedMessageBase<ProtocolEnds>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              ::fidl::internal::kLLCPPInMemoryWireFormatVersion,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(
              wire_format_version,
              ::fidl::IncomingMessage(
                  bytes, byte_actual, handles, handle_actual,
                  ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

    DecodedMessage(const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }

    // Internal constructor for specifying a specific wire format version.
    DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                   const fidl_incoming_msg_t* c_msg)
        : DecodedMessage(wire_format_version,
                         reinterpret_cast<uint8_t*>(c_msg->bytes),
                         c_msg->num_bytes, c_msg->handles, c_msg->num_handles) {
    }
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ProtocolEnds* PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<ProtocolEnds*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };
};
#endif  // __Fuchsia__

}  // namespace wire
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsClientEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsClientEndsResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsServerEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsServerEndsResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithProtocolEndsStructContainingEndsResponseTable;

class WithProtocolEnds final {
  WithProtocolEnds() = delete;

 public:
  class ClientEnds final {
    ClientEnds() = delete;
  };
  class ServerEnds final {
    ServerEnds() = delete;
  };
  class StructContainingEnds final {
    StructContainingEnds() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::WithProtocolEnds> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::WithProtocolEnds>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithProtocolEnds>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithProtocolEnds>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> in;
  explicit WireRequest(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : in(std::move(in)) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsClientEndsRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(in)) {}
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(in)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(in)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(in)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithProtocolEnds::ClientEnds>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> out;
  explicit WireResponse(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : out(std::move(out)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsClientEndsResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(out)) {}
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{std::move(out)};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(out)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(out)) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::ClientEnds>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::ClientEnds>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::ClientEnds>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> in;
  explicit WireRequest(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
      : in(std::move(in)) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsServerEndsRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(in)) {}
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(in)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(in)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(in)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithProtocolEnds::ServerEnds>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> out;
  explicit WireResponse(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
      : out(std::move(out)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsServerEndsResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(out)) {}
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{std::move(out)};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(out)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(out)) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::ServerEnds>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::ServerEnds>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::ServerEnds>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::ProtocolEnds in;
  explicit WireRequest(::fidl_test_protocols::wire::ProtocolEnds&& in)
      : in(std::move(in)) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
  static constexpr uint32_t MaxNumHandles = 4;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size,
                          ::fidl_test_protocols::wire::ProtocolEnds&& in)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(in)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size,
                          ::fidl_test_protocols::wire::ProtocolEnds&& in)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(in)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::fidl_test_protocols::wire::ProtocolEnds&& in)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(in)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::ProtocolEnds&& in)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(in)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::ProtocolEnds out;
  explicit WireResponse(::fidl_test_protocols::wire::ProtocolEnds&& out)
      : out(std::move(out)) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithProtocolEndsStructContainingEndsResponseTable;
  static constexpr uint32_t MaxNumHandles = 4;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size,
                          ::fidl_test_protocols::wire::ProtocolEnds&& out)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(out)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size,
                          ::fidl_test_protocols::wire::ProtocolEnds&& out)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{std::move(out)};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>(
          response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl_test_protocols::wire::ProtocolEnds&& out)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(out)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::ProtocolEnds&& out)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(out)) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl_test_protocols::wire::ProtocolEnds&& in);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      ::fidl_test_protocols::wire::ProtocolEnds&& in, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::fidl_test_protocols::wire::ProtocolEnds&& in, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>&&
          decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*>(
        bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::WithProtocolEnds>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          client_end)
      : client_end_(client_end) {}

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          _client_end,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(_client_end,
                                                             std::move(in));
  }
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(client_end_,
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          _client_end,
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          _client_end,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(_client_end,
                                                             std::move(in));
  }
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(client_end_,
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          _client_end,
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          _client_end,
      ::fidl_test_protocols::wire::ProtocolEnds&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        _client_end, std::move(in));
  }
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl_test_protocols::wire::ProtocolEnds&& in) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        client_end_, std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          _client_end,
      ::fidl::BufferSpan _request_buffer,
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl::BufferSpan _request_buffer,
                       ::fidl_test_protocols::wire::ProtocolEnds&& in,
                       ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds> client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::WithProtocolEnds> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithProtocolEnds>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithProtocolEnds> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithProtocolEnds>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::WithProtocolEnds> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(this->client_end(),
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(this->client_end(),
                                                             std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl_test_protocols::wire::ProtocolEnds&& in) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        this->client_end(), std::move(in));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds(::fidl::BufferSpan _request_buffer,
                       ::fidl_test_protocols::wire::ProtocolEnds&& in,
                       ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(in), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::WithProtocolEnds> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& out);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::fidl_test_protocols::wire::ProtocolEnds&& out);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer,
                       ::fidl_test_protocols::wire::ProtocolEnds&& out);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::WithProtocolEnds>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::WithProtocolEnds;

  using ClientEndsCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequestView request,
                          ClientEndsCompleter::Sync& _completer) = 0;

  using ServerEndsCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequestView request,
                          ServerEndsCompleter::Sync& _completer) = 0;

  using StructContainingEndsCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(
      StructContainingEndsRequestView request,
      StructContainingEndsCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ManyParametersFifteenRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ManyParametersFifteenResponseTable;

class ManyParameters final {
  ManyParameters() = delete;

 public:
  class Fifteen final {
    Fifteen() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::ManyParameters> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::ManyParameters>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::ManyParameters>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::ManyParameters>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  bool p1;
  bool p2;
  bool p3;
  bool p4;
  bool p5;
  bool p6;
  bool p7;
  bool p8;
  bool p9;
  bool p10;
  bool p11;
  bool p12;
  bool p13;
  bool p14;
  bool p15;
  explicit WireRequest(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                       bool p7, bool p8, bool p9, bool p10, bool p11, bool p12,
                       bool p13, bool p14, bool p15)
      : p1(p1),
        p2(p2),
        p3(p3),
        p4(p4),
        p5(p5),
        p6(p6),
        p7(p7),
        p8(p8),
        p9(p9),
        p10(p10),
        p11(p11),
        p12(p12),
        p13(p13),
        p14(p14),
        p15(p15) {
    _InitHeader();
  }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ManyParametersFifteenRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, bool p1, bool p2,
                          bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
                          bool p9, bool p10, bool p11, bool p12, bool p13,
                          bool p14, bool p15)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, p1, p2,
                                p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13,
                                p14, p15) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, bool p1, bool p2,
                          bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
                          bool p9, bool p10, bool p11, bool p12, bool p13,
                          bool p14, bool p15)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
                                          p9, p10, p11, p12, p13, p14, p15};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(bool p1, bool p2, bool p3, bool p4, bool p5,
                                 bool p6, bool p7, bool p8, bool p9, bool p10,
                                 bool p11, bool p12, bool p13, bool p14,
                                 bool p15)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), p1, p2,
                   p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, bool p1, bool p2,
        bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
        bool p11, bool p12, bool p13, bool p14, bool p15)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), p1, p2, p3, p4, p5, p6, p7, p8, p9,
                   p10, p11, p12, p13, p14, p15) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::ManyParameters::Fifteen>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::ManyParameters::Fifteen>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<
          ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>*>(
          bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters> _client,
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::ManyParameters::Fifteen>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, bool p1,
      bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8, bool p9,
      bool p10, bool p11, bool p12, bool p13, bool p14, bool p15);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::ManyParameters>|, avoiding setting up
// a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::ManyParameters>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters>
          client_end)
      : client_end_(client_end) {}

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen>
  Fifteen(::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters>
              _client_end,
          bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7,
          bool p8, bool p9, bool p10, bool p11, bool p12, bool p13, bool p14,
          bool p15) {
    return ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen>(
        _client_end, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13,
        p14, p15);
  }
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen> Fifteen(
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) && {
    return ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen>(
        client_end_, p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13,
        p14, p15);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ManyParameters::Fifteen>
  Fifteen(::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters>
              _client_end,
          ::fidl::BufferSpan _request_buffer, bool p1, bool p2, bool p3,
          bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
          bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ManyParameters::Fifteen>(
        _client_end, _request_buffer.data, _request_buffer.capacity, p1, p2, p3,
        p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ManyParameters::Fifteen>
  Fifteen(::fidl::BufferSpan _request_buffer, bool p1, bool p2, bool p3,
          bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
          bool p11, bool p12, bool p13, bool p14, bool p15) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ManyParameters::Fifteen>(
        client_end_, _request_buffer.data, _request_buffer.capacity, p1, p2, p3,
        p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters> client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::ManyParameters> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ManyParameters>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::ManyParameters>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ManyParameters> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ManyParameters>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::ManyParameters> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen> Fifteen(
      bool p1, bool p2, bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
      bool p9, bool p10, bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireResult<::fidl_test_protocols::ManyParameters::Fifteen>(
        this->client_end(), p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12,
        p13, p14, p15);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ManyParameters::Fifteen>
  Fifteen(::fidl::BufferSpan _request_buffer, bool p1, bool p2, bool p3,
          bool p4, bool p5, bool p6, bool p7, bool p8, bool p9, bool p10,
          bool p11, bool p12, bool p13, bool p14, bool p15) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ManyParameters::Fifteen>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, p1,
        p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::ManyParameters> client_end_;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::ManyParameters>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::ManyParameters;

  using FifteenCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ManyParameters::Fifteen>;
  using FifteenRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequestView request,
                       FifteenCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxResponseAsStructRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxResponseAsStructResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsEnumRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxErrorAsEnumResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxHandleInResultRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_WithErrorSyntaxHandleInResultResponseTable;

class WithErrorSyntax final {
  WithErrorSyntax() = delete;

 public:
  class ResponseAsStruct final {
    ResponseAsStruct() = delete;
  };
  class ErrorAsPrimitive final {
    ErrorAsPrimitive() = delete;
  };
  class ErrorAsEnum final {
    ErrorAsEnum() = delete;
  };
  class HandleInResult final {
    HandleInResult() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::WithErrorSyntax> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::WithErrorSyntax>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithErrorSyntax>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::WithErrorSyntax>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
  using Result =
      fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxResponseAsStructResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  static constexpr uint32_t MaxOutOfLine = 24;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
            result)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, result) {
    }
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
            result)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{result};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
            result)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), result) {
    }
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
            result)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), result) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<64> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
  using Result =
      fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxErrorAsPrimitiveResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
            result)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, result) {
    }
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
            result)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{result};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
            result)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), result) {
    }
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
            result)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), result) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final {
  using Result = fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxErrorAsEnumResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 40;
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, result) {
    }
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{result};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), result) {
    }
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), result) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::WithErrorSyntax::HandleInResult>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final {
  using Result = fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult;

  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result;
  explicit WireResponse(
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
      : result(result) {
    _InitHeader();
  }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_WithErrorSyntaxHandleInResultResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 40;
  static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = true;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(
        uint8_t* _backing_buffer, uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, result) {
    }
    UnownedEncodedMessage(
        uint32_t _iovec_capacity, uint8_t* _backing_buffer,
        uint32_t _backing_buffer_size,
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{result};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), result) {
    }
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), result) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::WithErrorSyntax::HandleInResult>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<64> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*>(bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(bytes_);
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> _client,
      uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::WithErrorSyntax>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          client_end)
      : client_end_(client_end) {}

  // Allocates 80 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(_client_end);
  }
  // Allocates 80 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(client_end_);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          _client_end,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        _client_end, _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct(::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        client_end_, _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(_client_end);
  }
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(client_end_);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          _client_end,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        _client_end, _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive(::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        client_end_, _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum(::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
                  _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(_client_end);
  }
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(client_end_);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum(::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
                  _client_end,
              ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        _client_end, _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum(::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        client_end_, _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(_client_end);
  }
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(client_end_);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          _client_end,
      ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        _client_end, _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult(::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        client_end_, _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax> client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::WithErrorSyntax> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithErrorSyntax>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::WithErrorSyntax> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::WithErrorSyntax>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::WithErrorSyntax> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 80 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        this->client_end());
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult(::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>(
        this->client_end(), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::WithErrorSyntax> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
          result);
  ::fidl::Result ReplySuccess(int64_t a, int64_t b, int64_t c);
  ::fidl::Result ReplyError(uint32_t error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult
          result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer, int64_t a, int64_t b,
                              int64_t c);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
          result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(uint32_t error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult
          result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  ::fidl::Result ReplySuccess();
  ::fidl::Result ReplyError(::fidl_test_protocols::wire::ErrorEnum error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  ::fidl::Result ReplySuccess(::zx::handle&& h);
  ::fidl::Result ReplyError(uint32_t error);
  ::fidl::Result Reply(
      ::fidl::BufferSpan _buffer,
      ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult result);
  ::fidl::Result ReplySuccess(::fidl::BufferSpan _buffer, ::zx::handle&& h);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::WithErrorSyntax>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::WithErrorSyntax;

  using ResponseAsStructCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>;
  using ResponseAsStructRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(
      ResponseAsStructRequestView request,
      ResponseAsStructCompleter::Sync& _completer) = 0;

  using ErrorAsPrimitiveCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
  using ErrorAsPrimitiveRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(
      ErrorAsPrimitiveRequestView request,
      ErrorAsPrimitiveCompleter::Sync& _completer) = 0;

  using ErrorAsEnumCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>;
  using ErrorAsEnumRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(ErrorAsEnumRequestView request,
                           ErrorAsEnumCompleter::Sync& _completer) = 0;

  using HandleInResultCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>;
  using HandleInResultRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(HandleInResultRequestView request,
                              HandleInResultCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_DiscoverableProtocolMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_DiscoverableProtocolMethodResponseTable;

class DiscoverableProtocol final {
  DiscoverableProtocol() = delete;

 public:
  class Method final {
    Method() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::DiscoverableProtocol> {
  static constexpr char DiscoverableName[] =
      "fidl.test.protocols.DiscoverableProtocol";
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::DiscoverableProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 16;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::DiscoverableProtocol::Method>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::DiscoverableProtocol::Method>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::DiscoverableProtocol::Method>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          _client);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::DiscoverableProtocol::Method>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          _client);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>|, avoiding
// setting up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::DiscoverableProtocol>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          client_end)
      : client_end_(client_end) {}

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
  Method(::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
             _client_end) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::DiscoverableProtocol::Method>(_client_end);
  }
  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
  Method() && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::DiscoverableProtocol::Method>(client_end_);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
      client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::DiscoverableProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::DiscoverableProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::DiscoverableProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::DiscoverableProtocol>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::DiscoverableProtocol>
    final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&
  client_end() const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::DiscoverableProtocol::Method>
  Method() {
    return ::fidl::WireResult<
        ::fidl_test_protocols::DiscoverableProtocol::Method>(
        this->client_end());
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol> client_end_;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::DiscoverableProtocol;

  using MethodCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::DiscoverableProtocol::Method>;
  using MethodRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(MethodRequestView request,
                      MethodCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl_test_protocols {
__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodAResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolEventARequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolEventAEventTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodBRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMethodBResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolTakeHandleResponseTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMutateSocketRequestTable;

__LOCAL extern "C" const fidl_type_t
    fidl_test_protocols_ChannelProtocolMutateSocketResponseTable;

class ChannelProtocol final {
  ChannelProtocol() = delete;

 public:
  class MethodA final {
    MethodA() = delete;
  };
  class EventA final {
    EventA() = delete;
  };
  class MethodB final {
    MethodB() = delete;
  };
  class TakeHandle final {
    TakeHandle() = delete;
  };
  class MutateSocket final {
    MutateSocket() = delete;
  };
};
}  // namespace fidl_test_protocols
#ifdef __Fuchsia__

template <>
struct ::fidl::internal::ProtocolDetails<
    ::fidl_test_protocols::ChannelProtocol> {};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::WireServerDispatcher<
    ::fidl_test_protocols::ChannelProtocol>
    final {
  WireServerDispatcher() = delete;
  static ::fidl::DispatchResult TryDispatch(
      ::fidl::WireServer<::fidl_test_protocols::ChannelProtocol>* impl,
      ::fidl::IncomingMessage& msg, ::fidl::Transaction* txn);
  static ::fidl::DispatchResult Dispatch(
      ::fidl::WireServer<::fidl_test_protocols::ChannelProtocol>* impl,
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn);
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t a;
  int64_t b;
  explicit WireRequest(int64_t a, int64_t b) : a(a), b(b) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMethodARequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t a, int64_t b)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, a, b) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t a, int64_t b)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{a, b};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t a, int64_t b)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), a, b) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t a,
        int64_t b)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), a, b) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::ChannelProtocol::MethodA>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MethodA>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::MethodA>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t a;
  int64_t b;
  explicit WireResponse(int64_t a, int64_t b) : a(a), b(b) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolEventAEventTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t a, int64_t b)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, a, b) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t a, int64_t b)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{a, b};
      message_.Encode<
          ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>(
          &_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<
          ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>(
          response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t a, int64_t b)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), a, b) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t a,
        int64_t b)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), a, b) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::EventA>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::EventA>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::EventA>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t a;
  int64_t b;
  explicit WireRequest(int64_t a, int64_t b) : a(a), b(b) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMethodBRequestTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 32;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType =
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t a, int64_t b)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, a, b) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t a, int64_t b)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{a, b};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t a, int64_t b)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), a, b) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t a,
        int64_t b)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), a, b) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::ChannelProtocol::MethodB>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MethodB>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::MethodB>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
template <>
struct ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  int64_t result;
  explicit WireResponse(int64_t result) : result(result) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMethodBResponseTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t result)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size, result) {
    }
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, int64_t result)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{result};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MethodB>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MethodB>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(int64_t result)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(), result) {
    }
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, int64_t result)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), result) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
            response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
            response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::MethodB>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>>::DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MethodB>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::handle h;
  explicit WireRequest(::zx::handle&& h) : h(std::move(h)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolTakeHandleRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::handle&& h)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(h)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::handle&& h)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(h)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::handle&& h)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(h)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::handle&& h)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(h)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::ChannelProtocol::TakeHandle>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

template <>
struct ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl::_llcpp_coding_AnyZeroArgMessageTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::IovecBuffer iovecs_;
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage()
        : message_(1u, backing_buffer_.data(), backing_buffer_.size()) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size()) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::TakeHandle>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::TakeHandle>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
    const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
#ifdef __Fuchsia__
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }
#endif  // __Fuchsia__
   private:
    ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::TakeHandle>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}

    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#ifdef __Fuchsia__

template <>
struct ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket a;
  explicit WireRequest(::zx::socket&& a) : a(std::move(a)) { _InitHeader(); }
  WireRequest() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMutateSocketRequestTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr uint32_t AltPrimarySize = 24;
  static constexpr uint32_t AltMaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kRequest;
  using ResponseType = ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& a)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(a)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& a)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireRequest _request{std::move(a)};
      message_.Encode<WireRequest>(&_request);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                request) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireRequest* request)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<WireRequest>(request);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::socket&& a)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(a)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& a)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(a)) {}
    explicit OwnedEncodedMessage(WireRequest* request)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   request) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        WireRequest* request)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), request) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireRequest<
            ::fidl_test_protocols::ChannelProtocol::MutateSocket>> {
   public:
    using DecodedMessageBase<::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireRequest<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct ::fidl::WireResponse<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final {
  FIDL_ALIGNDECL
  fidl_message_header_t _hdr;
  ::zx::socket b;
  explicit WireResponse(::zx::socket&& b) : b(std::move(b)) { _InitHeader(); }
  WireResponse() { _InitHeader(); }

  static constexpr const fidl_type_t* Type =
      &::fidl_test_protocols::
          fidl_test_protocols_ChannelProtocolMutateSocketResponseTable;
  static constexpr uint32_t MaxNumHandles = 1;
  static constexpr uint32_t PrimarySize = 24;
  static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasFlexibleEnvelope = false;
  static constexpr bool HasPointer = false;
  static constexpr ::fidl::internal::TransactionalMessageKind MessageKind =
      ::fidl::internal::TransactionalMessageKind::kResponse;
  void _CloseHandles();

  class UnownedEncodedMessage final {
   public:
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& b)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                std::move(b)) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, ::zx::socket&& b)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      FIDL_ALIGNDECL WireResponse _response{std::move(b)};
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>>(&_response);
    }
    UnownedEncodedMessage(uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : UnownedEncodedMessage(::fidl::internal::IovecBufferSize,
                                _backing_buffer, _backing_buffer_size,
                                response) {}
    UnownedEncodedMessage(uint32_t _iovec_capacity, uint8_t* _backing_buffer,
                          uint32_t _backing_buffer_size, WireResponse* response)
        : message_(::fidl::OutgoingMessage::ConstructorArgs{
              .iovecs = iovecs_,
              .iovec_capacity = _iovec_capacity,
              .handles = handles_,
              .handle_capacity =
                  std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles),
              .backing_buffer = _backing_buffer,
              .backing_buffer_capacity = _backing_buffer_size,
          }) {
      ZX_ASSERT(_iovec_capacity <= std::size(iovecs_));
      message_.Encode<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>>(response);
    }
    UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
    UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
    UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.status() == ZX_OK; }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::IovecBuffer iovecs_;
    zx_handle_disposition_t
        handles_[std::min(ZX_CHANNEL_MAX_MSG_HANDLES, MaxNumHandles)];
    ::fidl::OutgoingMessage message_;
  };

  class OwnedEncodedMessage final {
   public:
    explicit OwnedEncodedMessage(::zx::socket&& b)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   std::move(b)) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned, ::zx::socket&& b)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), std::move(b)) {}
    explicit OwnedEncodedMessage(
        ::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)
        : message_(1u, backing_buffer_.data(), backing_buffer_.size(),
                   response) {}
    // Internal constructor.
    explicit OwnedEncodedMessage(
        ::fidl::internal::AllowUnownedInputRef allow_unowned,
        ::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)
        : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                   backing_buffer_.size(), response) {}
    OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
    OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
    OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

    zx_status_t status() const { return message_.status(); }
    const char* status_string() const { return message_.status_string(); }
    bool ok() const { return message_.ok(); }
    std::string FormatDescription() const {
      return message_.FormatDescription();
    }
    const char* lossy_description() const {
      return message_.lossy_description();
    }
    const ::fidl::Result& error() const { return message_.error(); }

    ::fidl::OutgoingMessage& GetOutgoingMessage() {
      return message_.GetOutgoingMessage();
    }
    template <typename ChannelLike>
    void Write(ChannelLike&& client) {
      message_.Write(std::forward<ChannelLike>(client));
    }

   private:
    ::fidl::internal::InlineMessageBuffer<24> backing_buffer_;
    UnownedEncodedMessage message_;
  };

 public:
  class DecodedMessage final
      : public ::fidl::internal::DecodedMessageBase<::fidl::WireResponse<
            ::fidl_test_protocols::ChannelProtocol::MutateSocket>> {
   public:
    using DecodedMessageBase<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>>::
        DecodedMessageBase;

    DecodedMessage(uint8_t* bytes, uint32_t byte_actual,
                   zx_handle_info_t* handles = nullptr,
                   uint32_t handle_actual = 0)
        : DecodedMessageBase(::fidl::IncomingMessage(bytes, byte_actual,
                                                     handles, handle_actual)) {}
    ~DecodedMessage() {
      if (ok() && (PrimaryObject() != nullptr)) {
        PrimaryObject()->_CloseHandles();
      }
    }

    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
    PrimaryObject() {
      ZX_DEBUG_ASSERT(ok());
      return reinterpret_cast<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes());
    }

    // Release the ownership of the decoded message. That means that the handles
    // won't be closed When the object is destroyed. After calling this method,
    // the |DecodedMessage| object should not be used anymore.
    void ReleasePrimaryObject() { ResetBytes(); }
  };

 private:
  void _InitHeader();
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      int64_t a, int64_t b);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

 private:
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodA>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t a,
      int64_t b);
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB> final
    : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      int64_t a, int64_t b);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      int64_t a, int64_t b, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*>(
        bytes_.data());
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity, int64_t a,
      int64_t b, uint8_t* _response_bytes, uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MethodB>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*>(
        bytes_);
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::handle&& h);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::handle&& h, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::handle&& h, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
          response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() = default;

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};
template <>
class ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final : public ::fidl::Result {
 public:
  explicit WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::socket&& a);
  WireResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      ::zx::socket&& a, zx_time_t _deadline);
  explicit WireResult(const ::fidl::Result& result) : ::fidl::Result(result) {}
  WireResult(WireResult&&) = delete;
  WireResult(const WireResult&) = delete;
  WireResult* operator=(WireResult&&) = delete;
  WireResult* operator=(const WireResult&) = delete;
  ~WireResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_.data());
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_.data());
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() const {
    return value();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<24> bytes_;
};
template <>
class ::fidl::WireUnownedResult<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    final : public ::fidl::Result {
 public:
  explicit WireUnownedResult(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> _client,
      uint8_t* _request_bytes, uint32_t _request_byte_capacity,
      ::zx::socket&& a, uint8_t* _response_bytes,
      uint32_t _response_byte_capacity);
  explicit WireUnownedResult(
      ::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)
      : bytes_(reinterpret_cast<uint8_t*>(response)) {}
  explicit WireUnownedResult(const ::fidl::Result& result)
      : ::fidl::Result(result) {}
  explicit WireUnownedResult(
      ::fidl::DecodedMessage<::fidl::WireResponse<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>>&& decoded)
      : ::fidl::Result(decoded) {
    if (decoded.ok()) {
      bytes_ = reinterpret_cast<uint8_t*>(decoded.PrimaryObject());
    } else {
      bytes_ = nullptr;
    }
    decoded.ReleasePrimaryObject();
  }
  WireUnownedResult(WireUnownedResult&&) = delete;
  WireUnownedResult(const WireUnownedResult&) = delete;
  WireUnownedResult* operator=(WireUnownedResult&&) = delete;
  WireUnownedResult* operator=(const WireUnownedResult&) = delete;
  ~WireUnownedResult() {
    if (ok()) {
      Unwrap()->_CloseHandles();
    }
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_);
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  Unwrap() const {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<const ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>*>(bytes_);
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() {
    return *Unwrap();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  value() const {
    return *Unwrap();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() {
    return &value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>*
  operator->() const {
    return &value();
  }

  ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() {
    return value();
  }
  const ::fidl::WireResponse<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>&
  operator*() const {
    return value();
  }

 private:
  uint8_t* bytes_;
};

// Methods to make a sync FIDL call directly on an unowned channel or a
// const reference to a
// |fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol>|, avoiding setting
// up a client.
template <>
class ::fidl::internal::WireCaller<::fidl_test_protocols::ChannelProtocol>
    final {
 public:
  explicit WireCaller(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
          client_end)
      : client_end_(client_end) {}

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA>
  MethodA(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
              _client_end,
          int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA>(
        _client_end, a, b);
  }
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA> MethodA(
      int64_t a, int64_t b) && {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA>(
        client_end_, a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MethodA>
  MethodA(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
              _client_end,
          ::fidl::BufferSpan _request_buffer, int64_t a, int64_t b) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodA>(
        _client_end, _request_buffer.data, _request_buffer.capacity, a, b);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodA>
  MethodA(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodA>(
        client_end_, _request_buffer.data, _request_buffer.capacity, a, b);
  }

  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
              _client_end,
          int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>(
        _client_end, a, b);
  }
  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b) && {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>(
        client_end_, a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
              _client_end,
          ::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodB>(
        _client_end, _request_buffer.data, _request_buffer.capacity, a, b,
        _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
          ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodB>(
        client_end_, _request_buffer.data, _request_buffer.capacity, a, b,
        _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
                 _client_end,
             ::zx::handle&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(_client_end,
                                                            std::move(h));
  }
  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::zx::handle&& h) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(client_end_,
                                                            std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
                 _client_end,
             ::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
             ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
             ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  static ::fidl::WireResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
                   _client_end,
               ::zx::socket&& a) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(_client_end,
                                                              std::move(a));
  }
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a) && {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(client_end_,
                                                              std::move(a));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  static ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
                   _client_end,
               ::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
               ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        _client_end, _request_buffer.data, _request_buffer.capacity,
        std::move(a), _response_buffer.data, _response_buffer.capacity);
  }
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
               ::fidl::BufferSpan _response_buffer) && {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        client_end_, _request_buffer.data, _request_buffer.capacity,
        std::move(a), _response_buffer.data, _response_buffer.capacity);
  }

 private:
  ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol> client_end_;
};
template <>
class ::fidl::internal::WireEventHandlerInterface<
    ::fidl_test_protocols::ChannelProtocol> {
 public:
  WireEventHandlerInterface() = default;
  virtual ~WireEventHandlerInterface() = default;
  virtual void EventA(
      ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>*
          event) {}
};

template <>
class ::fidl::WireAsyncEventHandler<::fidl_test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ChannelProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  WireAsyncEventHandler() = default;
};

template <>
class ::fidl::WireSyncEventHandler<::fidl_test_protocols::ChannelProtocol>
    : public ::fidl::internal::WireEventHandlerInterface<
          ::fidl_test_protocols::ChannelProtocol> {
 public:
  WireSyncEventHandler() = default;

  // Method called when an unknown event is found. This methods gives the status
  // which, in this case, is returned by HandleOneEvent.
  virtual zx_status_t Unknown() = 0;

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method.
  ::fidl::Result HandleOneEvent(
      ::fidl::UnownedClientEnd<::fidl_test_protocols::ChannelProtocol>
          client_end);
};
template <>
class ::fidl::WireSyncClient<::fidl_test_protocols::ChannelProtocol> final {
 public:
  WireSyncClient() = default;

  explicit WireSyncClient(
      ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol> client_end)
      : client_end_(std::move(client_end)) {}

  ~WireSyncClient() = default;
  WireSyncClient(WireSyncClient&&) = default;
  WireSyncClient& operator=(WireSyncClient&&) = default;

  const ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol>& client_end()
      const {
    return client_end_;
  }
  ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol>& client_end() {
    return client_end_;
  }

  const ::zx::channel& channel() const { return client_end_.channel(); }
  ::zx::channel* mutable_channel() { return &client_end_.channel(); }

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA> MethodA(
      int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodA>(
        this->client_end(), a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodA>
  MethodA(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodA>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, a,
        b);
  }

  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB> MethodB(
      int64_t a, int64_t b) {
    return ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>(
        this->client_end(), a, b);
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
          ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MethodB>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity, a,
        b, _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::zx::handle&& h) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(this->client_end(),
                                                            std::move(h));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle(::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
             ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(h), _response_buffer.data, _response_buffer.capacity);
  }

  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::zx::socket&& a) {
    return ::fidl::WireResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        this->client_end(), std::move(a));
  }

  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket(::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
               ::fidl::BufferSpan _response_buffer) {
    return ::fidl::WireUnownedResult<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>(
        this->client_end(), _request_buffer.data, _request_buffer.capacity,
        std::move(a), _response_buffer.data, _response_buffer.capacity);
  }

  // Handle all possible events defined in this protocol.
  // Blocks to consume exactly one message from the channel, then call the
  // corresponding virtual method defined in |SyncEventHandler|. The return
  // status of the handler function is folded with any transport-level errors
  // and returned.
  ::fidl::Result HandleOneEvent(
      ::fidl::WireSyncEventHandler<::fidl_test_protocols::ChannelProtocol>&
          event_handler) {
    return event_handler.HandleOneEvent(client_end_);
  }

 private:
  ::fidl::ClientEnd<::fidl_test_protocols::ChannelProtocol> client_end_;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(int64_t result);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, int64_t result);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::ChannelProtocol::MethodB>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>>;
};

template <>
class ::fidl::internal::WireCompleterBase<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::CompleterBase {
 public:
  // In the following methods, the return value indicates internal errors during
  // the reply, such as encoding or writing to the transport.
  // Note that any error will automatically lead to the destruction of the
  // binding, after which the |on_unbound| callback will be triggered with a
  // detailed reason.
  //
  // See //zircon/system/ulib/fidl/include/lib/fidl/llcpp/server.h.
  //
  // Because the reply status is identical to the unbinding status, it can be
  // safely ignored.
  ::fidl::Result Reply(::zx::socket&& b);
  ::fidl::Result Reply(::fidl::BufferSpan _buffer, ::zx::socket&& b);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
struct ::fidl::internal::WireMethodTypes<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::WireCompleterBase<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>>;
};

// Pure-virtual interface to be implemented by a server.
// This interface uses typed channels (i.e. |fidl::ClientEnd<SomeProtocol>|
// and |fidl::ServerEnd<SomeProtocol>|).
template <>
class ::fidl::WireServer<::fidl_test_protocols::ChannelProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  WireServer() = default;
  virtual ~WireServer() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::fidl_test_protocols::ChannelProtocol;

  using MethodACompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::MethodA>;
  using MethodARequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequestView request,
                       MethodACompleter::Sync& _completer) = 0;

  using MethodBCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::MethodB>;
  using MethodBRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequestView request,
                       MethodBCompleter::Sync& _completer) = 0;

  using TakeHandleCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequestView request,
                          TakeHandleCompleter::Sync& _completer) = 0;

  using MutateSocketCompleter = ::fidl::internal::WireCompleter<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketRequestView = ::fidl::internal::WireRequestView<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequestView request,
                            MutateSocketCompleter::Sync& _completer) = 0;

 private:
  ::fidl::DispatchResult dispatch_message(::fidl::IncomingMessage&& msg,
                                          ::fidl::Transaction* txn) final;
};
#endif  // __Fuchsia__

namespace fidl {

template <>
struct IsFidlType<::fidl_test_protocols::wire::Rights> : public std::true_type {
};
static_assert(std::is_standard_layout_v<::fidl_test_protocols::wire::Rights>);
static_assert(sizeof(::fidl_test_protocols::wire::Rights) == sizeof(uint32_t));

template <>
struct IsFidlType<::fidl_test_protocols::wire::ObjType>
    : public std::true_type {};

#ifdef __Fuchsia__

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse>);
static_assert(
    offsetof(::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse,
             h) == 0);
static_assert(
    sizeof(
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse) ==
    ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResponse::
        PrimarySize);
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::fidl_test_protocols::wire::WithErrorSyntaxHandleInResultResult>);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>) ==
    ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                            NoResponseMethod>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::HandleRightsProtocol::NoResponseMethod>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    ::fidl::WireRequest<::fidl_test_protocols::HandleRightsProtocol::
                            ResponseMethod>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>) ==
    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::
                             ResponseMethod>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::AnEvent>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::HandleRightsProtocol::AnEvent>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::HandleRightsProtocol::AnEvent>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::HandleRightsProtocol::AnEvent>,
             h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse>);
static_assert(
    offsetof(
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse,
        a) == 0);
static_assert(
    offsetof(
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse,
        b) == 8);
static_assert(
    offsetof(
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse,
        c) == 16);
static_assert(
    sizeof(
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse) ==
    ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResponse::
        PrimarySize);

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::fidl_test_protocols::wire::WithErrorSyntaxResponseAsStructResult>);

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse>);
static_assert(
    offsetof(
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse,
        __reserved) == 0);
static_assert(
    sizeof(
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse) ==
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse::
        PrimarySize);

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult>);

template <>
struct IsFidlType<
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse>);
static_assert(
    offsetof(::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse,
             __reserved) == 0);
static_assert(
    sizeof(::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse) ==
    ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse::
        PrimarySize);

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestNoResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestNoResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestEmptyResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestEmptyResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestWithResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               NoRequestWithResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             NoRequestWithResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     NoRequestWithResponse>,
             ret) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>> : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>> : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestNoResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestNoResponse>,
             arg) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestEmptyResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestEmptyResponse>,
             arg) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestEmptyResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestWithResponse>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestWithResponse>,
             arg) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>> : public std::true_type {
};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>> : public std::true_type {
};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               WithRequestWithResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             WithRequestWithResponse>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithAndWithoutRequestResponse::
                     WithRequestWithResponse>,
             ret) == 16);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               OnEmptyResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             OnEmptyResponse>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithAndWithoutRequestResponse::
               OnWithResponse>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithAndWithoutRequestResponse::
                             OnWithResponse>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::
                                 WithAndWithoutRequestResponse::OnWithResponse>,
        ret) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::Transitional::Request>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::fidl_test_protocols::Transitional::Request>,
             x) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Request>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>,
             y) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::Transitional::OneWay>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<::fidl_test_protocols::Transitional::OneWay>,
             x) == 16);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::Transitional::Event>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<::fidl_test_protocols::Transitional::Event>,
             x) == 16);

template <>
struct IsFidlType<::fidl_test_protocols::wire::TheUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_protocols::wire::TheUnion> : public std::true_type {
};
static_assert(std::is_standard_layout_v<::fidl_test_protocols::wire::TheUnion>);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::MethodWithUnion::UnionMethod>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::MethodWithUnion::UnionMethod>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::MethodWithUnion::UnionMethod>::PrimarySize);
static_assert(offsetof(::fidl::WireRequest<
                           ::fidl_test_protocols::MethodWithUnion::UnionMethod>,
                       u) == 16);

#ifdef __Fuchsia__

template <>
struct IsFidlType<::fidl_test_protocols::wire::ProtocolEnds>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_protocols::wire::ProtocolEnds>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_protocols::wire::ProtocolEnds>);
static_assert(offsetof(::fidl_test_protocols::wire::ProtocolEnds, client) == 0);
static_assert(offsetof(::fidl_test_protocols::wire::ProtocolEnds, server) == 4);
static_assert(offsetof(::fidl_test_protocols::wire::ProtocolEnds, client_opt) ==
              8);
static_assert(offsetof(::fidl_test_protocols::wire::ProtocolEnds, server_opt) ==
              12);
static_assert(sizeof(::fidl_test_protocols::wire::ProtocolEnds) ==
              ::fidl_test_protocols::wire::ProtocolEnds::PrimarySize);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireRequest<
                           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>,
                       in) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ClientEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ClientEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::fidl_test_protocols::WithProtocolEnds::ClientEnds>,
                       out) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireRequest<
                           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>,
                       in) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::ServerEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithProtocolEnds::ServerEnds>::PrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::fidl_test_protocols::WithProtocolEnds::ServerEnds>,
                       out) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    ::fidl::WireRequest<::fidl_test_protocols::WithProtocolEnds::
                            StructContainingEnds>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>,
             in) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>) ==
    ::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::
                             StructContainingEnds>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>,
             out) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ManyParameters::Fifteen>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p1) == 16);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p2) == 17);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p3) == 18);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p4) == 19);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p5) == 20);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p6) == 21);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p7) == 22);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p8) == 23);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p9) == 24);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p10) == 25);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p11) == 26);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p12) == 27);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p13) == 28);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p14) == 29);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ManyParameters::Fifteen>,
        p15) == 30);

template <>
struct IsFidlType<::fidl_test_protocols::wire::ErrorEnum>
    : public std::true_type {};

template <>
struct IsFidlType<::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_protocols::wire::WithErrorSyntaxErrorAsEnumResult>);

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>,
             result) == 16);

template <>
struct IsFidlType<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireRequest<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
             result) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>::PrimarySize);
static_assert(offsetof(::fidl::WireResponse<
                           ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>,
                       result) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::WithErrorSyntax::HandleInResult>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::PrimarySize);

template <>
struct IsFidlType<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
template <>
struct IsFidlMessage<::fidl::WireResponse<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::WithErrorSyntax::HandleInResult>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::WithErrorSyntax::HandleInResult>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::WithErrorSyntax::HandleInResult>,
             result) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::DiscoverableProtocol::Method>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::DiscoverableProtocol::Method>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::DiscoverableProtocol::Method>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MethodA>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>,
        a) == 16);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodA>,
        b) == 24);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::EventA>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>,
        a) == 16);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::EventA>,
        b) == 24);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
static_assert(
    sizeof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MethodB>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>,
        a) == 16);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MethodB>,
        b) == 24);

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::ChannelProtocol::MethodB>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MethodB>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>,
        result) == 16);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::ChannelProtocol::TakeHandle>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>::PrimarySize);
static_assert(
    offsetof(
        ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::TakeHandle>,
        h) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::TakeHandle>>
    : public std::true_type {};
static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::ChannelProtocol::TakeHandle>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::TakeHandle>::PrimarySize);

template <>
struct IsFidlType<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireRequest<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireRequest<
           ::fidl_test_protocols::ChannelProtocol::MutateSocket>) ==
    ::fidl::WireRequest<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>::PrimarySize);
static_assert(
    offsetof(::fidl::WireRequest<
                 ::fidl_test_protocols::ChannelProtocol::MutateSocket>,
             a) == 16);
#endif  // __Fuchsia__

template <>
struct IsFidlType<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
template <>
struct IsFidlMessage<
    ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MutateSocket>>
    : public std::true_type {};
#ifdef __Fuchsia__

static_assert(
    sizeof(::fidl::WireResponse<
           ::fidl_test_protocols::ChannelProtocol::MutateSocket>) ==
    ::fidl::WireResponse<
        ::fidl_test_protocols::ChannelProtocol::MutateSocket>::PrimarySize);
static_assert(
    offsetof(::fidl::WireResponse<
                 ::fidl_test_protocols::ChannelProtocol::MutateSocket>,
             b) == 16);
#endif  // __Fuchsia__

}  // namespace fidl
#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>&&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<
    ::fidl_test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |HandleRightsProtocol.ResponseMethod()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result ResponseMethod(
      ::zx::socket&& h,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
          _cb);

  ::fidl::Result ResponseMethod(
      ::zx::socket&& h,
      ::fit::callback<void(
          ::fidl::WireResponse<::fidl_test_protocols::HandleRightsProtocol::
                                   ResponseMethod>* response)>
          _cb);

  // Asynchronous variant of |HandleRightsProtocol.ResponseMethod()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result ResponseMethod(
      ::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>*
          _context);

  // Synchronous variant of |HandleRightsProtocol.ResponseMethod()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod_Sync(::zx::socket&& h);

  // Synchronous variant of |HandleRightsProtocol.ResponseMethod()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::HandleRightsProtocol::ResponseMethod>
  ResponseMethod_Sync(::fidl::BufferSpan _request_buffer, ::zx::socket&& h,
                      ::fidl::BufferSpan _response_buffer);

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result NoResponseMethod(::zx::socket&& h);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result NoResponseMethod(::fidl::BufferSpan _request_buffer,
                                  ::zx::socket&& h);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the HandleRightsProtocol protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::HandleRightsProtocol> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol>&
  server_end() const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  zx_status_t AnEvent(::zx::socket&& h) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t AnEvent(::fidl::BufferSpan _buffer, ::zx::socket&& h) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::HandleRightsProtocol> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::HandleRightsProtocol> {
 public:
  zx_status_t AnEvent(::zx::socket&& h) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().AnEvent(std::move(h));
    }
    return ZX_ERR_CANCELED;
  }

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t AnEvent(::fidl::BufferSpan _buffer, ::zx::socket&& h) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().AnEvent(std::move(_buffer), std::move(h));
    }
    return ZX_ERR_CANCELED;
  }

 private:
  friend class ::fidl::ServerBindingRef<
      ::fidl_test_protocols::HandleRightsProtocol>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::HandleRightsProtocol>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::HandleRightsProtocol>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        NoRequestEmptyResponse> : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestEmptyResponse>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            NoRequestWithResponse>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestEmptyResponse> : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithAndWithoutRequestResponse::
        WithRequestWithResponse> : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(::fidl::WireUnownedResult<
                        ::fidl_test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<
    ::fidl_test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestEmptyResponse()|. Allocates 16
  // bytes of request buffer on the stack. The callback is stored on the heap.
  ::fidl::Result NoRequestEmptyResponse(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>
          _cb);

  ::fidl::Result NoRequestEmptyResponse(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   NoRequestEmptyResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestEmptyResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  ::fidl::Result NoRequestEmptyResponse(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>* _context);

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestEmptyResponse()|. Allocates 32
  // bytes of message buffer on the stack. No heap allocation necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>
  NoRequestEmptyResponse_Sync();

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestWithResponse()|. Allocates 16 bytes
  // of request buffer on the stack. The callback is stored on the heap.
  ::fidl::Result NoRequestWithResponse(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>
          _cb);

  ::fidl::Result NoRequestWithResponse(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   NoRequestWithResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestWithResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  ::fidl::Result NoRequestWithResponse(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>* _context);

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestWithResponse()|. Allocates 16 bytes
  // of request buffer on the stack. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>
  NoRequestWithResponse_Sync();

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.NoRequestWithResponse()|. Caller provides
  // the backing storage for FIDL message via request and response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          NoRequestWithResponse>
  NoRequestWithResponse_Sync(::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestEmptyResponse()|. The request and
  // callback are allocated on the heap.
  ::fidl::Result WithRequestEmptyResponse(
      ::fidl::StringView arg,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>
          _cb);

  ::fidl::Result WithRequestEmptyResponse(
      ::fidl::StringView arg,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   WithRequestEmptyResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestEmptyResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  ::fidl::Result WithRequestEmptyResponse(
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>* _context);

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestEmptyResponse()|. Allocates 16
  // bytes of response buffer on the stack. Request is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>
  WithRequestEmptyResponse_Sync(::fidl::StringView arg);

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestEmptyResponse()|. Caller provides
  // the backing storage for FIDL message via request and response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>
  WithRequestEmptyResponse_Sync(::fidl::BufferSpan _request_buffer,
                                ::fidl::StringView arg,
                                ::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestWithResponse()|. The request and
  // callback are allocated on the heap.
  ::fidl::Result WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>
          _cb);

  ::fidl::Result WithRequestWithResponse(
      ::fidl::StringView arg,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithAndWithoutRequestResponse::
                   WithRequestWithResponse>* response)>
          _cb);

  // Asynchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestWithResponse()|. Caller provides
  // the backing storage for FIDL message via request buffer. Ownership of
  // |_context| is given unsafely to the binding until |OnError| or |OnReply|
  // are called on it.
  ::fidl::Result WithRequestWithResponse(
      ::fidl::BufferSpan _request_buffer, ::fidl::StringView arg,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>* _context);

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestWithResponse()|. Request is
  // heap-allocated. Response is heap-allocated.
  ::fidl::WireResult<::fidl_test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>
  WithRequestWithResponse_Sync(::fidl::StringView arg);

  // Synchronous variant of
  // |WithAndWithoutRequestResponse.WithRequestWithResponse()|. Caller provides
  // the backing storage for FIDL message via request and response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>
  WithRequestWithResponse_Sync(::fidl::BufferSpan _request_buffer,
                               ::fidl::StringView arg,
                               ::fidl::BufferSpan _response_buffer);

  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result NoRequestNoResponse();

  // Request is heap-allocated.
  ::fidl::Result WithRequestNoResponse(::fidl::StringView arg);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result WithRequestNoResponse(::fidl::BufferSpan _request_buffer,
                                       ::fidl::StringView arg);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the WithAndWithoutRequestResponse protocol, and can send events in that
// protocol.
template <>
class ::fidl::WireEventSender<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
          server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  server_end() const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>&
  server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  zx_status_t OnEmptyResponse() const;

  zx_status_t OnWithResponse(::fidl::StringView ret) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t OnWithResponse(::fidl::BufferSpan _buffer,
                             ::fidl::StringView ret) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::WithAndWithoutRequestResponse>
      server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::WithAndWithoutRequestResponse> {
 public:
  zx_status_t OnEmptyResponse() const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().OnEmptyResponse();
    }
    return ZX_ERR_CANCELED;
  }

  zx_status_t OnWithResponse(::fidl::StringView ret) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().OnWithResponse(ret);
    }
    return ZX_ERR_CANCELED;
  }

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t OnWithResponse(::fidl::BufferSpan _buffer,
                             ::fidl::StringView ret) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().OnWithResponse(std::move(_buffer), ret);
    }
    return ZX_ERR_CANCELED;
  }

 private:
  friend class ::fidl::ServerBindingRef<
      ::fidl_test_protocols::WithAndWithoutRequestResponse>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::WithAndWithoutRequestResponse>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::WithAndWithoutRequestResponse>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<::fidl_test_protocols::Transitional::Request>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>&&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::Transitional>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |Transitional.Request()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result Request(
      int64_t x,
      ::fidl::WireClientCallback<::fidl_test_protocols::Transitional::Request>
          _cb);

  ::fidl::Result Request(
      int64_t x,
      ::fit::callback<void(
          ::fidl::WireResponse<::fidl_test_protocols::Transitional::Request>*
              response)>
          _cb);

  // Asynchronous variant of |Transitional.Request()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result Request(
      ::fidl::BufferSpan _request_buffer, int64_t x,
      ::fidl::WireResponseContext<::fidl_test_protocols::Transitional::Request>*
          _context);

  // Synchronous variant of |Transitional.Request()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::Transitional::Request> Request_Sync(
      int64_t x);

  // Synchronous variant of |Transitional.Request()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::Transitional::Request>
  Request_Sync(::fidl::BufferSpan _request_buffer, int64_t x,
               ::fidl::BufferSpan _response_buffer);

  // Allocates 24 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result OneWay(int64_t x);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result OneWay(::fidl::BufferSpan _request_buffer, int64_t x);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the Transitional protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::Transitional> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::Transitional> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::Transitional>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::Transitional>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  zx_status_t Event(int64_t x) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t Event(::fidl::BufferSpan _buffer, int64_t x) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::Transitional> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::Transitional> {
 public:
  zx_status_t Event(int64_t x) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().Event(x);
    }
    return ZX_ERR_CANCELED;
  }

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t Event(::fidl::BufferSpan _buffer, int64_t x) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().Event(std::move(_buffer), x);
    }
    return ZX_ERR_CANCELED;
  }

 private:
  friend class ::fidl::ServerBindingRef<::fidl_test_protocols::Transitional>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::Transitional>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<
      ::fidl::internal::AsyncServerBinding<::fidl_test_protocols::Transitional>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::MethodWithUnion>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result UnionMethod(::fidl_test_protocols::wire::TheUnion u);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result UnionMethod(::fidl::BufferSpan _request_buffer,
                             ::fidl_test_protocols::wire::TheUnion u);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the MethodWithUnion protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::MethodWithUnion> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::MethodWithUnion> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::MethodWithUnion> {
 public:
 private:
  friend class ::fidl::ServerBindingRef<::fidl_test_protocols::MethodWithUnion>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::MethodWithUnion>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::MethodWithUnion>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>&&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |WithProtocolEnds.ClientEnds()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>
          _cb);

  ::fidl::Result ClientEnds(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithProtocolEnds::ClientEnds>* response)>
          _cb);

  // Asynchronous variant of |WithProtocolEnds.ClientEnds()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result ClientEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithProtocolEnds::ClientEnds>* _context);

  // Synchronous variant of |WithProtocolEnds.ClientEnds()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds_Sync(
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);

  // Synchronous variant of |WithProtocolEnds.ClientEnds()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ClientEnds>
  ClientEnds_Sync(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ClientEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |WithProtocolEnds.ServerEnds()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>
          _cb);

  ::fidl::Result ServerEnds(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithProtocolEnds::ServerEnds>* response)>
          _cb);

  // Asynchronous variant of |WithProtocolEnds.ServerEnds()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result ServerEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithProtocolEnds::ServerEnds>* _context);

  // Synchronous variant of |WithProtocolEnds.ServerEnds()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds_Sync(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in);

  // Synchronous variant of |WithProtocolEnds.ServerEnds()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithProtocolEnds::ServerEnds>
  ServerEnds_Sync(
      ::fidl::BufferSpan _request_buffer,
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&& in,
      ::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |WithProtocolEnds.StructContainingEnds()|.
  // Allocates 32 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result StructContainingEnds(
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
          _cb);

  ::fidl::Result StructContainingEnds(
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithProtocolEnds::
                                        StructContainingEnds>* response)>
          _cb);

  // Asynchronous variant of |WithProtocolEnds.StructContainingEnds()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result StructContainingEnds(
      ::fidl::BufferSpan _request_buffer,
      ::fidl_test_protocols::wire::ProtocolEnds&& in,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>*
          _context);

  // Synchronous variant of |WithProtocolEnds.StructContainingEnds()|.
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds_Sync(::fidl_test_protocols::wire::ProtocolEnds&& in);

  // Synchronous variant of |WithProtocolEnds.StructContainingEnds()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithProtocolEnds::StructContainingEnds>
  StructContainingEnds_Sync(::fidl::BufferSpan _request_buffer,
                            ::fidl_test_protocols::wire::ProtocolEnds&& in,
                            ::fidl::BufferSpan _response_buffer);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the WithProtocolEnds protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::WithProtocolEnds> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::WithProtocolEnds> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::WithProtocolEnds> {
 public:
 private:
  friend class ::fidl::ServerBindingRef<
      ::fidl_test_protocols::WithProtocolEnds>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::WithProtocolEnds>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::WithProtocolEnds>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::ManyParameters>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result Fifteen(bool p1, bool p2, bool p3, bool p4, bool p5, bool p6,
                         bool p7, bool p8, bool p9, bool p10, bool p11,
                         bool p12, bool p13, bool p14, bool p15);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result Fifteen(::fidl::BufferSpan _request_buffer, bool p1, bool p2,
                         bool p3, bool p4, bool p5, bool p6, bool p7, bool p8,
                         bool p9, bool p10, bool p11, bool p12, bool p13,
                         bool p14, bool p15);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the ManyParameters protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::ManyParameters> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::ManyParameters> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::ManyParameters> {
 public:
 private:
  friend class ::fidl::ServerBindingRef<::fidl_test_protocols::ManyParameters>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::ManyParameters>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::ManyParameters>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>&&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
          result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |WithErrorSyntax.ResponseAsStruct()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result ResponseAsStruct(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
          _cb);

  ::fidl::Result ResponseAsStruct(
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                                        ResponseAsStruct>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.ResponseAsStruct()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result ResponseAsStruct(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>* _context);

  // Synchronous variant of |WithErrorSyntax.ResponseAsStruct()|.
  // Allocates 80 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct_Sync();

  // Synchronous variant of |WithErrorSyntax.ResponseAsStruct()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ResponseAsStruct>
  ResponseAsStruct_Sync(::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |WithErrorSyntax.ErrorAsPrimitive()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result ErrorAsPrimitive(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
          _cb);

  ::fidl::Result ErrorAsPrimitive(
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                                        ErrorAsPrimitive>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.ErrorAsPrimitive()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result ErrorAsPrimitive(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>* _context);

  // Synchronous variant of |WithErrorSyntax.ErrorAsPrimitive()|.
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive_Sync();

  // Synchronous variant of |WithErrorSyntax.ErrorAsPrimitive()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  ErrorAsPrimitive_Sync(::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |WithErrorSyntax.ErrorAsEnum()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result ErrorAsEnum(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
          _cb);

  ::fidl::Result ErrorAsEnum(
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.ErrorAsEnum()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result ErrorAsEnum(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>* _context);

  // Synchronous variant of |WithErrorSyntax.ErrorAsEnum()|.
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum_Sync();

  // Synchronous variant of |WithErrorSyntax.ErrorAsEnum()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::WithErrorSyntax::ErrorAsEnum>
  ErrorAsEnum_Sync(::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |WithErrorSyntax.HandleInResult()|.
  // Allocates 16 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result HandleInResult(
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
          _cb);

  ::fidl::Result HandleInResult(
      ::fit::callback<
          void(::fidl::WireResponse<::fidl_test_protocols::WithErrorSyntax::
                                        HandleInResult>* response)>
          _cb);

  // Asynchronous variant of |WithErrorSyntax.HandleInResult()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result HandleInResult(
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::WithErrorSyntax::HandleInResult>* _context);

  // Synchronous variant of |WithErrorSyntax.HandleInResult()|.
  // Allocates 64 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult_Sync();

  // Synchronous variant of |WithErrorSyntax.HandleInResult()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::WithErrorSyntax::HandleInResult>
  HandleInResult_Sync(::fidl::BufferSpan _response_buffer);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the WithErrorSyntax protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::WithErrorSyntax> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::WithErrorSyntax> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::WithErrorSyntax> {
 public:
 private:
  friend class ::fidl::ServerBindingRef<::fidl_test_protocols::WithErrorSyntax>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::WithErrorSyntax>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::WithErrorSyntax>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<
    ::fidl_test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::ClientBase {
 public:
  // Allocates 16 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result Method();

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the DiscoverableProtocol protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::DiscoverableProtocol> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>&
  server_end() const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::DiscoverableProtocol> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::DiscoverableProtocol> {
 public:
 private:
  friend class ::fidl::ServerBindingRef<
      ::fidl_test_protocols::DiscoverableProtocol>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::DiscoverableProtocol>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::DiscoverableProtocol>>
      binding_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::ChannelProtocol::MethodB>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::ChannelProtocol::MethodB>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::WireResponseContext<
    ::fidl_test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::internal::ResponseContext {
 public:
  WireResponseContext();

  virtual void OnResult(
      ::fidl::WireUnownedResult<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>&& result) = 0;

 private:
  ::cpp17::optional<::fidl::UnbindInfo> OnRawResult(
      ::fidl::IncomingMessage&& msg) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::WireClientImpl<::fidl_test_protocols::ChannelProtocol>
    final : public ::fidl::internal::ClientBase {
 public:
  // Asynchronous variant of |ChannelProtocol.MethodB()|.
  // Allocates 32 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result MethodB(int64_t a, int64_t b,
                         ::fidl::WireClientCallback<
                             ::fidl_test_protocols::ChannelProtocol::MethodB>
                             _cb);

  ::fidl::Result MethodB(
      int64_t a, int64_t b,
      ::fit::callback<void(
          ::fidl::WireResponse<::fidl_test_protocols::ChannelProtocol::MethodB>*
              response)>
          _cb);

  // Asynchronous variant of |ChannelProtocol.MethodB()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result MethodB(
      ::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::ChannelProtocol::MethodB>* _context);

  // Synchronous variant of |ChannelProtocol.MethodB()|.
  // Allocates 56 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB_Sync(int64_t a, int64_t b);

  // Synchronous variant of |ChannelProtocol.MethodB()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::MethodB>
  MethodB_Sync(::fidl::BufferSpan _request_buffer, int64_t a, int64_t b,
               ::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |ChannelProtocol.TakeHandle()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result TakeHandle(
      ::zx::handle&& h, ::fidl::WireClientCallback<
                            ::fidl_test_protocols::ChannelProtocol::TakeHandle>
                            _cb);

  ::fidl::Result TakeHandle(
      ::zx::handle&& h,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::ChannelProtocol::TakeHandle>* response)>
          _cb);

  // Asynchronous variant of |ChannelProtocol.TakeHandle()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result TakeHandle(
      ::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::ChannelProtocol::TakeHandle>* _context);

  // Synchronous variant of |ChannelProtocol.TakeHandle()|.
  // Allocates 40 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle_Sync(::zx::handle&& h);

  // Synchronous variant of |ChannelProtocol.TakeHandle()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<::fidl_test_protocols::ChannelProtocol::TakeHandle>
  TakeHandle_Sync(::fidl::BufferSpan _request_buffer, ::zx::handle&& h,
                  ::fidl::BufferSpan _response_buffer);

  // Asynchronous variant of |ChannelProtocol.MutateSocket()|.
  // Allocates 24 bytes of request buffer on the stack. The callback is stored
  // on the heap.
  ::fidl::Result MutateSocket(
      ::zx::socket&& a,
      ::fidl::WireClientCallback<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>
          _cb);

  ::fidl::Result MutateSocket(
      ::zx::socket&& a,
      ::fit::callback<
          void(::fidl::WireResponse<
               ::fidl_test_protocols::ChannelProtocol::MutateSocket>* response)>
          _cb);

  // Asynchronous variant of |ChannelProtocol.MutateSocket()|.
  // Caller provides the backing storage for FIDL message via request buffer.
  // Ownership of |_context| is given unsafely to the binding until |OnError|
  // or |OnReply| are called on it.
  ::fidl::Result MutateSocket(
      ::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
      ::fidl::WireResponseContext<
          ::fidl_test_protocols::ChannelProtocol::MutateSocket>* _context);

  // Synchronous variant of |ChannelProtocol.MutateSocket()|.
  // Allocates 48 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::WireResult<::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket_Sync(::zx::socket&& a);

  // Synchronous variant of |ChannelProtocol.MutateSocket()|.
  // Caller provides the backing storage for FIDL message via request and
  // response buffers.
  ::fidl::WireUnownedResult<
      ::fidl_test_protocols::ChannelProtocol::MutateSocket>
  MutateSocket_Sync(::fidl::BufferSpan _request_buffer, ::zx::socket&& a,
                    ::fidl::BufferSpan _response_buffer);

  // Allocates 32 bytes of message buffer on the stack. No heap allocation
  // necessary.
  ::fidl::Result MethodA(int64_t a, int64_t b);

  // Caller provides the backing storage for FIDL message via request buffer.
  ::fidl::Result MethodA(::fidl::BufferSpan _request_buffer, int64_t a,
                         int64_t b);

  WireClientImpl() = default;

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      ::fidl::internal::AsyncEventHandler* maybe_event_handler) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
// |EventSender| owns a server endpoint of a channel speaking
// the ChannelProtocol protocol, and can send events in that protocol.
template <>
class ::fidl::WireEventSender<::fidl_test_protocols::ChannelProtocol> {
 public:
  // Constructs an event sender with an invalid channel.
  WireEventSender() = default;

  explicit WireEventSender(
      ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol> server_end)
      : server_end_(std::move(server_end)) {}

  // The underlying server channel endpoint, which may be replaced at run-time.
  const ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol>& server_end()
      const {
    return server_end_;
  }
  ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol>& server_end() {
    return server_end_;
  }

  const ::zx::channel& channel() const { return server_end_.channel(); }
  ::zx::channel& channel() { return server_end_.channel(); }

  // Whether the underlying channel is valid.
  bool is_valid() const { return server_end_.is_valid(); }

  zx_status_t EventA(int64_t a, int64_t b) const;

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t EventA(::fidl::BufferSpan _buffer, int64_t a, int64_t b) const;

 private:
  ::fidl::ServerEnd<::fidl_test_protocols::ChannelProtocol> server_end_;
};

template <>
class ::fidl::internal::WireWeakEventSender<
    ::fidl_test_protocols::ChannelProtocol> {
 public:
  zx_status_t EventA(int64_t a, int64_t b) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().EventA(a, b);
    }
    return ZX_ERR_CANCELED;
  }

  // Caller provides the backing storage for FIDL message via response buffers.
  zx_status_t EventA(::fidl::BufferSpan _buffer, int64_t a, int64_t b) const {
    if (auto _binding = binding_.lock()) {
      return _binding->event_sender().EventA(std::move(_buffer), a, b);
    }
    return ZX_ERR_CANCELED;
  }

 private:
  friend class ::fidl::ServerBindingRef<::fidl_test_protocols::ChannelProtocol>;

  explicit WireWeakEventSender(
      std::weak_ptr<::fidl::internal::AsyncServerBinding<
          ::fidl_test_protocols::ChannelProtocol>>
          binding)
      : binding_(std::move(binding)) {}

  std::weak_ptr<::fidl::internal::AsyncServerBinding<
      ::fidl_test_protocols::ChannelProtocol>>
      binding_;
};
#endif  // __Fuchsia__
