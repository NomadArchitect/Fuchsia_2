// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__

#endif  // __Fuchsia__

#include <fidl/fidl.test.padding/cpp/markers.h>

namespace fidl_test_padding {
namespace wire {
struct Padding7ByteMiddle;

struct Padding7ByteEnd;

struct Padding6ByteMiddle;

struct Padding6ByteEnd;

struct Padding5ByteMiddle;

struct Padding5ByteEnd;

struct Padding4ByteMiddle;

struct Padding4ByteEnd;

struct Padding4ByteAlignmentLength12;

struct Padding3ByteMiddle;

struct Padding3ByteEnd;

struct Padding2ByteMiddle;

struct Padding2ByteEnd;

struct Padding2ByteAlignmentLength6;

struct Padding1ByteMiddle;

struct Padding1ByteEnd;

extern "C" const fidl_type_t fidl_test_padding_Padding1ByteMiddleTable;

struct Padding1ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding1ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t a = {};

  uint16_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding1ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding1ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding1ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding1ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding1ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding1ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding1ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding1ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding1ByteMiddle> {
 public:
  using DecodedMessageBase<Padding1ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding1ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding1ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding1ByteEndTable;

struct Padding1ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding1ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 4;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint16_t a = {};

  uint8_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding1ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding1ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding1ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding1ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding1ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding1ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding1ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding1ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding1ByteEnd> {
 public:
  using DecodedMessageBase<Padding1ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding1ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding1ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding7ByteMiddleTable;

struct Padding7ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding7ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t a = {};

  uint64_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding7ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding7ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding7ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding7ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding7ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding7ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding7ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding7ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding7ByteMiddle> {
 public:
  using DecodedMessageBase<Padding7ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding7ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding7ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding7ByteEndTable;

struct Padding7ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding7ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t a = {};

  uint8_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding7ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding7ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding7ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding7ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding7ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding7ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding7ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding7ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding7ByteEnd> {
 public:
  using DecodedMessageBase<Padding7ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding7ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding7ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding6ByteMiddleTable;

struct Padding6ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding6ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint16_t a = {};

  uint64_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding6ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding6ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding6ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding6ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding6ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding6ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding6ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding6ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding6ByteMiddle> {
 public:
  using DecodedMessageBase<Padding6ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding6ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding6ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding6ByteEndTable;

struct Padding6ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding6ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t a = {};

  uint16_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding6ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding6ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding6ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding6ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding6ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding6ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding6ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding6ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding6ByteEnd> {
 public:
  using DecodedMessageBase<Padding6ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding6ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding6ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding5ByteMiddleTable;

struct Padding5ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding5ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint16_t a = {};

  uint8_t b = {};

  uint64_t c = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding5ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding5ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding5ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding5ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding5ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding5ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding5ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding5ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding5ByteMiddle> {
 public:
  using DecodedMessageBase<Padding5ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding5ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding5ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding5ByteEndTable;

struct Padding5ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding5ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t a = {};

  uint16_t b = {};

  uint8_t c = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding5ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding5ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding5ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding5ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding5ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding5ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding5ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding5ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding5ByteEnd> {
 public:
  using DecodedMessageBase<Padding5ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding5ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding5ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding4ByteMiddleTable;

struct Padding4ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding4ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint32_t a = {};

  uint64_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding4ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding4ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding4ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding4ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding4ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding4ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding4ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding4ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding4ByteMiddle> {
 public:
  using DecodedMessageBase<Padding4ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding4ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding4ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding4ByteEndTable;

struct Padding4ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding4ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint64_t a = {};

  uint32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding4ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding4ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding4ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding4ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding4ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding4ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding4ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding4ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding4ByteEnd> {
 public:
  using DecodedMessageBase<Padding4ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding4ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding4ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t
    fidl_test_padding_Padding4ByteAlignmentLength12Table;

struct Padding4ByteAlignmentLength12 {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding4ByteAlignmentLength12Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 12;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint32_t a = {};

  uint8_t b = {};

  uint16_t c = {};

  uint16_t d = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding4ByteAlignmentLength12::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding4ByteAlignmentLength12* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        Padding4ByteAlignmentLength12* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding4ByteAlignmentLength12>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding4ByteAlignmentLength12::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding4ByteAlignmentLength12* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding4ByteAlignmentLength12* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<16> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding4ByteAlignmentLength12::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          Padding4ByteAlignmentLength12> {
 public:
  using DecodedMessageBase<Padding4ByteAlignmentLength12>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding4ByteAlignmentLength12* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding4ByteAlignmentLength12*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding3ByteMiddleTable;

struct Padding3ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding3ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t a = {};

  uint32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding3ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding3ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding3ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding3ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding3ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding3ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding3ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding3ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding3ByteMiddle> {
 public:
  using DecodedMessageBase<Padding3ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding3ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding3ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding3ByteEndTable;

struct Padding3ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding3ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint32_t a = {};

  uint8_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding3ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding3ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding3ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding3ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding3ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding3ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding3ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding3ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding3ByteEnd> {
 public:
  using DecodedMessageBase<Padding3ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding3ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding3ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding2ByteMiddleTable;

struct Padding2ByteMiddle {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding2ByteMiddleTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint16_t a = {};

  uint32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding2ByteMiddle::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding2ByteMiddle* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding2ByteMiddle* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding2ByteMiddle>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding2ByteMiddle::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding2ByteMiddle* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding2ByteMiddle* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding2ByteMiddle::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding2ByteMiddle> {
 public:
  using DecodedMessageBase<Padding2ByteMiddle>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding2ByteMiddle* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding2ByteMiddle*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_padding_Padding2ByteEndTable;

struct Padding2ByteEnd {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding2ByteEndTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 8;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint32_t a = {};

  uint16_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding2ByteEnd::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding2ByteEnd* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Padding2ByteEnd* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding2ByteEnd>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding2ByteEnd::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding2ByteEnd* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding2ByteEnd* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding2ByteEnd::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Padding2ByteEnd> {
 public:
  using DecodedMessageBase<Padding2ByteEnd>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding2ByteEnd* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding2ByteEnd*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t
    fidl_test_padding_Padding2ByteAlignmentLength6Table;

struct Padding2ByteAlignmentLength6 {
  static constexpr const fidl_type_t* Type =
      &fidl_test_padding_Padding2ByteAlignmentLength6Table;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 6;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t a = {};

  uint16_t b = {};

  uint8_t c = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Padding2ByteAlignmentLength6::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Padding2ByteAlignmentLength6* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        Padding2ByteAlignmentLength6* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Padding2ByteAlignmentLength6>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Padding2ByteAlignmentLength6::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Padding2ByteAlignmentLength6* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      Padding2ByteAlignmentLength6* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Padding2ByteAlignmentLength6::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<
          Padding2ByteAlignmentLength6> {
 public:
  using DecodedMessageBase<Padding2ByteAlignmentLength6>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Padding2ByteAlignmentLength6* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Padding2ByteAlignmentLength6*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

}  // namespace wire
}  // namespace fidl_test_padding
namespace fidl {

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding7ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding7ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding7ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding7ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding7ByteMiddle, b) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding7ByteMiddle) ==
              ::fidl_test_padding::wire::Padding7ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding7ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding7ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding7ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding7ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding7ByteEnd, b) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding7ByteEnd) ==
              ::fidl_test_padding::wire::Padding7ByteEnd::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding6ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding6ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding6ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding6ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding6ByteMiddle, b) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding6ByteMiddle) ==
              ::fidl_test_padding::wire::Padding6ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding6ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding6ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding6ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding6ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding6ByteEnd, b) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding6ByteEnd) ==
              ::fidl_test_padding::wire::Padding6ByteEnd::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding5ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding5ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding5ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding5ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding5ByteMiddle, b) == 2);
static_assert(offsetof(::fidl_test_padding::wire::Padding5ByteMiddle, c) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding5ByteMiddle) ==
              ::fidl_test_padding::wire::Padding5ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding5ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding5ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding5ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding5ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding5ByteEnd, b) == 8);
static_assert(offsetof(::fidl_test_padding::wire::Padding5ByteEnd, c) == 10);
static_assert(sizeof(::fidl_test_padding::wire::Padding5ByteEnd) ==
              ::fidl_test_padding::wire::Padding5ByteEnd::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding4ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding4ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding4ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteMiddle, b) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding4ByteMiddle) ==
              ::fidl_test_padding::wire::Padding4ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding4ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding4ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding4ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteEnd, b) == 8);
static_assert(sizeof(::fidl_test_padding::wire::Padding4ByteEnd) ==
              ::fidl_test_padding::wire::Padding4ByteEnd::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding4ByteAlignmentLength12>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding4ByteAlignmentLength12>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_padding::wire::Padding4ByteAlignmentLength12>);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteAlignmentLength12,
                       a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteAlignmentLength12,
                       b) == 4);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteAlignmentLength12,
                       c) == 6);
static_assert(offsetof(::fidl_test_padding::wire::Padding4ByteAlignmentLength12,
                       d) == 8);
static_assert(
    sizeof(::fidl_test_padding::wire::Padding4ByteAlignmentLength12) ==
    ::fidl_test_padding::wire::Padding4ByteAlignmentLength12::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding3ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding3ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding3ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding3ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding3ByteMiddle, b) == 4);
static_assert(sizeof(::fidl_test_padding::wire::Padding3ByteMiddle) ==
              ::fidl_test_padding::wire::Padding3ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding3ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding3ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding3ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding3ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding3ByteEnd, b) == 4);
static_assert(sizeof(::fidl_test_padding::wire::Padding3ByteEnd) ==
              ::fidl_test_padding::wire::Padding3ByteEnd::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding2ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding2ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding2ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteMiddle, b) == 4);
static_assert(sizeof(::fidl_test_padding::wire::Padding2ByteMiddle) ==
              ::fidl_test_padding::wire::Padding2ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding2ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding2ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding2ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteEnd, b) == 4);
static_assert(sizeof(::fidl_test_padding::wire::Padding2ByteEnd) ==
              ::fidl_test_padding::wire::Padding2ByteEnd::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding2ByteAlignmentLength6>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding2ByteAlignmentLength6>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_padding::wire::Padding2ByteAlignmentLength6>);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteAlignmentLength6,
                       a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteAlignmentLength6,
                       b) == 2);
static_assert(offsetof(::fidl_test_padding::wire::Padding2ByteAlignmentLength6,
                       c) == 4);
static_assert(
    sizeof(::fidl_test_padding::wire::Padding2ByteAlignmentLength6) ==
    ::fidl_test_padding::wire::Padding2ByteAlignmentLength6::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding1ByteMiddle>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding1ByteMiddle>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding1ByteMiddle>);
static_assert(offsetof(::fidl_test_padding::wire::Padding1ByteMiddle, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding1ByteMiddle, b) == 2);
static_assert(sizeof(::fidl_test_padding::wire::Padding1ByteMiddle) ==
              ::fidl_test_padding::wire::Padding1ByteMiddle::PrimarySize);

template <>
struct IsFidlType<::fidl_test_padding::wire::Padding1ByteEnd>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_padding::wire::Padding1ByteEnd>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_padding::wire::Padding1ByteEnd>);
static_assert(offsetof(::fidl_test_padding::wire::Padding1ByteEnd, a) == 0);
static_assert(offsetof(::fidl_test_padding::wire::Padding1ByteEnd, b) == 2);
static_assert(sizeof(::fidl_test_padding::wire::Padding1ByteEnd) ==
              ::fidl_test_padding::wire::Padding1ByteEnd::PrimarySize);

}  // namespace fidl
