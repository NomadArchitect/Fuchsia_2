// WARNING: This file is machine generated by fidlgen_llcpp.

#pragma once

#include <fidl/test.protocols/cpp/markers.h>
#include <fidl/test.protocols/cpp/natural_types.h>
#include <fidl/test.protocols/cpp/wire_messaging.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/natural_client_messenger.h>
#include <lib/fidl/cpp/internal/natural_server_messenger.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>

namespace fidl {}  // namespace fidl
template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::
                         NoRequestEmptyResponse>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = true;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::
                         NoRequestWithResponse>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestEmptyResponse>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = true;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithAndWithoutRequestResponse::
                         WithRequestWithResponse>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
    final : public ::test_protocols::
                WithAndWithoutRequestResponseOnWithResponseRequest {
 public:
  using ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::
      WithAndWithoutRequestResponseOnWithResponseRequest;
  Event(::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest v)
      : WithAndWithoutRequestResponseOnWithResponseRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Event<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::Result<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final : public ::fitx::result<::fidl::Error> {
 public:
  using ::fitx::result<::fidl::Error>::result;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final : public ::test_protocols::
                WithAndWithoutRequestResponseNoRequestWithResponseTopResponse {
 public:
  using ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;
  Response(::test_protocols::
               WithAndWithoutRequestResponseNoRequestWithResponseTopResponse v)
      : WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;
};
template <>
class ::fidl::Result<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::
              WithAndWithoutRequestResponseNoRequestWithResponseTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>::
      result;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::Result<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final : public ::fitx::result<::fidl::Error> {
 public:
  using ::fitx::result<::fidl::Error>::result;
};

template <>
class ::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final
    : public ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse {
 public:
  using ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;
  Response(
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse v)
      : WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;
};
template <>
class ::fidl::Result<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestWithResponseTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>::
      result;
};

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void NoRequestEmptyResponse(
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestEmptyResponse>&& _callback) const;

  void NoRequestWithResponse(
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 NoRequestWithResponse>&& _callback) const;

  void WithRequestEmptyResponse(
      ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestEmptyResponse>
          request,
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestEmptyResponse>&& _callback) const;

  void WithRequestWithResponse(
      ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestWithResponse>
          request,
      ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                 WithRequestWithResponse>&& _callback) const;

  ::fitx::result<::fidl::Error> NoRequestNoResponse() const;

  ::fitx::result<::fidl::Error> WithRequestNoResponse(
      ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestNoResponse>
          request) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithAndWithoutRequestResponse> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnEmptyResponse(
      ::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>&) {}
  virtual void OnWithResponse(
      ::fidl::Event<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithAndWithoutRequestResponse>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<
                    ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<
          ::test_protocols::WithAndWithoutRequestResponse>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> OnEmptyResponse();

  ::fitx::result<::fidl::Error> OnWithResponse(
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
          payload);
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::WithAndWithoutRequestResponse>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> OnEmptyResponse();

  ::fitx::result<::fidl::Error> OnWithResponse(
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
          payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
    final : public ::test_protocols::
                WithAndWithoutRequestResponseWithRequestNoResponseRequest {
 public:
  using ::test_protocols::
      WithAndWithoutRequestResponseWithRequestNoResponseRequest::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest;
  Request(::test_protocols::
              WithAndWithoutRequestResponseWithRequestNoResponseRequest v)
      : ::test_protocols::
            WithAndWithoutRequestResponseWithRequestNoResponseRequest(
                std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestNoResponseRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    final : public ::test_protocols::
                WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
 public:
  using ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
  Request(::test_protocols::
              WithAndWithoutRequestResponseWithRequestEmptyResponseRequest v)
      : ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
                std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    final : public ::test_protocols::
                WithAndWithoutRequestResponseWithRequestWithResponseRequest {
 public:
  using ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseRequest::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest;
  Request(::test_protocols::
              WithAndWithoutRequestResponseWithRequestWithResponseRequest v)
      : ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest(
                std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::
      WithAndWithoutRequestResponseWithRequestWithResponseRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestWithResponse>&& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestWithResponse>&& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithAndWithoutRequestResponse;

  using NoRequestNoResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;
  using NoRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>;

  virtual void NoRequestNoResponse(
      NoRequestNoResponseRequest& request,
      NoRequestNoResponseCompleter::Sync& completer) = 0;

  using NoRequestEmptyResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;
  using NoRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>;

  virtual void NoRequestEmptyResponse(
      NoRequestEmptyResponseRequest& request,
      NoRequestEmptyResponseCompleter::Sync& completer) = 0;

  using NoRequestWithResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;
  using NoRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>;

  virtual void NoRequestWithResponse(
      NoRequestWithResponseRequest& request,
      NoRequestWithResponseCompleter::Sync& completer) = 0;

  using WithRequestNoResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;
  using WithRequestNoResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>;

  virtual void WithRequestNoResponse(
      WithRequestNoResponseRequest& request,
      WithRequestNoResponseCompleter::Sync& completer) = 0;

  using WithRequestEmptyResponseRequest =
      ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestEmptyResponse>;
  using WithRequestEmptyResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>;

  virtual void WithRequestEmptyResponse(
      WithRequestEmptyResponseRequest& request,
      WithRequestEmptyResponseCompleter::Sync& completer) = 0;

  using WithRequestWithResponseRequest = ::fidl::Request<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;
  using WithRequestWithResponseCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>;

  virtual void WithRequestWithResponse(
      WithRequestWithResponseRequest& request,
      WithRequestWithResponseCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::Transitional::Request> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::Transitional::Request>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::Transitional::Request>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalRequestTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalOneWayRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_TransitionalEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::Transitional::Event> final
    : public ::test_protocols::TransitionalEventRequest {
 public:
  using ::test_protocols::TransitionalEventRequest::TransitionalEventRequest;
  Event(::test_protocols::TransitionalEventRequest v)
      : TransitionalEventRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::Transitional::Event>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalEventRequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::Transitional::Request> final
    : public ::test_protocols::TransitionalRequestTopResponse {
 public:
  using ::test_protocols::TransitionalRequestTopResponse::
      TransitionalRequestTopResponse;
  Response(::test_protocols::TransitionalRequestTopResponse v)
      : TransitionalRequestTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::Transitional::Request>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::Result<::test_protocols::Transitional::Request> final
    : public ::fitx::result<::fidl::Error,
                            ::test_protocols::TransitionalRequestTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error, ::test_protocols::TransitionalRequestTopResponse>::result;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::Transitional> final
    : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void Request(::fidl::Request<::test_protocols::Transitional::Request> request,
               ::fidl::ClientCallback<::test_protocols::Transitional::Request>&&
                   _callback) const;

  ::fitx::result<::fidl::Error> OneWay(
      ::fidl::Request<::test_protocols::Transitional::OneWay> request) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::Transitional> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void Event(::fidl::Event<::test_protocols::Transitional::Event>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::Transitional>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::Transitional>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::Transitional>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::Transitional>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::Transitional>* event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> Event(
      ::test_protocols::TransitionalEventRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::Transitional>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::Transitional>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> Event(
      ::test_protocols::TransitionalEventRequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::Transitional::Request> final
    : public ::test_protocols::TransitionalRequestRequest {
 public:
  using ::test_protocols::TransitionalRequestRequest::
      TransitionalRequestRequest;
  Request(::test_protocols::TransitionalRequestRequest v)
      : ::test_protocols::TransitionalRequestRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::Transitional::Request>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalRequestRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::Transitional::OneWay> final
    : public ::test_protocols::TransitionalOneWayRequest {
 public:
  using ::test_protocols::TransitionalOneWayRequest::TransitionalOneWayRequest;
  Request(::test_protocols::TransitionalOneWayRequest v)
      : ::test_protocols::TransitionalOneWayRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::Transitional::OneWay>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::TransitionalOneWayRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::Transitional::Request> : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocols::Transitional::Request>&& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::Transitional>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::Transitional;

  using RequestRequest =
      ::fidl::Request<::test_protocols::Transitional::Request>;
  using RequestCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::Transitional::Request>;

  virtual void Request(RequestRequest& request,
                       RequestCompleter::Sync& completer) {
    completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

  using OneWayRequest = ::fidl::Request<::test_protocols::Transitional::OneWay>;
  using OneWayCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::Transitional::OneWay>;

  virtual void OneWay(OneWayRequest& request,
                      OneWayCompleter::Sync& completer) {
    completer.Close(ZX_ERR_NOT_SUPPORTED);
  }

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::Transitional>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> UnionMethod(
      ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod> request)
      const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::MethodWithUnion> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::MethodWithUnion>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::MethodWithUnion>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::MethodWithUnion>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::MethodWithUnion>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::MethodWithUnion>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod> final
    : public ::test_protocols::MethodWithUnionUnionMethodRequest {
 public:
  using ::test_protocols::MethodWithUnionUnionMethodRequest::
      MethodWithUnionUnionMethodRequest;
  Request(::test_protocols::MethodWithUnionUnionMethodRequest v)
      : ::test_protocols::MethodWithUnionUnionMethodRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::MethodWithUnionUnionMethodRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::MethodWithUnion>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::MethodWithUnion;

  using UnionMethodRequest =
      ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>;
  using UnionMethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::MethodWithUnion::UnionMethod>;

  virtual void UnionMethod(UnionMethodRequest& request,
                           UnionMethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::MethodWithUnion>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithProtocolEnds::ClientEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithProtocolEnds::ClientEnds>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithProtocolEnds::ServerEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithProtocolEnds::ServerEnds>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithProtocolEnds::StructContainingEnds> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::test_protocols::WithProtocolEndsClientEndsTopResponse {
 public:
  using ::test_protocols::WithProtocolEndsClientEndsTopResponse::
      WithProtocolEndsClientEndsTopResponse;
  Response(::test_protocols::WithProtocolEndsClientEndsTopResponse v)
      : WithProtocolEndsClientEndsTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::WithProtocolEndsClientEndsTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::WithProtocolEndsClientEndsTopResponse>::result;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::test_protocols::WithProtocolEndsServerEndsTopResponse {
 public:
  using ::test_protocols::WithProtocolEndsServerEndsTopResponse::
      WithProtocolEndsServerEndsTopResponse;
  Response(::test_protocols::WithProtocolEndsServerEndsTopResponse v)
      : WithProtocolEndsServerEndsTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsTopResponse;
};
template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::WithProtocolEndsServerEndsTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::WithProtocolEndsServerEndsTopResponse>::result;
};

template <>
class ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>
    final
    : public ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse {
 public:
  using ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse::
      WithProtocolEndsStructContainingEndsTopResponse;
  Response(::test_protocols::WithProtocolEndsStructContainingEndsTopResponse v)
      : WithProtocolEndsStructContainingEndsTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithProtocolEnds::StructContainingEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse;
};
template <>
class ::fidl::Result<::test_protocols::WithProtocolEnds::StructContainingEnds>
    final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>::
      result;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ClientEnds(
      ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> request,
      ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
          _callback) const;

  void ServerEnds(
      ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> request,
      ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
          _callback) const;

  void StructContainingEnds(
      ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>
          request,
      ::fidl::ClientCallback<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&& _callback)
      const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithProtocolEnds> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithProtocolEnds>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithProtocolEnds>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::WithProtocolEnds>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::WithProtocolEnds>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> final
    : public ::test_protocols::WithProtocolEndsClientEndsRequest {
 public:
  using ::test_protocols::WithProtocolEndsClientEndsRequest::
      WithProtocolEndsClientEndsRequest;
  Request(::test_protocols::WithProtocolEndsClientEndsRequest v)
      : ::test_protocols::WithProtocolEndsClientEndsRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsClientEndsRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> final
    : public ::test_protocols::WithProtocolEndsServerEndsRequest {
 public:
  using ::test_protocols::WithProtocolEndsServerEndsRequest::
      WithProtocolEndsServerEndsRequest;
  Request(::test_protocols::WithProtocolEndsServerEndsRequest v)
      : ::test_protocols::WithProtocolEndsServerEndsRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsServerEndsRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>
    final
    : public ::test_protocols::WithProtocolEndsStructContainingEndsRequest {
 public:
  using ::test_protocols::WithProtocolEndsStructContainingEndsRequest::
      WithProtocolEndsStructContainingEndsRequest;
  Request(::test_protocols::WithProtocolEndsStructContainingEndsRequest v)
      : ::test_protocols::WithProtocolEndsStructContainingEndsRequest(
            std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithProtocolEndsStructContainingEndsRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::ClientEnds>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::ServerEnds>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithProtocolEnds>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithProtocolEnds;

  using ClientEndsRequest =
      ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>;
  using ClientEndsCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithProtocolEnds::ClientEnds>;

  virtual void ClientEnds(ClientEndsRequest& request,
                          ClientEndsCompleter::Sync& completer) = 0;

  using ServerEndsRequest =
      ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>;
  using ServerEndsCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithProtocolEnds::ServerEnds>;

  virtual void ServerEnds(ServerEndsRequest& request,
                          ServerEndsCompleter::Sync& completer) = 0;

  using StructContainingEndsRequest =
      ::fidl::Request<::test_protocols::WithProtocolEnds::StructContainingEnds>;
  using StructContainingEndsCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>;

  virtual void StructContainingEnds(
      StructContainingEndsRequest& request,
      StructContainingEndsCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithProtocolEnds>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ManyParametersFifteenRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols
template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> Fifteen(
      ::fidl::Request<::test_protocols::ManyParameters::Fifteen> request) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::ManyParameters> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::ManyParameters>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<::test_protocols::ManyParameters>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::ManyParameters>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ManyParameters>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::ManyParameters>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ManyParameters::Fifteen> final
    : public ::test_protocols::ManyParametersFifteenRequest {
 public:
  using ::test_protocols::ManyParametersFifteenRequest::
      ManyParametersFifteenRequest;
  Request(::test_protocols::ManyParametersFifteenRequest v)
      : ::test_protocols::ManyParametersFifteenRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ManyParametersFifteenRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::ManyParameters>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ManyParameters;

  using FifteenRequest =
      ::fidl::Request<::test_protocols::ManyParameters::Fifteen>;
  using FifteenCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ManyParameters::Fifteen>;

  virtual void Fifteen(FifteenRequest& request,
                       FifteenCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::HandleRightsProtocol::ResponseMethod> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> final
    : public ::test_protocols::HandleRightsProtocolAnEventRequest {
 public:
  using ::test_protocols::HandleRightsProtocolAnEventRequest::
      HandleRightsProtocolAnEventRequest;
  Event(::test_protocols::HandleRightsProtocolAnEventRequest v)
      : HandleRightsProtocolAnEventRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolAnEventRequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final
    : public ::test_protocols::HandleRightsProtocolResponseMethodTopResponse {
 public:
  using ::test_protocols::HandleRightsProtocolResponseMethodTopResponse::
      HandleRightsProtocolResponseMethodTopResponse;
  Response(::test_protocols::HandleRightsProtocolResponseMethodTopResponse v)
      : HandleRightsProtocolResponseMethodTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::Result<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::HandleRightsProtocolResponseMethodTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>::result;
};

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::HandleRightsProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ResponseMethod(
      ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>
          request,
      ::fidl::ClientCallback<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
      const;

  ::fitx::result<::fidl::Error> NoResponseMethod(
      ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>
          request) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::HandleRightsProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void AnEvent(
      ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::HandleRightsProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::HandleRightsProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> AnEvent(
      ::test_protocols::HandleRightsProtocolAnEventRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::HandleRightsProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> AnEvent(
      ::test_protocols::HandleRightsProtocolAnEventRequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>
    final
    : public ::test_protocols::HandleRightsProtocolNoResponseMethodRequest {
 public:
  using ::test_protocols::HandleRightsProtocolNoResponseMethodRequest::
      HandleRightsProtocolNoResponseMethodRequest;
  Request(::test_protocols::HandleRightsProtocolNoResponseMethodRequest v)
      : ::test_protocols::HandleRightsProtocolNoResponseMethodRequest(
            std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolNoResponseMethodRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>
    final : public ::test_protocols::HandleRightsProtocolResponseMethodRequest {
 public:
  using ::test_protocols::HandleRightsProtocolResponseMethodRequest::
      HandleRightsProtocolResponseMethodRequest;
  Request(::test_protocols::HandleRightsProtocolResponseMethodRequest v)
      : ::test_protocols::HandleRightsProtocolResponseMethodRequest(
            std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::HandleRightsProtocolResponseMethodRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocols::HandleRightsProtocol::ResponseMethod>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::HandleRightsProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::HandleRightsProtocol;

  using NoResponseMethodRequest =
      ::fidl::Request<::test_protocols::HandleRightsProtocol::NoResponseMethod>;
  using NoResponseMethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>;

  virtual void NoResponseMethod(NoResponseMethodRequest& request,
                                NoResponseMethodCompleter::Sync& completer) = 0;

  using ResponseMethodRequest =
      ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>;
  using ResponseMethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>;

  virtual void ResponseMethod(ResponseMethodRequest& request,
                              ResponseMethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocols::HandleRightsProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = true;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = true;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::WithErrorSyntax::HandleInResult> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::WithErrorSyntax::HandleInResult>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final : public ::fitx::result<
                uint32_t,
                ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response> {
 public:
  using ::fitx::result<
      uint32_t,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>::result;
  Response(
      ::fitx::result<
          uint32_t, ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>
          v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>> {
  using DomainObject =
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(*o.result().err().take()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(*o.result().response().take()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
          m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::
               WithErr(m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::
               WithResponse(std::move(m.value()))}};
    }
  }
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ResponseAsStruct> final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
          ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response> {
 public:
  using ::fitx::result<
      ::fidl::AnyErrorIn<::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>::result;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final : public ::fitx::result<uint32_t> {
 public:
  using ::fitx::result<uint32_t>::result;
  Response(::fitx::result<uint32_t> v) : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
  using DomainObject =
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(*o.result().err().take()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok();
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
          m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
               WithErr(m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
               WithResponse({})}};
    }
  }
};
template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsPrimitive> final
    : public ::fitx::result<::fidl::AnyErrorIn<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>> {
 public:
  using ::fitx::result<::fidl::AnyErrorIn<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::result;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum> final
    : public ::fitx::result<::test_protocols::ErrorEnum> {
 public:
  using ::fitx::result<::test_protocols::ErrorEnum>::result;
  Response(::fitx::result<::test_protocols::ErrorEnum> v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
  using DomainObject = ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(*o.result().err().take()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok();
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>&& m) {
    if (m.is_error()) {
      return DomainObject{
          {.result =
               ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::WithErr(
                   m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::
               WithResponse({})}};
    }
  }
};
template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::ErrorAsEnum> final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<::test_protocols::WithErrorSyntax::ErrorAsEnum>> {
 public:
  using ::fitx::result<::fidl::AnyErrorIn<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>::result;
};

template <>
class ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult> final
    : public ::fitx::result<
          uint32_t, ::test_protocols::WithErrorSyntax_HandleInResult_Response> {
 public:
  using ::fitx::result<
      uint32_t,
      ::test_protocols::WithErrorSyntax_HandleInResult_Response>::result;
  Response(::fitx::result<
           uint32_t, ::test_protocols::WithErrorSyntax_HandleInResult_Response>
               v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>> {
  using DomainObject =
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse;

 public:
  static ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(*o.result().err().take()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(*o.result().response().take()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>&& m) {
    if (m.is_error()) {
      return DomainObject{
          {.result =
               ::test_protocols::WithErrorSyntax_HandleInResult_Result::WithErr(
                   m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocols::WithErrorSyntax_HandleInResult_Result::
               WithResponse(std::move(m.value()))}};
    }
  }
};
template <>
class ::fidl::Result<::test_protocols::WithErrorSyntax::HandleInResult> final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<::test_protocols::WithErrorSyntax::HandleInResult>,
          ::test_protocols::WithErrorSyntax_HandleInResult_Response> {
 public:
  using ::fitx::result<
      ::fidl::AnyErrorIn<::test_protocols::WithErrorSyntax::HandleInResult>,
      ::test_protocols::WithErrorSyntax_HandleInResult_Response>::result;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void ResponseAsStruct(::fidl::ClientCallback<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                            _callback) const;

  void ErrorAsPrimitive(::fidl::ClientCallback<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                            _callback) const;

  void ErrorAsEnum(
      ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
          _callback) const;

  void HandleInResult(
      ::fidl::ClientCallback<
          ::test_protocols::WithErrorSyntax::HandleInResult>&& _callback) const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::WithErrorSyntax> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::WithErrorSyntax>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithErrorSyntax>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::WithErrorSyntax>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::WithErrorSyntax>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::HandleInResult>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::WithErrorSyntax>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::WithErrorSyntax;

  using ResponseAsStructRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>;
  using ResponseAsStructCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>;

  virtual void ResponseAsStruct(ResponseAsStructRequest& request,
                                ResponseAsStructCompleter::Sync& completer) = 0;

  using ErrorAsPrimitiveRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;
  using ErrorAsPrimitiveCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>;

  virtual void ErrorAsPrimitive(ErrorAsPrimitiveRequest& request,
                                ErrorAsPrimitiveCompleter::Sync& completer) = 0;

  using ErrorAsEnumRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>;
  using ErrorAsEnumCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>;

  virtual void ErrorAsEnum(ErrorAsEnumRequest& request,
                           ErrorAsEnumCompleter::Sync& completer) = 0;

  using HandleInResultRequest =
      ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>;
  using HandleInResultCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::WithErrorSyntax::HandleInResult>;

  virtual void HandleInResult(HandleInResultRequest& request,
                              HandleInResultCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::WithErrorSyntax>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fitx::result<::fidl::Error> Method() const;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::DiscoverableProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::DiscoverableProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::DiscoverableProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::DiscoverableProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::DiscoverableProtocol::Method> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
#endif  // __Fuchsia__

template <>
class ::fidl::Server<::test_protocols::DiscoverableProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::DiscoverableProtocol;

  using MethodRequest =
      ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>;
  using MethodCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::DiscoverableProtocol::Method>;

  virtual void Method(MethodRequest& request,
                      MethodCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocols::DiscoverableProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::ChannelProtocol::MethodB> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::ChannelProtocol::MethodB>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::ChannelProtocol::MethodB>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::ChannelProtocol::TakeHandle> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::ChannelProtocol::TakeHandle>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = true;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocols::ChannelProtocol::MutateSocket> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocols::ChannelProtocol::MutateSocket>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocols {
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodARequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolEventARequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

#ifdef __Fuchsia__
}  // namespace test_protocols

template <>
class ::fidl::Event<::test_protocols::ChannelProtocol::EventA> final
    : public ::test_protocols::ChannelProtocolEventARequest {
 public:
  using ::test_protocols::ChannelProtocolEventARequest::
      ChannelProtocolEventARequest;
  Event(::test_protocols::ChannelProtocolEventARequest v)
      : ChannelProtocolEventARequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolEventARequest;
};
namespace test_protocols {}  // namespace test_protocols

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MethodB> final
    : public ::test_protocols::ChannelProtocolMethodBTopResponse {
 public:
  using ::test_protocols::ChannelProtocolMethodBTopResponse::
      ChannelProtocolMethodBTopResponse;
  Response(::test_protocols::ChannelProtocolMethodBTopResponse v)
      : ChannelProtocolMethodBTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBTopResponse;
};
namespace test_protocols {}  // namespace test_protocols
template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::MethodB> final
    : public ::fitx::result<
          ::fidl::Error, ::test_protocols::ChannelProtocolMethodBTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::ChannelProtocolMethodBTopResponse>::result;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle> final {
 public:
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::TakeHandle>>
    final {
 public:
  static constexpr bool kHasPayload = false;
};
template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::TakeHandle> final
    : public ::fitx::result<::fidl::Error> {
 public:
  using ::fitx::result<::fidl::Error>::result;
};

template <>
class ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::test_protocols::ChannelProtocolMutateSocketTopResponse {
 public:
  using ::test_protocols::ChannelProtocolMutateSocketTopResponse::
      ChannelProtocolMutateSocketTopResponse;
  Response(::test_protocols::ChannelProtocolMutateSocketTopResponse v)
      : ChannelProtocolMutateSocketTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketTopResponse;
};
template <>
class ::fidl::Result<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocols::ChannelProtocolMutateSocketTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocols::ChannelProtocolMutateSocketTopResponse>::result;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  void MethodB(
      ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> request,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
          _callback) const;

  void TakeHandle(
      ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> request,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
          _callback) const;

  void MutateSocket(
      ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> request,
      ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MutateSocket>&&
          _callback) const;

  ::fitx::result<::fidl::Error> MethodA(
      ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> request)
      const;
};
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocols::ChannelProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void EventA(
      ::fidl::Event<::test_protocols::ChannelProtocol::EventA>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocols::ChannelProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocols::ChannelProtocol>
    final : public ::fidl::internal::IncomingEventDispatcher<
                ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocols::ChannelProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocols::ChannelProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> EventA(
      ::test_protocols::ChannelProtocolEventARequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocols::ChannelProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> EventA(
      ::test_protocols::ChannelProtocolEventARequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> final
    : public ::test_protocols::ChannelProtocolMethodARequest {
 public:
  using ::test_protocols::ChannelProtocolMethodARequest::
      ChannelProtocolMethodARequest;
  Request(::test_protocols::ChannelProtocolMethodARequest v)
      : ::test_protocols::ChannelProtocolMethodARequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodARequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> final
    : public ::test_protocols::ChannelProtocolMethodBRequest {
 public:
  using ::test_protocols::ChannelProtocolMethodBRequest::
      ChannelProtocolMethodBRequest;
  Request(::test_protocols::ChannelProtocolMethodBRequest v)
      : ::test_protocols::ChannelProtocolMethodBRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMethodBRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> final
    : public ::test_protocols::ChannelProtocolTakeHandleRequest {
 public:
  using ::test_protocols::ChannelProtocolTakeHandleRequest::
      ChannelProtocolTakeHandleRequest;
  Request(::test_protocols::ChannelProtocolTakeHandleRequest v)
      : ::test_protocols::ChannelProtocolTakeHandleRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolTakeHandleRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket> final
    : public ::test_protocols::ChannelProtocolMutateSocketRequest {
 public:
  using ::test_protocols::ChannelProtocolMutateSocketRequest::
      ChannelProtocolMutateSocketRequest;
  Request(::test_protocols::ChannelProtocolMutateSocketRequest v)
      : ::test_protocols::ChannelProtocolMutateSocketRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocols::ChannelProtocolMutateSocketRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MethodB> : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>&& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::TakeHandle>
    : public ::fidl::CompleterBase {
 public:
  void Reply();

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MutateSocket>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocols::ChannelProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocols::ChannelProtocol;

  using MethodARequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>;
  using MethodACompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::MethodA>;

  virtual void MethodA(MethodARequest& request,
                       MethodACompleter::Sync& completer) = 0;

  using MethodBRequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>;
  using MethodBCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::MethodB>;

  virtual void MethodB(MethodBRequest& request,
                       MethodBCompleter::Sync& completer) = 0;

  using TakeHandleRequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>;
  using TakeHandleCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::TakeHandle>;

  virtual void TakeHandle(TakeHandleRequest& request,
                          TakeHandleCompleter::Sync& completer) = 0;

  using MutateSocketRequest =
      ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>;
  using MutateSocketCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocols::ChannelProtocol::MutateSocket>;

  virtual void MutateSocket(MutateSocketRequest& request,
                            MutateSocketCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(::fidl::Server<::test_protocols::ChannelProtocol>* impl,
                       ::fidl::IncomingMessage&& msg,
                       internal::IncomingTransportContext transport_context,
                       ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__
