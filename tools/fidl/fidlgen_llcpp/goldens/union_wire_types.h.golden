// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/fidl.test.union/cpp/markers.h>

namespace fidl_test_union {
namespace wire {
struct StructWithNullableXUnion;

struct Pizza;

struct Pasta;

struct NullableUnionStruct;

struct UnionSandwich;

struct Empty;

class UnionWithAttributes;

class Union;

class StrictUnion;

class StrictSimpleXUnion;

class StrictFoo;

class StrictBoundedXUnion;

class ReverseOrdinalUnion;

class StrictPizzaOrPasta;

class PizzaOrPasta;

class FlexiblePizzaOrPasta;

class ExplicitPizzaOrPasta;

class OlderSimpleUnion;

class NewerSimpleUnion;

class FlexibleUnion;

class FlexibleFoo;

class FieldCollision;

class ExplicitXUnion;

class ExplicitUnion;

class ExplicitStrictFoo;

class ExplicitFoo;

class XUnionContainingEmptyStruct;

extern "C" const fidl_type_t fidl_test_union_EmptyTable;

struct Empty {
  static constexpr const fidl_type_t* Type = &fidl_test_union_EmptyTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 1;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = false;

  uint8_t __reserved = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Empty::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Empty* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Empty* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Empty>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Empty::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Empty* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, Empty* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<8> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Empty::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Empty> {
 public:
  using DecodedMessageBase<Empty>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Empty* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Empty*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_UnionWithAttributesTable;

class UnionWithAttributes {
 public:
  UnionWithAttributes()
      : ordinal_(
            ::fidl_test_union::wire::UnionWithAttributes::Ordinal::Invalid),
        envelope_{} {}

  UnionWithAttributes(const UnionWithAttributes&) = default;
  UnionWithAttributes& operator=(const UnionWithAttributes&) = default;
  UnionWithAttributes(UnionWithAttributes&&) = default;
  UnionWithAttributes& operator=(UnionWithAttributes&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kX = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::UnionWithAttributes::Ordinal::Invalid;
  }

  bool is_x() const {
    return ordinal_ ==
           ::fidl_test_union::wire::UnionWithAttributes::Ordinal::kX;
  }
  static UnionWithAttributes WithX(::fidl::ObjectView<int64_t> val) {
    UnionWithAttributes result;
    result.set_x(val);
    return result;
  }

  template <typename... Args>
  static UnionWithAttributes WithX(::fidl::AnyArena& allocator,
                                   Args&&... args) {
    UnionWithAttributes result;
    result.set_x(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_x(::fidl::ObjectView<int64_t> elem) {
    ordinal_ = ::fidl_test_union::wire::UnionWithAttributes::Ordinal::kX;
    envelope_.As<int64_t>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_x(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::UnionWithAttributes::Ordinal::kX;
    set_x(::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
  }

  int64_t& mutable_x() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::UnionWithAttributes::Ordinal::kX);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& x() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::UnionWithAttributes::Ordinal::kX);
    return envelope_.As<int64_t>().get_data();
  }
  ::fidl_test_union::wire::UnionWithAttributes::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_UnionWithAttributesTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kX = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::UnionWithAttributes::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class UnionWithAttributes::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        UnionWithAttributes* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        UnionWithAttributes* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<UnionWithAttributes>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class UnionWithAttributes::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(UnionWithAttributes* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      UnionWithAttributes* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class UnionWithAttributes::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<UnionWithAttributes> {
 public:
  using DecodedMessageBase<UnionWithAttributes>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  UnionWithAttributes* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<UnionWithAttributes*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_UnionTable;

class Union {
 public:
  Union()
      : ordinal_(::fidl_test_union::wire::Union::Ordinal::Invalid),
        envelope_{} {}

  Union(const Union&) = default;
  Union& operator=(const Union&) = default;
  Union(Union&&) = default;
  Union& operator=(Union&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::Union::Ordinal::Invalid;
  }

  bool is_primitive() const {
    return ordinal_ == ::fidl_test_union::wire::Union::Ordinal::kPrimitive;
  }
  static Union WithPrimitive(int32_t val) {
    Union result;
    result.set_primitive(std::move(val));
    return result;
  }

  void set_primitive(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::Union::Ordinal::kPrimitive;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_primitive() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::Union::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::Union::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const {
    return ordinal_ ==
           ::fidl_test_union::wire::Union::Ordinal::kStringNeedsConstructor;
  }
  static Union WithStringNeedsConstructor(
      ::fidl::ObjectView<::fidl::StringView> val) {
    Union result;
    result.set_string_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static Union WithStringNeedsConstructor(::fidl::AnyArena& allocator,
                                          Args&&... args) {
    Union result;
    result.set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_string_needs_constructor(
      ::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::Union::Ordinal::kStringNeedsConstructor;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_string_needs_constructor(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::Union::Ordinal::kStringNeedsConstructor;
    set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_string_needs_constructor() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::Union::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::Union::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_vector_string_also_needs_constructor() const {
    return ordinal_ == ::fidl_test_union::wire::Union::Ordinal::
                           kVectorStringAlsoNeedsConstructor;
  }
  static Union WithVectorStringAlsoNeedsConstructor(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    Union result;
    result.set_vector_string_also_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static Union WithVectorStringAlsoNeedsConstructor(::fidl::AnyArena& allocator,
                                                    Args&&... args) {
    Union result;
    result.set_vector_string_also_needs_constructor(
        ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_vector_string_also_needs_constructor(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> elem) {
    ordinal_ = ::fidl_test_union::wire::Union::Ordinal::
        kVectorStringAlsoNeedsConstructor;
    envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_vector_string_also_needs_constructor(::fidl::AnyArena& allocator,
                                                Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::Union::Ordinal::
        kVectorStringAlsoNeedsConstructor;
    set_vector_string_also_needs_constructor(
        ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>&
  mutable_vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::Union::Ordinal::
                              kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>&
  vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::Union::Ordinal::
                              kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::fidl_test_union::wire::Union::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::Union::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_union_UnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::Union::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class Union::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Union* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Union* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Union>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Union::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Union* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, Union* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class Union::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Union> {
 public:
  using DecodedMessageBase<Union>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Union* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Union*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_StrictUnionTable;

class StrictUnion {
 public:
  StrictUnion()
      : ordinal_(::fidl_test_union::wire::StrictUnion::Ordinal::Invalid),
        envelope_{} {}

  StrictUnion(const StrictUnion&) = default;
  StrictUnion& operator=(const StrictUnion&) = default;
  StrictUnion(StrictUnion&&) = default;
  StrictUnion& operator=(StrictUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::StrictUnion::Ordinal::Invalid;
  }

  bool is_primitive() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictUnion::Ordinal::kPrimitive;
  }
  static StrictUnion WithPrimitive(int32_t val) {
    StrictUnion result;
    result.set_primitive(std::move(val));
    return result;
  }

  void set_primitive(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::StrictUnion::Ordinal::kPrimitive;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_primitive() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const {
    return ordinal_ == ::fidl_test_union::wire::StrictUnion::Ordinal::
                           kStringNeedsConstructor;
  }
  static StrictUnion WithStringNeedsConstructor(
      ::fidl::ObjectView<::fidl::StringView> val) {
    StrictUnion result;
    result.set_string_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static StrictUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator,
                                                Args&&... args) {
    StrictUnion result;
    result.set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_string_needs_constructor(
      ::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ =
        ::fidl_test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_string_needs_constructor(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ordinal_ =
        ::fidl_test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor;
    set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_string_needs_constructor() {
    ZX_ASSERT(
        ordinal_ ==
        ::fidl_test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(
        ordinal_ ==
        ::fidl_test_union::wire::StrictUnion::Ordinal::kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_vector_string_also_needs_constructor() const {
    return ordinal_ == ::fidl_test_union::wire::StrictUnion::Ordinal::
                           kVectorStringAlsoNeedsConstructor;
  }
  static StrictUnion WithVectorStringAlsoNeedsConstructor(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    StrictUnion result;
    result.set_vector_string_also_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static StrictUnion WithVectorStringAlsoNeedsConstructor(
      ::fidl::AnyArena& allocator, Args&&... args) {
    StrictUnion result;
    result.set_vector_string_also_needs_constructor(
        ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_vector_string_also_needs_constructor(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> elem) {
    ordinal_ = ::fidl_test_union::wire::StrictUnion::Ordinal::
        kVectorStringAlsoNeedsConstructor;
    envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_vector_string_also_needs_constructor(::fidl::AnyArena& allocator,
                                                Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::StrictUnion::Ordinal::
        kVectorStringAlsoNeedsConstructor;
    set_vector_string_also_needs_constructor(
        ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>&
  mutable_vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::StrictUnion::Ordinal::
                              kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>&
  vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::StrictUnion::Ordinal::
                              kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::fidl_test_union::wire::StrictUnion::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::StrictUnion::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_union_StrictUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::StrictUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        StrictUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, StrictUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<StrictUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class StrictUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(StrictUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, StrictUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class StrictUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<StrictUnion> {
 public:
  using DecodedMessageBase<StrictUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  StrictUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<StrictUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_StrictSimpleXUnionTable;

class StrictSimpleXUnion {
 public:
  StrictSimpleXUnion()
      : ordinal_(::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::Invalid),
        envelope_{} {}

  StrictSimpleXUnion(const StrictSimpleXUnion&) = default;
  StrictSimpleXUnion& operator=(const StrictSimpleXUnion&) = default;
  StrictSimpleXUnion(StrictSimpleXUnion&&) = default;
  StrictSimpleXUnion& operator=(StrictSimpleXUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::Invalid;
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kI;
  }
  static StrictSimpleXUnion WithI(int32_t val) {
    StrictSimpleXUnion result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kI;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_f() const {
    return ordinal_ == ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kF;
  }
  static StrictSimpleXUnion WithF(float val) {
    StrictSimpleXUnion result;
    result.set_f(std::move(val));
    return result;
  }

  void set_f(float elem) {
    ordinal_ = ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kF;
    envelope_.As<float>().set_data(std::move(elem));
  }

  float& mutable_f() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }

  bool is_s() const {
    return ordinal_ == ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kS;
  }
  static StrictSimpleXUnion WithS(::fidl::ObjectView<::fidl::StringView> val) {
    StrictSimpleXUnion result;
    result.set_s(val);
    return result;
  }

  template <typename... Args>
  static StrictSimpleXUnion WithS(::fidl::AnyArena& allocator, Args&&... args) {
    StrictSimpleXUnion result;
    result.set_s(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_s(::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kS;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_s(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kS;
    set_s(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                 std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  ::fidl_test_union::wire::StrictSimpleXUnion::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::StrictSimpleXUnion::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_StrictSimpleXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kS = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::StrictSimpleXUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictSimpleXUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        StrictSimpleXUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, StrictSimpleXUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<StrictSimpleXUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class StrictSimpleXUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(StrictSimpleXUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      StrictSimpleXUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class StrictSimpleXUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<StrictSimpleXUnion> {
 public:
  using DecodedMessageBase<StrictSimpleXUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  StrictSimpleXUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<StrictSimpleXUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_StrictFooTable;

class StrictFoo {
 public:
  StrictFoo()
      : ordinal_(::fidl_test_union::wire::StrictFoo::Ordinal::Invalid),
        envelope_{} {}

  StrictFoo(const StrictFoo&) = default;
  StrictFoo& operator=(const StrictFoo&) = default;
  StrictFoo(StrictFoo&&) = default;
  StrictFoo& operator=(StrictFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::Invalid;
  }

  bool is_s() const {
    return ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::kS;
  }
  static StrictFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    StrictFoo result;
    result.set_s(val);
    return result;
  }

  template <typename... Args>
  static StrictFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    StrictFoo result;
    result.set_s(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_s(::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::StrictFoo::Ordinal::kS;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_s(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::StrictFoo::Ordinal::kS;
    set_s(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                 std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::kI;
  }
  static StrictFoo WithI(int32_t val) {
    StrictFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::StrictFoo::Ordinal::kI;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::StrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::fidl_test_union::wire::StrictFoo::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::StrictFoo::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_union_StrictFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::StrictFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictFoo::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        StrictFoo* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, StrictFoo* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<StrictFoo>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class StrictFoo::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(StrictFoo* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, StrictFoo* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class StrictFoo::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<StrictFoo> {
 public:
  using DecodedMessageBase<StrictFoo>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  StrictFoo* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<StrictFoo*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_StrictBoundedXUnionTable;

class StrictBoundedXUnion {
 public:
  StrictBoundedXUnion()
      : ordinal_(
            ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::Invalid),
        envelope_{} {}

  StrictBoundedXUnion(const StrictBoundedXUnion&) = default;
  StrictBoundedXUnion& operator=(const StrictBoundedXUnion&) = default;
  StrictBoundedXUnion(StrictBoundedXUnion&&) = default;
  StrictBoundedXUnion& operator=(StrictBoundedXUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kV = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::Invalid;
  }

  bool is_v() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::kV;
  }
  static StrictBoundedXUnion WithV(
      ::fidl::ObjectView<::fidl::VectorView<uint8_t>> val) {
    StrictBoundedXUnion result;
    result.set_v(val);
    return result;
  }

  template <typename... Args>
  static StrictBoundedXUnion WithV(::fidl::AnyArena& allocator,
                                   Args&&... args) {
    StrictBoundedXUnion result;
    result.set_v(::fidl::ObjectView<::fidl::VectorView<uint8_t>>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_v(::fidl::ObjectView<::fidl::VectorView<uint8_t>> elem) {
    ordinal_ = ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::kV;
    envelope_.As<::fidl::VectorView<uint8_t>>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_v(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::kV;
    set_v(::fidl::ObjectView<::fidl::VectorView<uint8_t>>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::VectorView<uint8_t>& mutable_v() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<uint8_t>>().get_data();
  }
  const ::fidl::VectorView<uint8_t>& v() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<uint8_t>>().get_data();
  }
  ::fidl_test_union::wire::StrictBoundedXUnion::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::StrictBoundedXUnion::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_StrictBoundedXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 32;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kV = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::StrictBoundedXUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictBoundedXUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        StrictBoundedXUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        StrictBoundedXUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<StrictBoundedXUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class StrictBoundedXUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(StrictBoundedXUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      StrictBoundedXUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<56> backing_buffer_;
  UnownedEncodedMessage message_;
};

class StrictBoundedXUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<StrictBoundedXUnion> {
 public:
  using DecodedMessageBase<StrictBoundedXUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  StrictBoundedXUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<StrictBoundedXUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_ReverseOrdinalUnionTable;

class ReverseOrdinalUnion {
 public:
  ReverseOrdinalUnion()
      : ordinal_(
            ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::Invalid),
        envelope_{} {}

  ReverseOrdinalUnion(const ReverseOrdinalUnion&) = default;
  ReverseOrdinalUnion& operator=(const ReverseOrdinalUnion&) = default;
  ReverseOrdinalUnion(ReverseOrdinalUnion&&) = default;
  ReverseOrdinalUnion& operator=(ReverseOrdinalUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kSecond = 2,  // 0x2
    kFirst = 1,   // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::Invalid;
  }

  bool is_second() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond;
  }
  static ReverseOrdinalUnion WithSecond(uint32_t val) {
    ReverseOrdinalUnion result;
    result.set_second(std::move(val));
    return result;
  }

  void set_second(uint32_t elem) {
    ordinal_ = ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_second() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& second() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kSecond);
    return envelope_.As<uint32_t>().get_data();
  }

  bool is_first() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst;
  }
  static ReverseOrdinalUnion WithFirst(uint32_t val) {
    ReverseOrdinalUnion result;
    result.set_first(std::move(val));
    return result;
  }

  void set_first(uint32_t elem) {
    ordinal_ = ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst;
    envelope_.As<uint32_t>().set_data(std::move(elem));
  }

  uint32_t& mutable_first() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& first() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal::kFirst);
    return envelope_.As<uint32_t>().get_data();
  }
  ::fidl_test_union::wire::ReverseOrdinalUnion::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::ReverseOrdinalUnion::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_ReverseOrdinalUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kSecond = 2,  // 0x2
    kFirst = 1,   // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::ReverseOrdinalUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ReverseOrdinalUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ReverseOrdinalUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        ReverseOrdinalUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ReverseOrdinalUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ReverseOrdinalUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ReverseOrdinalUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ReverseOrdinalUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ReverseOrdinalUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ReverseOrdinalUnion> {
 public:
  using DecodedMessageBase<ReverseOrdinalUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  ReverseOrdinalUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ReverseOrdinalUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_StrictPizzaOrPastaTable;

class StrictPizzaOrPasta {
 public:
  StrictPizzaOrPasta()
      : ordinal_(::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::Invalid),
        envelope_{} {}

  StrictPizzaOrPasta(const StrictPizzaOrPasta&) = default;
  StrictPizzaOrPasta& operator=(const StrictPizzaOrPasta&) = default;
  StrictPizzaOrPasta(StrictPizzaOrPasta&&) = default;
  StrictPizzaOrPasta& operator=(StrictPizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::Invalid;
  }

  bool is_pizza() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza;
  }
  static StrictPizzaOrPasta WithPizza(
      ::fidl::ObjectView<::fidl_test_union::wire::Pizza> val) {
    StrictPizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  template <typename... Args>
  static StrictPizzaOrPasta WithPizza(::fidl::AnyArena& allocator,
                                      Args&&... args) {
    StrictPizzaOrPasta result;
    result.set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza> elem) {
    ordinal_ = ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza;
    envelope_.As<::fidl_test_union::wire::Pizza>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pizza(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza;
    set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }
  const ::fidl_test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const {
    return ordinal_ ==
           ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta;
  }
  static StrictPizzaOrPasta WithPasta(
      ::fidl::ObjectView<::fidl_test_union::wire::Pasta> val) {
    StrictPizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  template <typename... Args>
  static StrictPizzaOrPasta WithPasta(::fidl::AnyArena& allocator,
                                      Args&&... args) {
    StrictPizzaOrPasta result;
    result.set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta> elem) {
    ordinal_ = ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta;
    envelope_.As<::fidl_test_union::wire::Pasta>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pasta(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta;
    set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  const ::fidl_test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  ::fidl_test_union::wire::StrictPizzaOrPasta::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::StrictPizzaOrPasta::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_StrictPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::StrictPizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class StrictPizzaOrPasta::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        StrictPizzaOrPasta* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, StrictPizzaOrPasta* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<StrictPizzaOrPasta>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class StrictPizzaOrPasta::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(StrictPizzaOrPasta* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      StrictPizzaOrPasta* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class StrictPizzaOrPasta::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<StrictPizzaOrPasta> {
 public:
  using DecodedMessageBase<StrictPizzaOrPasta>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  StrictPizzaOrPasta* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<StrictPizzaOrPasta*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_PizzaOrPastaTable;

class PizzaOrPasta {
 public:
  PizzaOrPasta()
      : ordinal_(::fidl_test_union::wire::PizzaOrPasta::Ordinal::Invalid),
        envelope_{} {}

  PizzaOrPasta(const PizzaOrPasta&) = default;
  PizzaOrPasta& operator=(const PizzaOrPasta&) = default;
  PizzaOrPasta(PizzaOrPasta&&) = default;
  PizzaOrPasta& operator=(PizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::PizzaOrPasta::Ordinal::Invalid;
  }

  bool is_pizza() const {
    return ordinal_ == ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPizza;
  }
  static PizzaOrPasta WithPizza(
      ::fidl::ObjectView<::fidl_test_union::wire::Pizza> val) {
    PizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  template <typename... Args>
  static PizzaOrPasta WithPizza(::fidl::AnyArena& allocator, Args&&... args) {
    PizzaOrPasta result;
    result.set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza> elem) {
    ordinal_ = ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPizza;
    envelope_.As<::fidl_test_union::wire::Pizza>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pizza(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPizza;
    set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }
  const ::fidl_test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const {
    return ordinal_ == ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPasta;
  }
  static PizzaOrPasta WithPasta(
      ::fidl::ObjectView<::fidl_test_union::wire::Pasta> val) {
    PizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  template <typename... Args>
  static PizzaOrPasta WithPasta(::fidl::AnyArena& allocator, Args&&... args) {
    PizzaOrPasta result;
    result.set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta> elem) {
    ordinal_ = ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPasta;
    envelope_.As<::fidl_test_union::wire::Pasta>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pasta(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPasta;
    set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  const ::fidl_test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::PizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  ::fidl_test_union::wire::PizzaOrPasta::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::PizzaOrPasta::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type = &fidl_test_union_PizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::PizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class PizzaOrPasta::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        PizzaOrPasta* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, PizzaOrPasta* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<PizzaOrPasta>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class PizzaOrPasta::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(PizzaOrPasta* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, PizzaOrPasta* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class PizzaOrPasta::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<PizzaOrPasta> {
 public:
  using DecodedMessageBase<PizzaOrPasta>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  PizzaOrPasta* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<PizzaOrPasta*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_FlexiblePizzaOrPastaTable;

class FlexiblePizzaOrPasta {
 public:
  FlexiblePizzaOrPasta()
      : ordinal_(
            ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::Invalid),
        envelope_{} {}

  FlexiblePizzaOrPasta(const FlexiblePizzaOrPasta&) = default;
  FlexiblePizzaOrPasta& operator=(const FlexiblePizzaOrPasta&) = default;
  FlexiblePizzaOrPasta(FlexiblePizzaOrPasta&&) = default;
  FlexiblePizzaOrPasta& operator=(FlexiblePizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::Invalid;
  }

  bool is_pizza() const {
    return ordinal_ ==
           ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza;
  }
  static FlexiblePizzaOrPasta WithPizza(
      ::fidl::ObjectView<::fidl_test_union::wire::Pizza> val) {
    FlexiblePizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  template <typename... Args>
  static FlexiblePizzaOrPasta WithPizza(::fidl::AnyArena& allocator,
                                        Args&&... args) {
    FlexiblePizzaOrPasta result;
    result.set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza> elem) {
    ordinal_ = ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza;
    envelope_.As<::fidl_test_union::wire::Pizza>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pizza(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza;
    set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }
  const ::fidl_test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const {
    return ordinal_ ==
           ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta;
  }
  static FlexiblePizzaOrPasta WithPasta(
      ::fidl::ObjectView<::fidl_test_union::wire::Pasta> val) {
    FlexiblePizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  template <typename... Args>
  static FlexiblePizzaOrPasta WithPasta(::fidl::AnyArena& allocator,
                                        Args&&... args) {
    FlexiblePizzaOrPasta result;
    result.set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta> elem) {
    ordinal_ = ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta;
    envelope_.As<::fidl_test_union::wire::Pasta>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pasta(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta;
    set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  const ::fidl_test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  ::fidl_test_union::wire::FlexiblePizzaOrPasta::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_FlexiblePizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::FlexiblePizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FlexiblePizzaOrPasta::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        FlexiblePizzaOrPasta* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        FlexiblePizzaOrPasta* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<FlexiblePizzaOrPasta>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class FlexiblePizzaOrPasta::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(FlexiblePizzaOrPasta* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      FlexiblePizzaOrPasta* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class FlexiblePizzaOrPasta::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<FlexiblePizzaOrPasta> {
 public:
  using DecodedMessageBase<FlexiblePizzaOrPasta>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  FlexiblePizzaOrPasta* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<FlexiblePizzaOrPasta*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_ExplicitPizzaOrPastaTable;

class ExplicitPizzaOrPasta {
 public:
  ExplicitPizzaOrPasta()
      : ordinal_(
            ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::Invalid),
        envelope_{} {}

  ExplicitPizzaOrPasta(const ExplicitPizzaOrPasta&) = default;
  ExplicitPizzaOrPasta& operator=(const ExplicitPizzaOrPasta&) = default;
  ExplicitPizzaOrPasta(ExplicitPizzaOrPasta&&) = default;
  ExplicitPizzaOrPasta& operator=(ExplicitPizzaOrPasta&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::Invalid;
  }

  bool is_pizza() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza;
  }
  static ExplicitPizzaOrPasta WithPizza(
      ::fidl::ObjectView<::fidl_test_union::wire::Pizza> val) {
    ExplicitPizzaOrPasta result;
    result.set_pizza(val);
    return result;
  }

  template <typename... Args>
  static ExplicitPizzaOrPasta WithPizza(::fidl::AnyArena& allocator,
                                        Args&&... args) {
    ExplicitPizzaOrPasta result;
    result.set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza> elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza;
    envelope_.As<::fidl_test_union::wire::Pizza>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pizza(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza;
    set_pizza(::fidl::ObjectView<::fidl_test_union::wire::Pizza>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pizza& mutable_pizza() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }
  const ::fidl_test_union::wire::Pizza& pizza() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPizza);
    return envelope_.As<::fidl_test_union::wire::Pizza>().get_data();
  }

  bool is_pasta() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta;
  }
  static ExplicitPizzaOrPasta WithPasta(
      ::fidl::ObjectView<::fidl_test_union::wire::Pasta> val) {
    ExplicitPizzaOrPasta result;
    result.set_pasta(val);
    return result;
  }

  template <typename... Args>
  static ExplicitPizzaOrPasta WithPasta(::fidl::AnyArena& allocator,
                                        Args&&... args) {
    ExplicitPizzaOrPasta result;
    result.set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta> elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta;
    envelope_.As<::fidl_test_union::wire::Pasta>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_pasta(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta;
    set_pasta(::fidl::ObjectView<::fidl_test_union::wire::Pasta>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl_test_union::wire::Pasta& mutable_pasta() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  const ::fidl_test_union::wire::Pasta& pasta() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal::kPasta);
    return envelope_.As<::fidl_test_union::wire::Pasta>().get_data();
  }
  ::fidl_test_union::wire::ExplicitPizzaOrPasta::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::ExplicitPizzaOrPasta::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_ExplicitPizzaOrPastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPizza = 1,  // 0x1
    kPasta = 4,  // 0x4
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::ExplicitPizzaOrPasta::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitPizzaOrPasta::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ExplicitPizzaOrPasta* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        ExplicitPizzaOrPasta* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ExplicitPizzaOrPasta>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ExplicitPizzaOrPasta::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ExplicitPizzaOrPasta* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ExplicitPizzaOrPasta* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ExplicitPizzaOrPasta::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ExplicitPizzaOrPasta> {
 public:
  using DecodedMessageBase<ExplicitPizzaOrPasta>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  ExplicitPizzaOrPasta* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ExplicitPizzaOrPasta*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_OlderSimpleUnionTable;

class OlderSimpleUnion {
 public:
  OlderSimpleUnion()
      : ordinal_(::fidl_test_union::wire::OlderSimpleUnion::Ordinal::Invalid),
        envelope_{} {}

  OlderSimpleUnion(const OlderSimpleUnion&) = default;
  OlderSimpleUnion& operator=(const OlderSimpleUnion&) = default;
  OlderSimpleUnion(OlderSimpleUnion&&) = default;
  OlderSimpleUnion& operator=(OlderSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::Invalid;
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kI;
  }
  static OlderSimpleUnion WithI(::fidl::ObjectView<int64_t> val) {
    OlderSimpleUnion result;
    result.set_i(val);
    return result;
  }

  template <typename... Args>
  static OlderSimpleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    OlderSimpleUnion result;
    result.set_i(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_i(::fidl::ObjectView<int64_t> elem) {
    ordinal_ = ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kI;
    envelope_.As<int64_t>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_i(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kI;
    set_i(::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
  }

  int64_t& mutable_i() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool is_f() const {
    return ordinal_ == ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kF;
  }
  static OlderSimpleUnion WithF(float val) {
    OlderSimpleUnion result;
    result.set_f(std::move(val));
    return result;
  }

  void set_f(float elem) {
    ordinal_ = ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kF;
    envelope_.As<float>().set_data(std::move(elem));
  }

  float& mutable_f() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::OlderSimpleUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  ::fidl_test_union::wire::OlderSimpleUnion::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_OlderSimpleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::OlderSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class OlderSimpleUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        OlderSimpleUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, OlderSimpleUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<OlderSimpleUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class OlderSimpleUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(OlderSimpleUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      OlderSimpleUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class OlderSimpleUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<OlderSimpleUnion> {
 public:
  using DecodedMessageBase<OlderSimpleUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  OlderSimpleUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<OlderSimpleUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_NewerSimpleUnionTable;

class NewerSimpleUnion {
 public:
  NewerSimpleUnion()
      : ordinal_(::fidl_test_union::wire::NewerSimpleUnion::Ordinal::Invalid),
        envelope_{} {}

  NewerSimpleUnion(const NewerSimpleUnion&) = default;
  NewerSimpleUnion& operator=(const NewerSimpleUnion&) = default;
  NewerSimpleUnion(NewerSimpleUnion&&) = default;
  NewerSimpleUnion& operator=(NewerSimpleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::Invalid;
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kI;
  }
  static NewerSimpleUnion WithI(::fidl::ObjectView<int64_t> val) {
    NewerSimpleUnion result;
    result.set_i(val);
    return result;
  }

  template <typename... Args>
  static NewerSimpleUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    NewerSimpleUnion result;
    result.set_i(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_i(::fidl::ObjectView<int64_t> elem) {
    ordinal_ = ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kI;
    envelope_.As<int64_t>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_i(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kI;
    set_i(::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
  }

  int64_t& mutable_i() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool is_s() const {
    return ordinal_ == ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kS;
  }
  static NewerSimpleUnion WithS(::fidl::ObjectView<::fidl::StringView> val) {
    NewerSimpleUnion result;
    result.set_s(val);
    return result;
  }

  template <typename... Args>
  static NewerSimpleUnion WithS(::fidl::AnyArena& allocator, Args&&... args) {
    NewerSimpleUnion result;
    result.set_s(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_s(::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kS;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_s(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kS;
    set_s(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                 std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_v() const {
    return ordinal_ == ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kV;
  }
  static NewerSimpleUnion WithV(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    NewerSimpleUnion result;
    result.set_v(val);
    return result;
  }

  template <typename... Args>
  static NewerSimpleUnion WithV(::fidl::AnyArena& allocator, Args&&... args) {
    NewerSimpleUnion result;
    result.set_v(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_v(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> elem) {
    ordinal_ = ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kV;
    envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_v(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kV;
    set_v(::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>& mutable_v() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>& v() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::NewerSimpleUnion::Ordinal::kV);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::fidl_test_union::wire::NewerSimpleUnion::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_NewerSimpleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kS = 2,  // 0x2
    kV = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::NewerSimpleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class NewerSimpleUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        NewerSimpleUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, NewerSimpleUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<NewerSimpleUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class NewerSimpleUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(NewerSimpleUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      NewerSimpleUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class NewerSimpleUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<NewerSimpleUnion> {
 public:
  using DecodedMessageBase<NewerSimpleUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  NewerSimpleUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<NewerSimpleUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_FlexibleUnionTable;

class FlexibleUnion {
 public:
  FlexibleUnion()
      : ordinal_(::fidl_test_union::wire::FlexibleUnion::Ordinal::Invalid),
        envelope_{} {}

  FlexibleUnion(const FlexibleUnion&) = default;
  FlexibleUnion& operator=(const FlexibleUnion&) = default;
  FlexibleUnion(FlexibleUnion&&) = default;
  FlexibleUnion& operator=(FlexibleUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::Invalid;
  }

  bool is_primitive() const {
    return ordinal_ ==
           ::fidl_test_union::wire::FlexibleUnion::Ordinal::kPrimitive;
  }
  static FlexibleUnion WithPrimitive(int32_t val) {
    FlexibleUnion result;
    result.set_primitive(std::move(val));
    return result;
  }

  void set_primitive(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::FlexibleUnion::Ordinal::kPrimitive;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_primitive() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::FlexibleUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::FlexibleUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const {
    return ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::
                           kStringNeedsConstructor;
  }
  static FlexibleUnion WithStringNeedsConstructor(
      ::fidl::ObjectView<::fidl::StringView> val) {
    FlexibleUnion result;
    result.set_string_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static FlexibleUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator,
                                                  Args&&... args) {
    FlexibleUnion result;
    result.set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_string_needs_constructor(
      ::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::FlexibleUnion::Ordinal::
        kStringNeedsConstructor;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_string_needs_constructor(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::FlexibleUnion::Ordinal::
        kStringNeedsConstructor;
    set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::
                              kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::
                              kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_vector_string_also_needs_constructor() const {
    return ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::
                           kVectorStringAlsoNeedsConstructor;
  }
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> val) {
    FlexibleUnion result;
    result.set_vector_string_also_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static FlexibleUnion WithVectorStringAlsoNeedsConstructor(
      ::fidl::AnyArena& allocator, Args&&... args) {
    FlexibleUnion result;
    result.set_vector_string_also_needs_constructor(
        ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
            allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_vector_string_also_needs_constructor(
      ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>> elem) {
    ordinal_ = ::fidl_test_union::wire::FlexibleUnion::Ordinal::
        kVectorStringAlsoNeedsConstructor;
    envelope_.As<::fidl::VectorView<::fidl::StringView>>().set_data(
        std::move(elem));
  }

  template <typename... Args>
  void set_vector_string_also_needs_constructor(::fidl::AnyArena& allocator,
                                                Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::FlexibleUnion::Ordinal::
        kVectorStringAlsoNeedsConstructor;
    set_vector_string_also_needs_constructor(
        ::fidl::ObjectView<::fidl::VectorView<::fidl::StringView>>(
            allocator, std::forward<Args>(args)...));
  }

  ::fidl::VectorView<::fidl::StringView>&
  mutable_vector_string_also_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::
                              kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  const ::fidl::VectorView<::fidl::StringView>&
  vector_string_also_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleUnion::Ordinal::
                              kVectorStringAlsoNeedsConstructor);
    return envelope_.As<::fidl::VectorView<::fidl::StringView>>().get_data();
  }
  ::fidl_test_union::wire::FlexibleUnion::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_FlexibleUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,                         // 0x1
    kStringNeedsConstructor = 2,            // 0x2
    kVectorStringAlsoNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::FlexibleUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FlexibleUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        FlexibleUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, FlexibleUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<FlexibleUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class FlexibleUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(FlexibleUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      FlexibleUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class FlexibleUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<FlexibleUnion> {
 public:
  using DecodedMessageBase<FlexibleUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  FlexibleUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<FlexibleUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_FlexibleFooTable;

class FlexibleFoo {
 public:
  FlexibleFoo()
      : ordinal_(::fidl_test_union::wire::FlexibleFoo::Ordinal::Invalid),
        envelope_{} {}

  FlexibleFoo(const FlexibleFoo&) = default;
  FlexibleFoo& operator=(const FlexibleFoo&) = default;
  FlexibleFoo(FlexibleFoo&&) = default;
  FlexibleFoo& operator=(FlexibleFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 1,  // 0x1
    kI = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::Invalid;
  }

  bool is_s() const {
    return ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::kS;
  }
  static FlexibleFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    FlexibleFoo result;
    result.set_s(val);
    return result;
  }

  template <typename... Args>
  static FlexibleFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    FlexibleFoo result;
    result.set_s(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_s(::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::FlexibleFoo::Ordinal::kS;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_s(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::FlexibleFoo::Ordinal::kS;
    set_s(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                 std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::kI;
  }
  static FlexibleFoo WithI(int32_t val) {
    FlexibleFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::FlexibleFoo::Ordinal::kI;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::FlexibleFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::fidl_test_union::wire::FlexibleFoo::Tag which() const;

  static constexpr const fidl_type_t* Type = &fidl_test_union_FlexibleFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 1,  // 0x1
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::FlexibleFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FlexibleFoo::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        FlexibleFoo* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, FlexibleFoo* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<FlexibleFoo>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class FlexibleFoo::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(FlexibleFoo* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, FlexibleFoo* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class FlexibleFoo::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<FlexibleFoo> {
 public:
  using DecodedMessageBase<FlexibleFoo>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  FlexibleFoo* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<FlexibleFoo*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_FieldCollisionTable;

class FieldCollision {
 public:
  FieldCollision()
      : ordinal_(::fidl_test_union::wire::FieldCollision::Ordinal::Invalid),
        envelope_{} {}

  FieldCollision(const FieldCollision&) = default;
  FieldCollision& operator=(const FieldCollision&) = default;
  FieldCollision(FieldCollision&&) = default;
  FieldCollision& operator=(FieldCollision&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kFieldCollisionTag = 1,  // 0x1
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::FieldCollision::Ordinal::Invalid;
  }

  bool is_field_collision_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag;
  }
  static FieldCollision WithFieldCollisionTag(int32_t val) {
    FieldCollision result;
    result.set_field_collision_tag(std::move(val));
    return result;
  }

  void set_field_collision_tag(int32_t elem) {
    ordinal_ =
        ::fidl_test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_field_collision_tag() {
    ZX_ASSERT(
        ordinal_ ==
        ::fidl_test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& field_collision_tag() const {
    ZX_ASSERT(
        ordinal_ ==
        ::fidl_test_union::wire::FieldCollision::Ordinal::kFieldCollisionTag);
    return envelope_.As<int32_t>().get_data();
  }
  ::fidl_test_union::wire::FieldCollision::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::FieldCollision::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_FieldCollisionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kFieldCollisionTag = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::FieldCollision::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class FieldCollision::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        FieldCollision* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, FieldCollision* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<FieldCollision>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class FieldCollision::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(FieldCollision* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      FieldCollision* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class FieldCollision::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<FieldCollision> {
 public:
  using DecodedMessageBase<FieldCollision>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  FieldCollision* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<FieldCollision*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_ExplicitXUnionTable;

class ExplicitXUnion {
 public:
  ExplicitXUnion()
      : ordinal_(::fidl_test_union::wire::ExplicitXUnion::Ordinal::Invalid),
        envelope_{} {}

  ExplicitXUnion(const ExplicitXUnion&) = default;
  ExplicitXUnion& operator=(const ExplicitXUnion&) = default;
  ExplicitXUnion(ExplicitXUnion&&) = default;
  ExplicitXUnion& operator=(ExplicitXUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kI = 1,  // 0x1
    kF = 4,  // 0x4
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ExplicitXUnion::Ordinal::Invalid;
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kI;
  }
  static ExplicitXUnion WithI(::fidl::ObjectView<int64_t> val) {
    ExplicitXUnion result;
    result.set_i(val);
    return result;
  }

  template <typename... Args>
  static ExplicitXUnion WithI(::fidl::AnyArena& allocator, Args&&... args) {
    ExplicitXUnion result;
    result.set_i(
        ::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_i(::fidl::ObjectView<int64_t> elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kI;
    envelope_.As<int64_t>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_i(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kI;
    set_i(::fidl::ObjectView<int64_t>(allocator, std::forward<Args>(args)...));
  }

  int64_t& mutable_i() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }
  const int64_t& i() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kI);
    return envelope_.As<int64_t>().get_data();
  }

  bool is_f() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kF;
  }
  static ExplicitXUnion WithF(float val) {
    ExplicitXUnion result;
    result.set_f(std::move(val));
    return result;
  }

  void set_f(float elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kF;
    envelope_.As<float>().set_data(std::move(elem));
  }

  float& mutable_f() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  const float& f() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitXUnion::Ordinal::kF);
    return envelope_.As<float>().get_data();
  }
  ::fidl_test_union::wire::ExplicitXUnion::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_ExplicitXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kI = 1,  // 0x1
    kF = 4,  // 0x4
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::ExplicitXUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitXUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ExplicitXUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, ExplicitXUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ExplicitXUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ExplicitXUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ExplicitXUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ExplicitXUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class ExplicitXUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ExplicitXUnion> {
 public:
  using DecodedMessageBase<ExplicitXUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  ExplicitXUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ExplicitXUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_ExplicitUnionTable;

class ExplicitUnion {
 public:
  ExplicitUnion()
      : ordinal_(::fidl_test_union::wire::ExplicitUnion::Ordinal::Invalid),
        envelope_{} {}

  ExplicitUnion(const ExplicitUnion&) = default;
  ExplicitUnion& operator=(const ExplicitUnion&) = default;
  ExplicitUnion(ExplicitUnion&&) = default;
  ExplicitUnion& operator=(ExplicitUnion&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitUnion::Ordinal::Invalid;
  }

  bool is_primitive() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ExplicitUnion::Ordinal::kPrimitive;
  }
  static ExplicitUnion WithPrimitive(int32_t val) {
    ExplicitUnion result;
    result.set_primitive(std::move(val));
    return result;
  }

  void set_primitive(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitUnion::Ordinal::kPrimitive;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_primitive() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& primitive() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitUnion::Ordinal::kPrimitive);
    return envelope_.As<int32_t>().get_data();
  }

  bool is_string_needs_constructor() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitUnion::Ordinal::
                           kStringNeedsConstructor;
  }
  static ExplicitUnion WithStringNeedsConstructor(
      ::fidl::ObjectView<::fidl::StringView> val) {
    ExplicitUnion result;
    result.set_string_needs_constructor(val);
    return result;
  }

  template <typename... Args>
  static ExplicitUnion WithStringNeedsConstructor(::fidl::AnyArena& allocator,
                                                  Args&&... args) {
    ExplicitUnion result;
    result.set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_string_needs_constructor(
      ::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitUnion::Ordinal::
        kStringNeedsConstructor;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_string_needs_constructor(::fidl::AnyArena& allocator,
                                    Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::ExplicitUnion::Ordinal::
        kStringNeedsConstructor;
    set_string_needs_constructor(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_string_needs_constructor() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitUnion::Ordinal::
                              kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& string_needs_constructor() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitUnion::Ordinal::
                              kStringNeedsConstructor);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  ::fidl_test_union::wire::ExplicitUnion::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::ExplicitUnion::Tag>(ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_ExplicitUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kPrimitive = 1,               // 0x1
    kStringNeedsConstructor = 3,  // 0x3
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::ExplicitUnion::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ExplicitUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, ExplicitUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ExplicitUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ExplicitUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ExplicitUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ExplicitUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ExplicitUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ExplicitUnion> {
 public:
  using DecodedMessageBase<ExplicitUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  ExplicitUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ExplicitUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_ExplicitStrictFooTable;

class ExplicitStrictFoo {
 public:
  ExplicitStrictFoo()
      : ordinal_(::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::Invalid),
        envelope_{} {}

  ExplicitStrictFoo(const ExplicitStrictFoo&) = default;
  ExplicitStrictFoo& operator=(const ExplicitStrictFoo&) = default;
  ExplicitStrictFoo(ExplicitStrictFoo&&) = default;
  ExplicitStrictFoo& operator=(ExplicitStrictFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::Invalid;
  }

  bool is_s() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kS;
  }
  static ExplicitStrictFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    ExplicitStrictFoo result;
    result.set_s(val);
    return result;
  }

  template <typename... Args>
  static ExplicitStrictFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    ExplicitStrictFoo result;
    result.set_s(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_s(::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kS;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_s(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kS;
    set_s(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                 std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kI;
  }
  static ExplicitStrictFoo WithI(int32_t val) {
    ExplicitStrictFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kI;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ ==
              ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::fidl_test_union::wire::ExplicitStrictFoo::Tag which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::fidl_test_union::wire::ExplicitStrictFoo::Tag>(
        ordinal_);
  }

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_ExplicitStrictFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 3,  // 0x3
    kI = 2,  // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::ExplicitStrictFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitStrictFoo::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ExplicitStrictFoo* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, ExplicitStrictFoo* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ExplicitStrictFoo>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ExplicitStrictFoo::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ExplicitStrictFoo* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      ExplicitStrictFoo* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ExplicitStrictFoo::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ExplicitStrictFoo> {
 public:
  using DecodedMessageBase<ExplicitStrictFoo>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  ExplicitStrictFoo* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ExplicitStrictFoo*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_ExplicitFooTable;

class ExplicitFoo {
 public:
  ExplicitFoo()
      : ordinal_(::fidl_test_union::wire::ExplicitFoo::Ordinal::Invalid),
        envelope_{} {}

  ExplicitFoo(const ExplicitFoo&) = default;
  ExplicitFoo& operator=(const ExplicitFoo&) = default;
  ExplicitFoo(ExplicitFoo&&) = default;
  ExplicitFoo& operator=(ExplicitFoo&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kS = 2,  // 0x2
    kI = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::Invalid;
  }

  bool is_s() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::kS;
  }
  static ExplicitFoo WithS(::fidl::ObjectView<::fidl::StringView> val) {
    ExplicitFoo result;
    result.set_s(val);
    return result;
  }

  template <typename... Args>
  static ExplicitFoo WithS(::fidl::AnyArena& allocator, Args&&... args) {
    ExplicitFoo result;
    result.set_s(::fidl::ObjectView<::fidl::StringView>(
        allocator, std::forward<Args>(args)...));
    return result;
  }

  void set_s(::fidl::ObjectView<::fidl::StringView> elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitFoo::Ordinal::kS;
    envelope_.As<::fidl::StringView>().set_data(std::move(elem));
  }

  template <typename... Args>
  void set_s(::fidl::AnyArena& allocator, Args&&... args) {
    ordinal_ = ::fidl_test_union::wire::ExplicitFoo::Ordinal::kS;
    set_s(::fidl::ObjectView<::fidl::StringView>(allocator,
                                                 std::forward<Args>(args)...));
  }

  ::fidl::StringView& mutable_s() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }
  const ::fidl::StringView& s() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::kS);
    return envelope_.As<::fidl::StringView>().get_data();
  }

  bool is_i() const {
    return ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::kI;
  }
  static ExplicitFoo WithI(int32_t val) {
    ExplicitFoo result;
    result.set_i(std::move(val));
    return result;
  }

  void set_i(int32_t elem) {
    ordinal_ = ::fidl_test_union::wire::ExplicitFoo::Ordinal::kI;
    envelope_.As<int32_t>().set_data(std::move(elem));
  }

  int32_t& mutable_i() {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  const int32_t& i() const {
    ZX_ASSERT(ordinal_ == ::fidl_test_union::wire::ExplicitFoo::Ordinal::kI);
    return envelope_.As<int32_t>().get_data();
  }
  ::fidl_test_union::wire::ExplicitFoo::Tag which() const;

  static constexpr const fidl_type_t* Type = &fidl_test_union_ExplicitFooTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kS = 2,  // 0x2
    kI = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::ExplicitFoo::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class ExplicitFoo::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        ExplicitFoo* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, ExplicitFoo* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<ExplicitFoo>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class ExplicitFoo::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(ExplicitFoo* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, ExplicitFoo* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class ExplicitFoo::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<ExplicitFoo> {
 public:
  using DecodedMessageBase<ExplicitFoo>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  ExplicitFoo* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<ExplicitFoo*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_XUnionContainingEmptyStructTable;

class XUnionContainingEmptyStruct {
 public:
  XUnionContainingEmptyStruct()
      : ordinal_(::fidl_test_union::wire::XUnionContainingEmptyStruct::Ordinal::
                     Invalid),
        envelope_{} {}

  XUnionContainingEmptyStruct(const XUnionContainingEmptyStruct&) = default;
  XUnionContainingEmptyStruct& operator=(const XUnionContainingEmptyStruct&) =
      default;
  XUnionContainingEmptyStruct(XUnionContainingEmptyStruct&&) = default;
  XUnionContainingEmptyStruct& operator=(XUnionContainingEmptyStruct&&) =
      default;

  enum class Tag : fidl_xunion_tag_t {
    kEmpty = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::fidl_test_union::wire::XUnionContainingEmptyStruct::
                           Ordinal::Invalid;
  }

  bool is_empty() const {
    return ordinal_ == ::fidl_test_union::wire::XUnionContainingEmptyStruct::
                           Ordinal::kEmpty;
  }
  static XUnionContainingEmptyStruct WithEmpty(
      ::fidl_test_union::wire::Empty val) {
    XUnionContainingEmptyStruct result;
    result.set_empty(std::move(val));
    return result;
  }

  void set_empty(::fidl_test_union::wire::Empty elem) {
    ordinal_ =
        ::fidl_test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty;
    envelope_.As<::fidl_test_union::wire::Empty>().set_data(std::move(elem));
  }

  ::fidl_test_union::wire::Empty& mutable_empty() {
    ZX_ASSERT(
        ordinal_ ==
        ::fidl_test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty);
    return envelope_.As<::fidl_test_union::wire::Empty>().get_data();
  }
  const ::fidl_test_union::wire::Empty& empty() const {
    ZX_ASSERT(
        ordinal_ ==
        ::fidl_test_union::wire::XUnionContainingEmptyStruct::Ordinal::kEmpty);
    return envelope_.As<::fidl_test_union::wire::Empty>().get_data();
  }
  ::fidl_test_union::wire::XUnionContainingEmptyStruct::Tag which() const;

  static constexpr const fidl_type_t* Type =
      &fidl_test_union_XUnionContainingEmptyStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 0;
  static constexpr bool HasPointer = true;

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kEmpty = 1,  // 0x1
  };

  static void SizeAndOffsetAssertionHelper();
  ::fidl_test_union::wire::XUnionContainingEmptyStruct::Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

class XUnionContainingEmptyStruct::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        XUnionContainingEmptyStruct* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        XUnionContainingEmptyStruct* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<XUnionContainingEmptyStruct>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class XUnionContainingEmptyStruct::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(XUnionContainingEmptyStruct* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Construct a message using owned buffers.
  // If |iovec_capacity>1|, then the message in OwnedEncodedMessage may point
  // the input FIDL object, which is not owned by it.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      XUnionContainingEmptyStruct* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class XUnionContainingEmptyStruct::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<XUnionContainingEmptyStruct> {
 public:
  using DecodedMessageBase<XUnionContainingEmptyStruct>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  XUnionContainingEmptyStruct* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<XUnionContainingEmptyStruct*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_StructWithNullableXUnionTable;

struct StructWithNullableXUnion {
  static constexpr const fidl_type_t* Type =
      &fidl_test_union_StructWithNullableXUnionTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  ::fidl_test_union::wire::OlderSimpleUnion x1 = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class StructWithNullableXUnion::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        StructWithNullableXUnion* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        StructWithNullableXUnion* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<StructWithNullableXUnion>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class StructWithNullableXUnion::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(StructWithNullableXUnion* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      StructWithNullableXUnion* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class StructWithNullableXUnion::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<StructWithNullableXUnion> {
 public:
  using DecodedMessageBase<StructWithNullableXUnion>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  StructWithNullableXUnion* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<StructWithNullableXUnion*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_PizzaTable;

struct Pizza {
  static constexpr const fidl_type_t* Type = &fidl_test_union_PizzaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::fidl::VectorView<::fidl::StringView> toppings = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Pizza::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Pizza* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Pizza* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Pizza>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Pizza::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Pizza* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, Pizza* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class Pizza::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Pizza> {
 public:
  using DecodedMessageBase<Pizza>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Pizza* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Pizza*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_PastaTable;

struct Pasta {
  static constexpr const fidl_type_t* Type = &fidl_test_union_PastaTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 16;
  static constexpr bool HasPointer = true;

  ::fidl::StringView sauce = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class Pasta::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        Pasta* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, Pasta* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<Pasta>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class Pasta::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(Pasta* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned, Pasta* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<32> backing_buffer_;
  UnownedEncodedMessage message_;
};

class Pasta::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<Pasta> {
 public:
  using DecodedMessageBase<Pasta>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  Pasta* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<Pasta*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_NullableUnionStructTable;

struct NullableUnionStruct {
  static constexpr const fidl_type_t* Type =
      &fidl_test_union_NullableUnionStructTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 16;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 4294967295;
  static constexpr bool HasPointer = true;

  ::fidl_test_union::wire::Union the_union = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class NullableUnionStruct::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        NullableUnionStruct* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size,
                        NullableUnionStruct* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<NullableUnionStruct>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class NullableUnionStruct::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(NullableUnionStruct* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      NullableUnionStruct* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES>
      backing_buffer_;
  UnownedEncodedMessage message_;
};

class NullableUnionStruct::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<NullableUnionStruct> {
 public:
  using DecodedMessageBase<NullableUnionStruct>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  NullableUnionStruct* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<NullableUnionStruct*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

extern "C" const fidl_type_t fidl_test_union_UnionSandwichTable;

struct UnionSandwich {
  static constexpr const fidl_type_t* Type =
      &fidl_test_union_UnionSandwichTable;
  static constexpr uint32_t MaxNumHandles = 0;
  static constexpr uint32_t PrimarySize = 32;
  [[maybe_unused]] static constexpr uint32_t MaxOutOfLine = 8;
  static constexpr bool HasPointer = true;

  uint32_t a = {};

  ::fidl_test_union::wire::ExplicitXUnion u = {};

  uint32_t b = {};

  class UnownedEncodedMessage;
  class OwnedEncodedMessage;
  class DecodedMessage;
};

class UnionSandwich::UnownedEncodedMessage final {
 public:
  UnownedEncodedMessage(uint8_t* backing_buffer, uint32_t backing_buffer_size,
                        UnionSandwich* value)
      : UnownedEncodedMessage(::fidl::internal::IovecBufferSize, backing_buffer,
                              backing_buffer_size, value) {}
  UnownedEncodedMessage(uint32_t iovec_capacity, uint8_t* backing_buffer,
                        uint32_t backing_buffer_size, UnionSandwich* value)
      : message_(::fidl::OutgoingMessage::ConstructorArgs{
            .transport_type = FIDL_TRANSPORT_TYPE_CHANNEL,
            .iovecs = iovecs_,
            .iovec_capacity = iovec_capacity,
            .backing_buffer = backing_buffer,
            .backing_buffer_capacity = backing_buffer_size,
        }) {
    ZX_ASSERT(iovec_capacity <= std::size(iovecs_));
    message_.Encode<UnionSandwich>(value);
  }
  UnownedEncodedMessage(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage(UnownedEncodedMessage&&) = delete;
  UnownedEncodedMessage* operator=(const UnownedEncodedMessage&) = delete;
  UnownedEncodedMessage* operator=(UnownedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.status() == ZX_OK; }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() { return message_; }

 private:
  ::fidl::internal::IovecBuffer iovecs_;
  ::fidl::OutgoingMessage message_;
};

class UnionSandwich::OwnedEncodedMessage final {
 public:
  explicit OwnedEncodedMessage(UnionSandwich* value)
      : message_(1u, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  // Internal constructor.
  explicit OwnedEncodedMessage(
      ::fidl::internal::AllowUnownedInputRef allow_unowned,
      UnionSandwich* value)
      : message_(::fidl::internal::IovecBufferSize, backing_buffer_.data(),
                 static_cast<uint32_t>(backing_buffer_.size()), value) {}
  OwnedEncodedMessage(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage(OwnedEncodedMessage&&) = delete;
  OwnedEncodedMessage* operator=(const OwnedEncodedMessage&) = delete;
  OwnedEncodedMessage* operator=(OwnedEncodedMessage&&) = delete;

  zx_status_t status() const { return message_.status(); }
#ifdef __Fuchsia__
  const char* status_string() const { return message_.status_string(); }
#endif  // __Fuchsia__
  bool ok() const { return message_.ok(); }
  std::string FormatDescription() const { return message_.FormatDescription(); }
  const char* lossy_description() const { return message_.lossy_description(); }
  const ::fidl::Result& error() const { return message_.error(); }

  ::fidl::OutgoingMessage& GetOutgoingMessage() {
    return message_.GetOutgoingMessage();
  }

 private:
  ::fidl::internal::InlineMessageBuffer<48> backing_buffer_;
  UnownedEncodedMessage message_;
};

class UnionSandwich::DecodedMessage final
    : public ::fidl::internal::DecodedMessageBase<UnionSandwich> {
 public:
  using DecodedMessageBase<UnionSandwich>::DecodedMessageBase;

  DecodedMessage(
      uint8_t* bytes, uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            ::fidl::internal::kLLCPPEncodedWireFormatVersion,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(
      ::fidl::internal::WireFormatVersion wire_format_version, uint8_t* bytes,
      uint32_t byte_actual, zx_handle_t* handles = nullptr,
      void* handle_metadata = nullptr, uint32_t handle_actual = 0,
      fidl_transport_type transport_type = FIDL_TRANSPORT_TYPE_CHANNEL)
      : DecodedMessageBase(
            wire_format_version,
            ::fidl::IncomingMessage(
                transport_type, bytes, byte_actual, handles, handle_metadata,
                handle_actual,
                ::fidl::IncomingMessage::kSkipMessageHeaderValidation)) {}

  DecodedMessage(const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  // Internal constructor for specifying a specific wire format version.
  DecodedMessage(::fidl::internal::WireFormatVersion wire_format_version,
                 const fidl_incoming_msg_t* c_msg)
      : DecodedMessage(wire_format_version,
                       reinterpret_cast<uint8_t*>(c_msg->bytes),
                       c_msg->num_bytes, c_msg->handles, c_msg->handle_metadata,
                       c_msg->num_handles) {}

  UnionSandwich* PrimaryObject() {
    ZX_DEBUG_ASSERT(ok());
    return reinterpret_cast<UnionSandwich*>(bytes());
  }

  // Release the ownership of the decoded message. That means that the handles
  // won't be closed When the object is destroyed. After calling this method,
  // the |DecodedMessage| object should not be used anymore.
  void ReleasePrimaryObject() { ResetBytes(); }
};

}  // namespace wire
}  // namespace fidl_test_union
namespace fidl {

template <>
struct IsFidlType<::fidl_test_union::wire::StructWithNullableXUnion>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_union::wire::StructWithNullableXUnion>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_union::wire::StructWithNullableXUnion>);
static_assert(offsetof(::fidl_test_union::wire::StructWithNullableXUnion, x1) ==
              0);
static_assert(sizeof(::fidl_test_union::wire::StructWithNullableXUnion) ==
              ::fidl_test_union::wire::StructWithNullableXUnion::PrimarySize);

template <>
struct IsFidlType<::fidl_test_union::wire::Pizza> : public std::true_type {};
template <>
struct IsStruct<::fidl_test_union::wire::Pizza> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::Pizza>);
static_assert(offsetof(::fidl_test_union::wire::Pizza, toppings) == 0);
static_assert(sizeof(::fidl_test_union::wire::Pizza) ==
              ::fidl_test_union::wire::Pizza::PrimarySize);

template <>
struct IsFidlType<::fidl_test_union::wire::Pasta> : public std::true_type {};
template <>
struct IsStruct<::fidl_test_union::wire::Pasta> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::Pasta>);
static_assert(offsetof(::fidl_test_union::wire::Pasta, sauce) == 0);
static_assert(sizeof(::fidl_test_union::wire::Pasta) ==
              ::fidl_test_union::wire::Pasta::PrimarySize);

template <>
struct IsFidlType<::fidl_test_union::wire::NullableUnionStruct>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_union::wire::NullableUnionStruct>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::NullableUnionStruct>);
static_assert(offsetof(::fidl_test_union::wire::NullableUnionStruct,
                       the_union) == 0);
static_assert(sizeof(::fidl_test_union::wire::NullableUnionStruct) ==
              ::fidl_test_union::wire::NullableUnionStruct::PrimarySize);

template <>
struct IsFidlType<::fidl_test_union::wire::UnionSandwich>
    : public std::true_type {};
template <>
struct IsStruct<::fidl_test_union::wire::UnionSandwich>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::UnionSandwich>);
static_assert(offsetof(::fidl_test_union::wire::UnionSandwich, a) == 0);
static_assert(offsetof(::fidl_test_union::wire::UnionSandwich, u) == 8);
static_assert(offsetof(::fidl_test_union::wire::UnionSandwich, b) == 24);
static_assert(sizeof(::fidl_test_union::wire::UnionSandwich) ==
              ::fidl_test_union::wire::UnionSandwich::PrimarySize);

template <>
struct IsFidlType<::fidl_test_union::wire::Empty> : public std::true_type {};
template <>
struct IsStruct<::fidl_test_union::wire::Empty> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::Empty>);
static_assert(offsetof(::fidl_test_union::wire::Empty, __reserved) == 0);
static_assert(sizeof(::fidl_test_union::wire::Empty) ==
              ::fidl_test_union::wire::Empty::PrimarySize);

template <>
struct IsFidlType<::fidl_test_union::wire::UnionWithAttributes>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::UnionWithAttributes>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::UnionWithAttributes>);

template <>
struct IsFidlType<::fidl_test_union::wire::Union> : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::Union> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::Union>);

template <>
struct IsFidlType<::fidl_test_union::wire::StrictUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::StrictUnion> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::StrictUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::StrictSimpleXUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::StrictSimpleXUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::StrictSimpleXUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::StrictFoo> : public std::true_type {
};
template <>
struct IsUnion<::fidl_test_union::wire::StrictFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::StrictFoo>);

template <>
struct IsFidlType<::fidl_test_union::wire::StrictBoundedXUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::StrictBoundedXUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::StrictBoundedXUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::ReverseOrdinalUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::ReverseOrdinalUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::ReverseOrdinalUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::StrictPizzaOrPasta>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::StrictPizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::StrictPizzaOrPasta>);

template <>
struct IsFidlType<::fidl_test_union::wire::PizzaOrPasta>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::PizzaOrPasta> : public std::true_type {
};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::PizzaOrPasta>);

template <>
struct IsFidlType<::fidl_test_union::wire::FlexiblePizzaOrPasta>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::FlexiblePizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::FlexiblePizzaOrPasta>);

template <>
struct IsFidlType<::fidl_test_union::wire::ExplicitPizzaOrPasta>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::ExplicitPizzaOrPasta>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::ExplicitPizzaOrPasta>);

template <>
struct IsFidlType<::fidl_test_union::wire::OlderSimpleUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::OlderSimpleUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::OlderSimpleUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::NewerSimpleUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::NewerSimpleUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::NewerSimpleUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::FlexibleUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::FlexibleUnion> : public std::true_type {
};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::FlexibleUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::FlexibleFoo>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::FlexibleFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::FlexibleFoo>);

template <>
struct IsFidlType<::fidl_test_union::wire::FieldCollision>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::FieldCollision>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::FieldCollision>);

template <>
struct IsFidlType<::fidl_test_union::wire::ExplicitXUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::ExplicitXUnion>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::ExplicitXUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::ExplicitUnion>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::ExplicitUnion> : public std::true_type {
};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::ExplicitUnion>);

template <>
struct IsFidlType<::fidl_test_union::wire::ExplicitStrictFoo>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::ExplicitStrictFoo>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::fidl_test_union::wire::ExplicitStrictFoo>);

template <>
struct IsFidlType<::fidl_test_union::wire::ExplicitFoo>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::ExplicitFoo> : public std::true_type {};
static_assert(std::is_standard_layout_v<::fidl_test_union::wire::ExplicitFoo>);

template <>
struct IsFidlType<::fidl_test_union::wire::XUnionContainingEmptyStruct>
    : public std::true_type {};
template <>
struct IsUnion<::fidl_test_union::wire::XUnionContainingEmptyStruct>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::fidl_test_union::wire::XUnionContainingEmptyStruct>);

}  // namespace fidl
