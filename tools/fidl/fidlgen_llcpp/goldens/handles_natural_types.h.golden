// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.handles/cpp/common_types.h>
#include <fidl/test.handles/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/internal/codable_base.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/bti.h>
#include <lib/zx/channel.h>
#include <lib/zx/clock.h>
#include <lib/zx/debuglog.h>
#include <lib/zx/event.h>
#include <lib/zx/eventpair.h>
#include <lib/zx/exception.h>
#include <lib/zx/fifo.h>
#include <lib/zx/guest.h>
#include <lib/zx/handle.h>
#include <lib/zx/interrupt.h>
#include <lib/zx/iommu.h>
#include <lib/zx/job.h>
#include <lib/zx/pager.h>
#include <lib/zx/pcidevice.h>
#include <lib/zx/pmt.h>
#include <lib/zx/port.h>
#include <lib/zx/process.h>
#include <lib/zx/profile.h>
#include <lib/zx/resource.h>
#include <lib/zx/socket.h>
#include <lib/zx/suspendtoken.h>
#include <lib/zx/thread.h>
#include <lib/zx/timer.h>
#include <lib/zx/vcpu.h>
#include <lib/zx/vmar.h>
#include <lib/zx/vmo.h>

#endif  // __Fuchsia__

namespace test_handles {
class Handles;

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;

class Handles final : public ::fidl::internal::CodableBase<Handles> {
 private:
  struct Storage_;

 public:
  Handles(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Handles(::zx::handle plain_handle, ::zx::bti bti_handle,
          ::zx::channel channel_handle, ::zx::clock clock_handle,
          ::zx::debuglog debuglog_handle, ::zx::event event_handle,
          ::zx::eventpair eventpair_handle, ::zx::exception exception_handle,
          ::zx::fifo fifo_handle, ::zx::guest guest_handle,
          ::zx::interrupt interrupt_handle, ::zx::iommu iommu_handle,
          ::zx::job job_handle, ::zx::pager pager_handle,
          ::zx::pcidevice pcidevice_handle, ::zx::pmt pmt_handle,
          ::zx::port port_handle, ::zx::process process_handle,
          ::zx::profile profile_handle, ::zx::resource resource_handle,
          ::zx::socket socket_handle, ::zx::suspendtoken suspendtoken_handle,
          ::zx::thread thread_handle, ::zx::timer timer_handle,
          ::zx::vcpu vcpu_handle, ::zx::vmar vmar_handle, ::zx::vmo vmo_handle,
          ::zx::vmo rights_handle, ::zx::handle aliased_plain_handle_field,
          ::zx::vmo aliased_subtype_handle_field,
          ::zx::vmo aliased_rights_handle_field,
          ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol,
          ::fidl::ServerEnd<::test_handles::SomeProtocol>
              request_some_protocol) noexcept
      : storage_({.plain_handle = std::move(plain_handle),
                  .bti_handle = std::move(bti_handle),
                  .channel_handle = std::move(channel_handle),
                  .clock_handle = std::move(clock_handle),
                  .debuglog_handle = std::move(debuglog_handle),
                  .event_handle = std::move(event_handle),
                  .eventpair_handle = std::move(eventpair_handle),
                  .exception_handle = std::move(exception_handle),
                  .fifo_handle = std::move(fifo_handle),
                  .guest_handle = std::move(guest_handle),
                  .interrupt_handle = std::move(interrupt_handle),
                  .iommu_handle = std::move(iommu_handle),
                  .job_handle = std::move(job_handle),
                  .pager_handle = std::move(pager_handle),
                  .pcidevice_handle = std::move(pcidevice_handle),
                  .pmt_handle = std::move(pmt_handle),
                  .port_handle = std::move(port_handle),
                  .process_handle = std::move(process_handle),
                  .profile_handle = std::move(profile_handle),
                  .resource_handle = std::move(resource_handle),
                  .socket_handle = std::move(socket_handle),
                  .suspendtoken_handle = std::move(suspendtoken_handle),
                  .thread_handle = std::move(thread_handle),
                  .timer_handle = std::move(timer_handle),
                  .vcpu_handle = std::move(vcpu_handle),
                  .vmar_handle = std::move(vmar_handle),
                  .vmo_handle = std::move(vmo_handle),
                  .rights_handle = std::move(rights_handle),
                  .aliased_plain_handle_field =
                      std::move(aliased_plain_handle_field),
                  .aliased_subtype_handle_field =
                      std::move(aliased_subtype_handle_field),
                  .aliased_rights_handle_field =
                      std::move(aliased_rights_handle_field),
                  .some_protocol = std::move(some_protocol),
                  .request_some_protocol = std::move(request_some_protocol)}) {}
  Handles() : Handles(Storage_{}) {}

  Handles(Handles&&) noexcept = default;
  Handles& operator=(Handles&&) noexcept = default;

  const ::zx::handle& plain_handle() const { return storage_.plain_handle; }

  ::zx::handle& plain_handle() { return storage_.plain_handle; }

  const ::zx::bti& bti_handle() const { return storage_.bti_handle; }

  ::zx::bti& bti_handle() { return storage_.bti_handle; }

  const ::zx::channel& channel_handle() const {
    return storage_.channel_handle;
  }

  ::zx::channel& channel_handle() { return storage_.channel_handle; }

  const ::zx::clock& clock_handle() const { return storage_.clock_handle; }

  ::zx::clock& clock_handle() { return storage_.clock_handle; }

  const ::zx::debuglog& debuglog_handle() const {
    return storage_.debuglog_handle;
  }

  ::zx::debuglog& debuglog_handle() { return storage_.debuglog_handle; }

  const ::zx::event& event_handle() const { return storage_.event_handle; }

  ::zx::event& event_handle() { return storage_.event_handle; }

  const ::zx::eventpair& eventpair_handle() const {
    return storage_.eventpair_handle;
  }

  ::zx::eventpair& eventpair_handle() { return storage_.eventpair_handle; }

  const ::zx::exception& exception_handle() const {
    return storage_.exception_handle;
  }

  ::zx::exception& exception_handle() { return storage_.exception_handle; }

  const ::zx::fifo& fifo_handle() const { return storage_.fifo_handle; }

  ::zx::fifo& fifo_handle() { return storage_.fifo_handle; }

  const ::zx::guest& guest_handle() const { return storage_.guest_handle; }

  ::zx::guest& guest_handle() { return storage_.guest_handle; }

  const ::zx::interrupt& interrupt_handle() const {
    return storage_.interrupt_handle;
  }

  ::zx::interrupt& interrupt_handle() { return storage_.interrupt_handle; }

  const ::zx::iommu& iommu_handle() const { return storage_.iommu_handle; }

  ::zx::iommu& iommu_handle() { return storage_.iommu_handle; }

  const ::zx::job& job_handle() const { return storage_.job_handle; }

  ::zx::job& job_handle() { return storage_.job_handle; }

  const ::zx::pager& pager_handle() const { return storage_.pager_handle; }

  ::zx::pager& pager_handle() { return storage_.pager_handle; }

  const ::zx::pcidevice& pcidevice_handle() const {
    return storage_.pcidevice_handle;
  }

  ::zx::pcidevice& pcidevice_handle() { return storage_.pcidevice_handle; }

  const ::zx::pmt& pmt_handle() const { return storage_.pmt_handle; }

  ::zx::pmt& pmt_handle() { return storage_.pmt_handle; }

  const ::zx::port& port_handle() const { return storage_.port_handle; }

  ::zx::port& port_handle() { return storage_.port_handle; }

  const ::zx::process& process_handle() const {
    return storage_.process_handle;
  }

  ::zx::process& process_handle() { return storage_.process_handle; }

  const ::zx::profile& profile_handle() const {
    return storage_.profile_handle;
  }

  ::zx::profile& profile_handle() { return storage_.profile_handle; }

  const ::zx::resource& resource_handle() const {
    return storage_.resource_handle;
  }

  ::zx::resource& resource_handle() { return storage_.resource_handle; }

  const ::zx::socket& socket_handle() const { return storage_.socket_handle; }

  ::zx::socket& socket_handle() { return storage_.socket_handle; }

  const ::zx::suspendtoken& suspendtoken_handle() const {
    return storage_.suspendtoken_handle;
  }

  ::zx::suspendtoken& suspendtoken_handle() {
    return storage_.suspendtoken_handle;
  }

  const ::zx::thread& thread_handle() const { return storage_.thread_handle; }

  ::zx::thread& thread_handle() { return storage_.thread_handle; }

  const ::zx::timer& timer_handle() const { return storage_.timer_handle; }

  ::zx::timer& timer_handle() { return storage_.timer_handle; }

  const ::zx::vcpu& vcpu_handle() const { return storage_.vcpu_handle; }

  ::zx::vcpu& vcpu_handle() { return storage_.vcpu_handle; }

  const ::zx::vmar& vmar_handle() const { return storage_.vmar_handle; }

  ::zx::vmar& vmar_handle() { return storage_.vmar_handle; }

  const ::zx::vmo& vmo_handle() const { return storage_.vmo_handle; }

  ::zx::vmo& vmo_handle() { return storage_.vmo_handle; }

  const ::zx::vmo& rights_handle() const { return storage_.rights_handle; }

  ::zx::vmo& rights_handle() { return storage_.rights_handle; }

  const ::zx::handle& aliased_plain_handle_field() const {
    return storage_.aliased_plain_handle_field;
  }

  ::zx::handle& aliased_plain_handle_field() {
    return storage_.aliased_plain_handle_field;
  }

  const ::zx::vmo& aliased_subtype_handle_field() const {
    return storage_.aliased_subtype_handle_field;
  }

  ::zx::vmo& aliased_subtype_handle_field() {
    return storage_.aliased_subtype_handle_field;
  }

  const ::zx::vmo& aliased_rights_handle_field() const {
    return storage_.aliased_rights_handle_field;
  }

  ::zx::vmo& aliased_rights_handle_field() {
    return storage_.aliased_rights_handle_field;
  }

  const ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() const {
    return storage_.some_protocol;
  }

  ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() {
    return storage_.some_protocol;
  }

  const ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol()
      const {
    return storage_.request_some_protocol;
  }

  ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol() {
    return storage_.request_some_protocol;
  }

 private:
  friend ::fidl::internal::CodableBase<Handles>;
  friend ::fidl::CodingTraits<Handles>;
  Handles(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

  struct Storage_ final {
    ::zx::handle plain_handle{};
    ::zx::bti bti_handle{};
    ::zx::channel channel_handle{};
    ::zx::clock clock_handle{};
    ::zx::debuglog debuglog_handle{};
    ::zx::event event_handle{};
    ::zx::eventpair eventpair_handle{};
    ::zx::exception exception_handle{};
    ::zx::fifo fifo_handle{};
    ::zx::guest guest_handle{};
    ::zx::interrupt interrupt_handle{};
    ::zx::iommu iommu_handle{};
    ::zx::job job_handle{};
    ::zx::pager pager_handle{};
    ::zx::pcidevice pcidevice_handle{};
    ::zx::pmt pmt_handle{};
    ::zx::port port_handle{};
    ::zx::process process_handle{};
    ::zx::profile profile_handle{};
    ::zx::resource resource_handle{};
    ::zx::socket socket_handle{};
    ::zx::suspendtoken suspendtoken_handle{};
    ::zx::thread thread_handle{};
    ::zx::timer timer_handle{};
    ::zx::vcpu vcpu_handle{};
    ::zx::vmar vmar_handle{};
    ::zx::vmo vmo_handle{};
    ::zx::vmo rights_handle{};
    ::zx::handle aliased_plain_handle_field{};
    ::zx::vmo aliased_subtype_handle_field{};
    ::zx::vmo aliased_rights_handle_field{};
    ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol{};
    ::fidl::ServerEnd<::test_handles::SomeProtocol> request_some_protocol{};
  };

  Storage_ storage_;
};

#endif  // __Fuchsia__

}  // namespace test_handles
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_handles_HandlesTable;

template <>
struct IsResource<::test_handles::Handles> : public std::true_type {};
template <>
struct IsFidlType<::test_handles::Handles> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_handles::Handles> final {
 public:
  static constexpr const fidl_type_t* kCodingTable = &test_handles_HandlesTable;
};

template <>
struct CodingTraits<::test_handles::Handles> {
  static constexpr size_t inline_size_v1_no_ee = 132;
  static constexpr size_t inline_size_v2 = 132;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_handles::Handles* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.plain_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_NONE,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.bti_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_BTI,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.channel_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 12
                                                                           : 12;
    ::fidl::Encode(encoder, &value->storage_.clock_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CLOCK,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 16
                                                                           : 16;
    ::fidl::Encode(encoder, &value->storage_.debuglog_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_LOG,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 20
                                                                           : 20;
    ::fidl::Encode(encoder, &value->storage_.event_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_EVENT,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 24
                                                                           : 24;
    ::fidl::Encode(encoder, &value->storage_.eventpair_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_EVENTPAIR,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 28
                                                                           : 28;
    ::fidl::Encode(encoder, &value->storage_.exception_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_EXCEPTION,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 32
                                                                           : 32;
    ::fidl::Encode(encoder, &value->storage_.fifo_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_FIFO,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 36
                                                                           : 36;
    ::fidl::Encode(encoder, &value->storage_.guest_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_GUEST,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 40
                                                                           : 40;
    ::fidl::Encode(encoder, &value->storage_.interrupt_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_INTERRUPT,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 44
                                                                           : 44;
    ::fidl::Encode(encoder, &value->storage_.iommu_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_IOMMU,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 48
                                                                           : 48;
    ::fidl::Encode(encoder, &value->storage_.job_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_JOB,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 52
                                                                           : 52;
    ::fidl::Encode(encoder, &value->storage_.pager_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_PAGER,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 56
                                                                           : 56;
    ::fidl::Encode(encoder, &value->storage_.pcidevice_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_PCI_DEVICE,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 60
                                                                           : 60;
    ::fidl::Encode(encoder, &value->storage_.pmt_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_PMT,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 64
                                                                           : 64;
    ::fidl::Encode(encoder, &value->storage_.port_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_PORT,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 68
                                                                           : 68;
    ::fidl::Encode(encoder, &value->storage_.process_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_PROCESS,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 72
                                                                           : 72;
    ::fidl::Encode(encoder, &value->storage_.profile_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_PROFILE,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 76
                                                                           : 76;
    ::fidl::Encode(encoder, &value->storage_.resource_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_RESOURCE,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 80
                                                                           : 80;
    ::fidl::Encode(encoder, &value->storage_.socket_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 84
                                                                           : 84;
    ::fidl::Encode(encoder, &value->storage_.suspendtoken_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SUSPEND_TOKEN,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 88
                                                                           : 88;
    ::fidl::Encode(encoder, &value->storage_.thread_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_THREAD,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 92
                                                                           : 92;
    ::fidl::Encode(encoder, &value->storage_.timer_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_TIMER,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 96
                                                                           : 96;
    ::fidl::Encode(encoder, &value->storage_.vcpu_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_VCPU,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 100
            : 100;
    ::fidl::Encode(encoder, &value->storage_.vmar_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_VMAR,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 104
            : 104;
    ::fidl::Encode(encoder, &value->storage_.vmo_handle, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_VMO,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 108
            : 108;
    ::fidl::Encode(encoder, &value->storage_.rights_handle,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_VMO,
                       .rights = 0x5,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 112
            : 112;
    ::fidl::Encode(encoder, &value->storage_.aliased_plain_handle_field,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_NONE,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 116
            : 116;
    ::fidl::Encode(encoder, &value->storage_.aliased_subtype_handle_field,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_VMO,
                       .rights = 0x80000000,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 120
            : 120;
    ::fidl::Encode(encoder, &value->storage_.aliased_rights_handle_field,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_VMO,
                       .rights = 0x1,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 124
            : 124;
    ::fidl::Encode(encoder, &value->storage_.some_protocol,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1
            ? 128
            : 128;
    ::fidl::Encode(encoder, &value->storage_.request_some_protocol,
                   offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_handles::Handles* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.plain_handle, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.bti_handle, offset + 4);
    ::fidl::Decode(decoder, &value->storage_.channel_handle, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.clock_handle, offset + 12);
    ::fidl::Decode(decoder, &value->storage_.debuglog_handle, offset + 16);
    ::fidl::Decode(decoder, &value->storage_.event_handle, offset + 20);
    ::fidl::Decode(decoder, &value->storage_.eventpair_handle, offset + 24);
    ::fidl::Decode(decoder, &value->storage_.exception_handle, offset + 28);
    ::fidl::Decode(decoder, &value->storage_.fifo_handle, offset + 32);
    ::fidl::Decode(decoder, &value->storage_.guest_handle, offset + 36);
    ::fidl::Decode(decoder, &value->storage_.interrupt_handle, offset + 40);
    ::fidl::Decode(decoder, &value->storage_.iommu_handle, offset + 44);
    ::fidl::Decode(decoder, &value->storage_.job_handle, offset + 48);
    ::fidl::Decode(decoder, &value->storage_.pager_handle, offset + 52);
    ::fidl::Decode(decoder, &value->storage_.pcidevice_handle, offset + 56);
    ::fidl::Decode(decoder, &value->storage_.pmt_handle, offset + 60);
    ::fidl::Decode(decoder, &value->storage_.port_handle, offset + 64);
    ::fidl::Decode(decoder, &value->storage_.process_handle, offset + 68);
    ::fidl::Decode(decoder, &value->storage_.profile_handle, offset + 72);
    ::fidl::Decode(decoder, &value->storage_.resource_handle, offset + 76);
    ::fidl::Decode(decoder, &value->storage_.socket_handle, offset + 80);
    ::fidl::Decode(decoder, &value->storage_.suspendtoken_handle, offset + 84);
    ::fidl::Decode(decoder, &value->storage_.thread_handle, offset + 88);
    ::fidl::Decode(decoder, &value->storage_.timer_handle, offset + 92);
    ::fidl::Decode(decoder, &value->storage_.vcpu_handle, offset + 96);
    ::fidl::Decode(decoder, &value->storage_.vmar_handle, offset + 100);
    ::fidl::Decode(decoder, &value->storage_.vmo_handle, offset + 104);
    ::fidl::Decode(decoder, &value->storage_.rights_handle, offset + 108);
    ::fidl::Decode(decoder, &value->storage_.aliased_plain_handle_field,
                   offset + 112);
    ::fidl::Decode(decoder, &value->storage_.aliased_subtype_handle_field,
                   offset + 116);
    ::fidl::Decode(decoder, &value->storage_.aliased_rights_handle_field,
                   offset + 120);
    ::fidl::Decode(decoder, &value->storage_.some_protocol, offset + 124);
    ::fidl::Decode(decoder, &value->storage_.request_some_protocol,
                   offset + 128);
  }
};
#endif  // __Fuchsia__

template <>
struct CodingTraits<::test_handles::obj_type> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_handles::obj_type* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_handles::obj_type* value,
                     size_t offset) {
    // TODO: decode
  }
};

}  // namespace fidl
