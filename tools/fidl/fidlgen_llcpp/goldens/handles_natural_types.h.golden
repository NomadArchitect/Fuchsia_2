// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.handles/cpp/common_types.h>
#include <fidl/test.handles/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/bti.h>
#include <lib/zx/channel.h>
#include <lib/zx/clock.h>
#include <lib/zx/debuglog.h>
#include <lib/zx/event.h>
#include <lib/zx/eventpair.h>
#include <lib/zx/exception.h>
#include <lib/zx/fifo.h>
#include <lib/zx/guest.h>
#include <lib/zx/handle.h>
#include <lib/zx/interrupt.h>
#include <lib/zx/iommu.h>
#include <lib/zx/job.h>
#include <lib/zx/pager.h>
#include <lib/zx/pmt.h>
#include <lib/zx/port.h>
#include <lib/zx/process.h>
#include <lib/zx/profile.h>
#include <lib/zx/resource.h>
#include <lib/zx/socket.h>
#include <lib/zx/suspend_token.h>
#include <lib/zx/thread.h>
#include <lib/zx/timer.h>
#include <lib/zx/vcpu.h>
#include <lib/zx/vmar.h>
#include <lib/zx/vmo.h>

#endif  // __Fuchsia__

namespace test_handles {
class Handles;

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;

class Handles {
 private:
  struct Storage_;

 public:
  Handles(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  Handles(::zx::handle plain_handle, ::zx::bti bti_handle,
          ::zx::channel channel_handle, ::zx::clock clock_handle,
          ::zx::debuglog debuglog_handle, ::zx::event event_handle,
          ::zx::eventpair eventpair_handle, ::zx::exception exception_handle,
          ::zx::fifo fifo_handle, ::zx::guest guest_handle,
          ::zx::interrupt interrupt_handle, ::zx::iommu iommu_handle,
          ::zx::job job_handle, ::zx::pager pager_handle, ::zx::pmt pmt_handle,
          ::zx::port port_handle, ::zx::process process_handle,
          ::zx::profile profile_handle, ::zx::resource resource_handle,
          ::zx::socket socket_handle, ::zx::suspend_token suspendtoken_handle,
          ::zx::thread thread_handle, ::zx::timer timer_handle,
          ::zx::vcpu vcpu_handle, ::zx::vmar vmar_handle, ::zx::vmo vmo_handle,
          ::zx::vmo rights_handle, ::zx::handle aliased_plain_handle_field,
          ::zx::vmo aliased_subtype_handle_field,
          ::zx::vmo aliased_rights_handle_field,
          ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol,
          ::fidl::ServerEnd<::test_handles::SomeProtocol>
              request_some_protocol) noexcept
      : storage_({.plain_handle = std::move(plain_handle),
                  .bti_handle = std::move(bti_handle),
                  .channel_handle = std::move(channel_handle),
                  .clock_handle = std::move(clock_handle),
                  .debuglog_handle = std::move(debuglog_handle),
                  .event_handle = std::move(event_handle),
                  .eventpair_handle = std::move(eventpair_handle),
                  .exception_handle = std::move(exception_handle),
                  .fifo_handle = std::move(fifo_handle),
                  .guest_handle = std::move(guest_handle),
                  .interrupt_handle = std::move(interrupt_handle),
                  .iommu_handle = std::move(iommu_handle),
                  .job_handle = std::move(job_handle),
                  .pager_handle = std::move(pager_handle),
                  .pmt_handle = std::move(pmt_handle),
                  .port_handle = std::move(port_handle),
                  .process_handle = std::move(process_handle),
                  .profile_handle = std::move(profile_handle),
                  .resource_handle = std::move(resource_handle),
                  .socket_handle = std::move(socket_handle),
                  .suspendtoken_handle = std::move(suspendtoken_handle),
                  .thread_handle = std::move(thread_handle),
                  .timer_handle = std::move(timer_handle),
                  .vcpu_handle = std::move(vcpu_handle),
                  .vmar_handle = std::move(vmar_handle),
                  .vmo_handle = std::move(vmo_handle),
                  .rights_handle = std::move(rights_handle),
                  .aliased_plain_handle_field =
                      std::move(aliased_plain_handle_field),
                  .aliased_subtype_handle_field =
                      std::move(aliased_subtype_handle_field),
                  .aliased_rights_handle_field =
                      std::move(aliased_rights_handle_field),
                  .some_protocol = std::move(some_protocol),
                  .request_some_protocol = std::move(request_some_protocol)}) {}
  Handles() : Handles(Storage_{}) {}

  Handles(Handles&&) noexcept = default;
  Handles& operator=(Handles&&) noexcept = default;

  const ::zx::handle& plain_handle() const { return storage_.plain_handle; }

  ::zx::handle& plain_handle() { return storage_.plain_handle; }

  const ::zx::bti& bti_handle() const { return storage_.bti_handle; }

  ::zx::bti& bti_handle() { return storage_.bti_handle; }

  const ::zx::channel& channel_handle() const {
    return storage_.channel_handle;
  }

  ::zx::channel& channel_handle() { return storage_.channel_handle; }

  const ::zx::clock& clock_handle() const { return storage_.clock_handle; }

  ::zx::clock& clock_handle() { return storage_.clock_handle; }

  const ::zx::debuglog& debuglog_handle() const {
    return storage_.debuglog_handle;
  }

  ::zx::debuglog& debuglog_handle() { return storage_.debuglog_handle; }

  const ::zx::event& event_handle() const { return storage_.event_handle; }

  ::zx::event& event_handle() { return storage_.event_handle; }

  const ::zx::eventpair& eventpair_handle() const {
    return storage_.eventpair_handle;
  }

  ::zx::eventpair& eventpair_handle() { return storage_.eventpair_handle; }

  const ::zx::exception& exception_handle() const {
    return storage_.exception_handle;
  }

  ::zx::exception& exception_handle() { return storage_.exception_handle; }

  const ::zx::fifo& fifo_handle() const { return storage_.fifo_handle; }

  ::zx::fifo& fifo_handle() { return storage_.fifo_handle; }

  const ::zx::guest& guest_handle() const { return storage_.guest_handle; }

  ::zx::guest& guest_handle() { return storage_.guest_handle; }

  const ::zx::interrupt& interrupt_handle() const {
    return storage_.interrupt_handle;
  }

  ::zx::interrupt& interrupt_handle() { return storage_.interrupt_handle; }

  const ::zx::iommu& iommu_handle() const { return storage_.iommu_handle; }

  ::zx::iommu& iommu_handle() { return storage_.iommu_handle; }

  const ::zx::job& job_handle() const { return storage_.job_handle; }

  ::zx::job& job_handle() { return storage_.job_handle; }

  const ::zx::pager& pager_handle() const { return storage_.pager_handle; }

  ::zx::pager& pager_handle() { return storage_.pager_handle; }

  const ::zx::pmt& pmt_handle() const { return storage_.pmt_handle; }

  ::zx::pmt& pmt_handle() { return storage_.pmt_handle; }

  const ::zx::port& port_handle() const { return storage_.port_handle; }

  ::zx::port& port_handle() { return storage_.port_handle; }

  const ::zx::process& process_handle() const {
    return storage_.process_handle;
  }

  ::zx::process& process_handle() { return storage_.process_handle; }

  const ::zx::profile& profile_handle() const {
    return storage_.profile_handle;
  }

  ::zx::profile& profile_handle() { return storage_.profile_handle; }

  const ::zx::resource& resource_handle() const {
    return storage_.resource_handle;
  }

  ::zx::resource& resource_handle() { return storage_.resource_handle; }

  const ::zx::socket& socket_handle() const { return storage_.socket_handle; }

  ::zx::socket& socket_handle() { return storage_.socket_handle; }

  const ::zx::suspend_token& suspendtoken_handle() const {
    return storage_.suspendtoken_handle;
  }

  ::zx::suspend_token& suspendtoken_handle() {
    return storage_.suspendtoken_handle;
  }

  const ::zx::thread& thread_handle() const { return storage_.thread_handle; }

  ::zx::thread& thread_handle() { return storage_.thread_handle; }

  const ::zx::timer& timer_handle() const { return storage_.timer_handle; }

  ::zx::timer& timer_handle() { return storage_.timer_handle; }

  const ::zx::vcpu& vcpu_handle() const { return storage_.vcpu_handle; }

  ::zx::vcpu& vcpu_handle() { return storage_.vcpu_handle; }

  const ::zx::vmar& vmar_handle() const { return storage_.vmar_handle; }

  ::zx::vmar& vmar_handle() { return storage_.vmar_handle; }

  const ::zx::vmo& vmo_handle() const { return storage_.vmo_handle; }

  ::zx::vmo& vmo_handle() { return storage_.vmo_handle; }

  const ::zx::vmo& rights_handle() const { return storage_.rights_handle; }

  ::zx::vmo& rights_handle() { return storage_.rights_handle; }

  const ::zx::handle& aliased_plain_handle_field() const {
    return storage_.aliased_plain_handle_field;
  }

  ::zx::handle& aliased_plain_handle_field() {
    return storage_.aliased_plain_handle_field;
  }

  const ::zx::vmo& aliased_subtype_handle_field() const {
    return storage_.aliased_subtype_handle_field;
  }

  ::zx::vmo& aliased_subtype_handle_field() {
    return storage_.aliased_subtype_handle_field;
  }

  const ::zx::vmo& aliased_rights_handle_field() const {
    return storage_.aliased_rights_handle_field;
  }

  ::zx::vmo& aliased_rights_handle_field() {
    return storage_.aliased_rights_handle_field;
  }

  const ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() const {
    return storage_.some_protocol;
  }

  ::fidl::ClientEnd<::test_handles::SomeProtocol>& some_protocol() {
    return storage_.some_protocol;
  }

  const ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol()
      const {
    return storage_.request_some_protocol;
  }

  ::fidl::ServerEnd<::test_handles::SomeProtocol>& request_some_protocol() {
    return storage_.request_some_protocol;
  }

 private:
  struct Storage_ final {
    ::zx::handle plain_handle{};
    ::zx::bti bti_handle{};
    ::zx::channel channel_handle{};
    ::zx::clock clock_handle{};
    ::zx::debuglog debuglog_handle{};
    ::zx::event event_handle{};
    ::zx::eventpair eventpair_handle{};
    ::zx::exception exception_handle{};
    ::zx::fifo fifo_handle{};
    ::zx::guest guest_handle{};
    ::zx::interrupt interrupt_handle{};
    ::zx::iommu iommu_handle{};
    ::zx::job job_handle{};
    ::zx::pager pager_handle{};
    ::zx::pmt pmt_handle{};
    ::zx::port port_handle{};
    ::zx::process process_handle{};
    ::zx::profile profile_handle{};
    ::zx::resource resource_handle{};
    ::zx::socket socket_handle{};
    ::zx::suspend_token suspendtoken_handle{};
    ::zx::thread thread_handle{};
    ::zx::timer timer_handle{};
    ::zx::vcpu vcpu_handle{};
    ::zx::vmar vmar_handle{};
    ::zx::vmo vmo_handle{};
    ::zx::vmo rights_handle{};
    ::zx::handle aliased_plain_handle_field{};
    ::zx::vmo aliased_subtype_handle_field{};
    ::zx::vmo aliased_rights_handle_field{};
    ::fidl::ClientEnd<::test_handles::SomeProtocol> some_protocol{};
    ::fidl::ServerEnd<::test_handles::SomeProtocol> request_some_protocol{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_handles::Handles, 128, 128>;
  friend struct ::fidl::internal::MemberVisitor<::test_handles::Handles>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::handle,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE,
                                                        0x80000000, false>>{
          &Storage_::plain_handle, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::bti,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_BTI,
                                                        0x80000000, false>>{
          &Storage_::bti_handle, 4, 4},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::channel,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CHANNEL,
                                                        0x80000000, false>>{
          &Storage_::channel_handle, 8, 8},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::clock,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_CLOCK,
                                                        0x80000000, false>>{
          &Storage_::clock_handle, 12, 12},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::debuglog,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_LOG,
                                                        0x80000000, false>>{
          &Storage_::debuglog_handle, 16, 16},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::event,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_EVENT,
                                                        0x80000000, false>>{
          &Storage_::event_handle, 20, 20},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::eventpair,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_EVENTPAIR,
                                                        0x80000000, false>>{
          &Storage_::eventpair_handle, 24, 24},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::exception,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_EXCEPTION,
                                                        0x80000000, false>>{
          &Storage_::exception_handle, 28, 28},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::fifo,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_FIFO,
                                                        0x80000000, false>>{
          &Storage_::fifo_handle, 32, 32},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::guest,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_GUEST,
                                                        0x80000000, false>>{
          &Storage_::guest_handle, 36, 36},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::interrupt,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_INTERRUPT,
                                                        0x80000000, false>>{
          &Storage_::interrupt_handle, 40, 40},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::iommu,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_IOMMU,
                                                        0x80000000, false>>{
          &Storage_::iommu_handle, 44, 44},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::job,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_JOB,
                                                        0x80000000, false>>{
          &Storage_::job_handle, 48, 48},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::pager,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PAGER,
                                                        0x80000000, false>>{
          &Storage_::pager_handle, 52, 52},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::pmt,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PMT,
                                                        0x80000000, false>>{
          &Storage_::pmt_handle, 56, 56},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::port,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PORT,
                                                        0x80000000, false>>{
          &Storage_::port_handle, 60, 60},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::process,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PROCESS,
                                                        0x80000000, false>>{
          &Storage_::process_handle, 64, 64},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::profile,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_PROFILE,
                                                        0x80000000, false>>{
          &Storage_::profile_handle, 68, 68},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::resource,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_RESOURCE,
                                                        0x80000000, false>>{
          &Storage_::resource_handle, 72, 72},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::socket,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET,
                                                        0x80000000, false>>{
          &Storage_::socket_handle, 76, 76},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::suspend_token,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_SUSPEND_TOKEN, 0x80000000, false>>{
          &Storage_::suspendtoken_handle, 80, 80},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::thread,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_THREAD,
                                                        0x80000000, false>>{
          &Storage_::thread_handle, 84, 84},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::timer,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_TIMER,
                                                        0x80000000, false>>{
          &Storage_::timer_handle, 88, 88},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::vcpu,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VCPU,
                                                        0x80000000, false>>{
          &Storage_::vcpu_handle, 92, 92},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::vmar,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMAR,
                                                        0x80000000, false>>{
          &Storage_::vmar_handle, 96, 96},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::vmo,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO,
                                                        0x80000000, false>>{
          &Storage_::vmo_handle, 100, 100},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::vmo,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x5,
                                                        false>>{
          &Storage_::rights_handle, 104, 104},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::handle,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE,
                                                        0x80000000, false>>{
          &Storage_::aliased_plain_handle_field, 108, 108},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::vmo,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO,
                                                        0x80000000, false>>{
          &Storage_::aliased_subtype_handle_field, 112, 112},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::vmo,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_VMO, 0x1,
                                                        false>>{
          &Storage_::aliased_rights_handle_field, 116, 116},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ClientEnd<::test_handles::SomeProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
          &Storage_::some_protocol, 120, 120},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ServerEnd<::test_handles::SomeProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
          &Storage_::request_some_protocol, 124, 124});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

}  // namespace test_handles
namespace fidl {

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_handles_HandlesTable;

template <>
struct IsResource<::test_handles::Handles> : public std::true_type {};
template <>
struct IsFidlType<::test_handles::Handles> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_handles::Handles> final {
 public:
  static constexpr const fidl_type_t* kCodingTable = &test_handles_HandlesTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_handles::Handles, ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_handles::Handles, 128, 128> {};

template <>
struct internal::NaturalIsMemcpyCompatible<::test_handles::Handles>
    : public std::bool_constant<
          !internal::NaturalHasPadding<::test_handles::Handles>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::handle>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::bti>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::channel>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::clock>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::debuglog>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::event>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::eventpair>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::exception>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::fifo>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::guest>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::interrupt>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::iommu>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::job>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::pager>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::pmt>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::port>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::process>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::profile>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::resource>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::socket>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::suspend_token>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::thread>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::timer>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::vcpu>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::vmar>::value &&
          internal::NaturalIsMemcpyCompatible<::zx::vmo>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::fidl::ClientEnd<::test_handles::SomeProtocol>>::value &&
          internal::NaturalIsMemcpyCompatible<
              ::fidl::ServerEnd<::test_handles::SomeProtocol>>::value> {};

#endif  // __Fuchsia__

template <>
struct internal::NaturalCodingTraits<
    ::test_handles::obj_type, ::fidl::internal::NaturalCodingConstraintEmpty> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  static void Encode(internal::NaturalEncoder* encoder,
                     ::test_handles::obj_type* value, size_t offset,
                     size_t recursion_depth) {
    switch (*value) {
      case ::test_handles::obj_type::kNone:
      case ::test_handles::obj_type::kProcess:
      case ::test_handles::obj_type::kThread:
      case ::test_handles::obj_type::kVmo:
      case ::test_handles::obj_type::kChannel:
      case ::test_handles::obj_type::kEvent:
      case ::test_handles::obj_type::kPort:
      case ::test_handles::obj_type::kInterrupt:
      case ::test_handles::obj_type::kLog:
      case ::test_handles::obj_type::kSocket:
      case ::test_handles::obj_type::kResource:
      case ::test_handles::obj_type::kEventpair:
      case ::test_handles::obj_type::kJob:
      case ::test_handles::obj_type::kVmar:
      case ::test_handles::obj_type::kFifo:
      case ::test_handles::obj_type::kGuest:
      case ::test_handles::obj_type::kVcpu:
      case ::test_handles::obj_type::kTimer:
      case ::test_handles::obj_type::kIommu:
      case ::test_handles::obj_type::kBti:
      case ::test_handles::obj_type::kProfile:
      case ::test_handles::obj_type::kPmt:
      case ::test_handles::obj_type::kSuspendToken:
      case ::test_handles::obj_type::kPager:
      case ::test_handles::obj_type::kException:
      case ::test_handles::obj_type::kClock:
      case ::test_handles::obj_type::kStream:
      case ::test_handles::obj_type::kMsi:
        break;
      default:
        encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
    *encoder->template GetPtr<::test_handles::obj_type>(offset) = *value;
  }
  static void Decode(internal::NaturalDecoder* decoder,
                     ::test_handles::obj_type* value, size_t offset,
                     size_t recursion_depth) {
    *value = *decoder->template GetPtr<::test_handles::obj_type>(offset);
    switch (*value) {
      case ::test_handles::obj_type::kNone:
      case ::test_handles::obj_type::kProcess:
      case ::test_handles::obj_type::kThread:
      case ::test_handles::obj_type::kVmo:
      case ::test_handles::obj_type::kChannel:
      case ::test_handles::obj_type::kEvent:
      case ::test_handles::obj_type::kPort:
      case ::test_handles::obj_type::kInterrupt:
      case ::test_handles::obj_type::kLog:
      case ::test_handles::obj_type::kSocket:
      case ::test_handles::obj_type::kResource:
      case ::test_handles::obj_type::kEventpair:
      case ::test_handles::obj_type::kJob:
      case ::test_handles::obj_type::kVmar:
      case ::test_handles::obj_type::kFifo:
      case ::test_handles::obj_type::kGuest:
      case ::test_handles::obj_type::kVcpu:
      case ::test_handles::obj_type::kTimer:
      case ::test_handles::obj_type::kIommu:
      case ::test_handles::obj_type::kBti:
      case ::test_handles::obj_type::kProfile:
      case ::test_handles::obj_type::kPmt:
      case ::test_handles::obj_type::kSuspendToken:
      case ::test_handles::obj_type::kPager:
      case ::test_handles::obj_type::kException:
      case ::test_handles::obj_type::kClock:
      case ::test_handles::obj_type::kStream:
      case ::test_handles::obj_type::kMsi:
        break;
      default:
        decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
  }
};

}  // namespace fidl
