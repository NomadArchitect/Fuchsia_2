// WARNING: This file is machine generated by fidlgen_llcpp.

#include <fidl/test.protocols/cpp/natural_messaging.h>

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;

[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;

[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>
            request,
        ::fidl::ClientCallback<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<::fidl::Request<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>(
          ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(
        ::fidl::Request<
            ::test_protocols::HandleRightsProtocol::NoResponseMethod>
            request) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal};
  ::fidl::Status status =
      messenger().OneWay(::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<::fidl::Request<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>>::
              IntoDomainObject(std::move(request))));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::HandleRightsProtocolAnEventRequest>(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> event =
            ::fidl::internal::NaturalMessageConverter<::fidl::Event<
                ::test_protocols::HandleRightsProtocol::AnEvent>>::
                FromDomainObject(std::move(decoded.value()));
        event_handler()->AnEvent(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(
        ::test_protocols::HandleRightsProtocolAnEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  ::fidl::Status result = _inner().SendEvent(encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(
        ::test_protocols::HandleRightsProtocolAnEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::fidl::Response<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<::fidl::Response<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>>::
              IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_[] = {
    {
        ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>
              request = ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::HandleRightsProtocol::
                                      NoResponseMethod>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->NoResponseMethod(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::HandleRightsProtocolResponseMethodRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::HandleRightsProtocol::ResponseMethod>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->ResponseMethod(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_end_ = &entries_[2];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestEmptyResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestEmptyResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    NoRequestWithResponse(
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestWithResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>
            request,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestEmptyResponse>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestEmptyResponse>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>
            request,
        ::fidl::ClientCallback<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>&& _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestWithResponse>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>(
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse()
    const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal};
  ::fidl::Status status = messenger().OneWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder));
  return ::fidl::internal::ToFitxResult(status);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(
        ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>
            request) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal};
  ::fidl::Status status =
      messenger().OneWay(::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                                  WithRequestNoResponse>>::
              IntoDomainObject(std::move(request))));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fitx::result decoded =
          ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
            event;
        event_handler()->OnEmptyResponse(event);
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>(
          std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
            event = ::fidl::internal::NaturalMessageConverter<::fidl::Event<
                ::test_protocols::WithAndWithoutRequestResponse::
                    OnWithResponse>>::FromDomainObject(std::move(decoded
                                                                     .value()));
        event_handler()->OnWithResponse(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(_encoder);
  ::fidl::Status result = _inner().SendEvent(encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(_encoder);
  encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{encoded_message});
}

::fitx::result<::fidl::Error> fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnWithResponse_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  ::fidl::Status result = _inner().SendEvent(encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::
                   kWithAndWithoutRequestResponse_OnWithResponse_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  _messenger.SendReply(::fidl::internal::EncodeTransactionalMessage(_encoder),
                       ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>&& response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                                   NoRequestWithResponse>>::
              IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  _messenger.SendReply(::fidl::internal::EncodeTransactionalMessage(_encoder),
                       ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>&& response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::
              kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                                   WithRequestWithResponse>>::
              IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestNoResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestNoResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestEmptyResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestWithResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::
                  WithAndWithoutRequestResponseWithRequestNoResponseRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestNoResponse>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestNoResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestNoResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::
                  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestEmptyResponse>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestEmptyResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::
                  WithAndWithoutRequestResponseWithRequestWithResponseRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestWithResponse>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestWithResponse(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

void fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    Dispatch(
        ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithAndWithoutRequestResponse>::
    dispatch_message(
        ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
        ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithAndWithoutRequestResponse>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;

[[maybe_unused]] constexpr inline uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;

[[maybe_unused]] constexpr inline uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::fidl::Request<::test_protocols::Transitional::Request> request,
    ::fidl::ClientCallback<::test_protocols::Transitional::Request>&& _callback)
    const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Request_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::Transitional::Request>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::Transitional::Request>(
          ::test_protocols::kTransitional_Request_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::OneWay(
    ::fidl::Request<::test_protocols::Transitional::OneWay> request) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_OneWay_Ordinal};
  ::fidl::Status status =
      messenger().OneWay(::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::Transitional::OneWay>>::
              IntoDomainObject(std::move(request))));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::TransitionalEventRequest>(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<::test_protocols::Transitional::Event> event =
            ::fidl::internal::NaturalMessageConverter<
                ::fidl::Event<::test_protocols::Transitional::Event>>::
                FromDomainObject(std::move(decoded.value()));
        event_handler()->Event(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional>::Event(
    ::test_protocols::TransitionalEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Event_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  ::fidl::Status result = _inner().SendEvent(encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocols::Transitional>::Event(
    ::test_protocols::TransitionalEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Event_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::Transitional::Request>::Reply(
        ::fidl::Response<::test_protocols::Transitional::Request>&& response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kTransitional_Request_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Response<::test_protocols::Transitional::Request>>::
              IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::Transitional>::entries_[] = {
    {
        ::test_protocols::kTransitional_Request_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::TransitionalRequestRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::Transitional::Request> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::Transitional::Request>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::Transitional::Request>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::Transitional>*>(
              interface)
              ->Request(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kTransitional_OneWay_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::TransitionalOneWayRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::Transitional::OneWay> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::Transitional::OneWay>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::Transitional::OneWay>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::Transitional>*>(
              interface)
              ->OneWay(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::Transitional>::entries_end_ = &entries_[2];

void fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional>::
    Dispatch(::fidl::Server<::test_protocols::Transitional>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::Transitional>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::Transitional>::Dispatch(this, std::move(msg),
                                                std::move(transport_context),
                                                txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod> request)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kMethodWithUnion_UnionMethod_Ordinal};
  ::fidl::Status status =
      messenger().OneWay(::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>>::
              IntoDomainObject(std::move(request))));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_[] = {
    {
        ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::MethodWithUnionUnionMethodRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::MethodWithUnion::UnionMethod>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::MethodWithUnion::UnionMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::MethodWithUnion>*>(
              interface)
              ->UnionMethod(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_end_ = &entries_[1];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(
        ::fidl::Server<::test_protocols::MethodWithUnion>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(
        ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds> request,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ClientEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithProtocolEnds::ClientEnds>(
          ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(
        ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds> request,
        ::fidl::ClientCallback<::test_protocols::WithProtocolEnds::ServerEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithProtocolEnds::ServerEnds>(
          ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::fidl::Request<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>
            request,
        ::fidl::ClientCallback<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<::fidl::Request<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>(
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
          std::move(_callback)));
}

namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(
        ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>&&
            response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::WithProtocolEnds::ClientEnds>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(
        ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>&&
            response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::WithProtocolEnds::ServerEnds>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::fidl::Response<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
              response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{
          ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<::fidl::Response<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>>::
              IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_[] = {
    {
        ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::WithProtocolEndsClientEndsRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithProtocolEnds::ClientEnds>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::ClientEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ClientEnds(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::WithProtocolEndsServerEndsRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithProtocolEnds::ServerEnds>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::ServerEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ServerEnds(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::WithProtocolEndsStructContainingEndsRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>
              request = ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::WithProtocolEnds::
                                      StructContainingEnds>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->StructContainingEnds(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_end_ = &entries_[3];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(
        ::fidl::Server<::test_protocols::WithProtocolEnds>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithProtocolEnds>::Dispatch(this, std::move(msg),
                                                    std::move(
                                                        transport_context),
                                                    txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>::Fifteen(
    ::fidl::Request<::test_protocols::ManyParameters::Fifteen> request) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kManyParameters_Fifteen_Ordinal};
  ::fidl::Status status =
      messenger().OneWay(::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>::
              IntoDomainObject(std::move(request))));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>::entries_[] = {
    {
        ::test_protocols::kManyParameters_Fifteen_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ManyParametersFifteenRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ManyParameters::Fifteen> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ManyParameters>*>(
              interface)
              ->Fifteen(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>::entries_end_ = &entries_[1];

void fidl::internal::NaturalServerDispatcher<::test_protocols::ManyParameters>::
    Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::ManyParameters>::Dispatch(this, std::move(msg),
                                                  std::move(transport_context),
                                                  txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ResponseAsStruct(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
                         _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>(
          ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsPrimitive(::fidl::ClientCallback<
                     ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
                         _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
          ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    ErrorAsEnum(
        ::fidl::ClientCallback<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>(
          ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::WithErrorSyntax>::
    HandleInResult(::fidl::ClientCallback<
                   ::test_protocols::WithErrorSyntax::HandleInResult>&&
                       _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::WithErrorSyntax::HandleInResult>(
          ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
          std::move(_callback)));
}

namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(
        ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
            response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::WithErrorSyntax::ResponseAsStruct>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(
        ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
            response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(
        ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
            response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::WithErrorSyntax::ErrorAsEnum>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    Reply(::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>&&
              response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::WithErrorSyntax::HandleInResult>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_[] = {
    {
        ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ResponseAsStruct(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ErrorAsPrimitive(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ErrorAsEnum(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::HandleInResult>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->HandleInResult(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_end_ = &entries_[4];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(
        ::fidl::Server<::test_protocols::WithErrorSyntax>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kDiscoverableProtocol_Method_Ordinal};
  ::fidl::Status status = messenger().OneWay(
      ::fidl::internal::EncodeTransactionalMessage(_encoder));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_[] = {
    {
        ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::DiscoverableProtocol::Method>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::DiscoverableProtocol>*>(
              interface)
              ->Method(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_end_ = &entries_[1];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;

[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;

[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;

[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;

[[maybe_unused]] constexpr inline uint64_t
    kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MethodB(::fidl::Request<::test_protocols::ChannelProtocol::MethodB> request,
            ::fidl::ClientCallback<::test_protocols::ChannelProtocol::MethodB>&&
                _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::ChannelProtocol::MethodB>(
          ::test_protocols::kChannelProtocol_MethodB_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(
        ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle> request,
        ::fidl::ClientCallback<::test_protocols::ChannelProtocol::TakeHandle>&&
            _callback) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>>::
              IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::ChannelProtocol::TakeHandle>(
          ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
          std::move(_callback)));
}

void fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(
        ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>
            request,
        ::fidl::ClientCallback<
            ::test_protocols::ChannelProtocol::MutateSocket>&& _callback)
        const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  return messenger().TwoWay(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                        ::test_protocols::ChannelProtocol::MutateSocket>>::
                        IntoDomainObject(std::move(request))),
      ::fidl::internal::MakeResponseContext<
          ::test_protocols::ChannelProtocol::MutateSocket>(
          ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
          std::move(_callback)));
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::MethodA(
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> request) const {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodA_Ordinal};
  ::fidl::Status status =
      messenger().OneWay(::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>::
              IntoDomainObject(std::move(request))));
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::ChannelProtocolEventARequest>(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<::test_protocols::ChannelProtocol::EventA> event =
            ::fidl::internal::NaturalMessageConverter<
                ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>::
                FromDomainObject(std::move(decoded.value()));
        event_handler()->EventA(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocols::ChannelProtocol>::EventA(
        ::test_protocols::ChannelProtocolEventARequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_EventA_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  ::fidl::Status result = _inner().SendEvent(encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>::EventA(
    ::test_protocols::ChannelProtocolEventARequest payload) {
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_EventA_Ordinal};
  auto encoded_message = ::fidl::internal::EncodeTransactionalMessage(
      _encoder, std::move(payload));
  encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB>::Reply(
        ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>&&
            response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MethodB_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder,
          ::fidl::internal::NaturalMessageConverter<
              ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>::
              IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  _messenger.SendReply(::fidl::internal::EncodeTransactionalMessage(_encoder),
                       ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MutateSocket>::
    Reply(::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>&&
              response) {
  ::fidl::internal::NaturalServerMessenger _messenger{this};
  ::fidl::internal::NaturalMessageEncoder<::fidl::internal::ChannelTransport>
      _encoder{::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  _messenger.SendReply(
      ::fidl::internal::EncodeTransactionalMessage(
          _encoder, ::fidl::internal::NaturalMessageConverter<::fidl::Response<
                        ::test_protocols::ChannelProtocol::MutateSocket>>::
                        IntoDomainObject(std::move(response))),
      ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_[] = {
    {
        ::test_protocols::kChannelProtocol_MethodA_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolMethodARequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MethodA(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MethodB_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolMethodBRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MethodB(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolTakeHandleRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::ChannelProtocol::TakeHandle>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::TakeHandle>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->TakeHandle(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolMutateSocketRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::ChannelProtocol::MutateSocket>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MutateSocket>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MutateSocket(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_end_ = &entries_[4];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::ChannelProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__
