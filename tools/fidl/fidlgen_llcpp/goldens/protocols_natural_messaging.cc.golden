// WARNING: This file is machine generated by fidlgen_llcpp.

#include <fidl/test.protocols/cpp/natural_messaging.h>

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::internal::NaturalThenable<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse()
    const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse()
    const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(
        ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestEmptyResponse>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Request<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>::IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(
        ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestWithResponse>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Request<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>::IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse()
    const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(
        ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                            WithRequestNoResponse>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Request<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>>::IntoDomainObject(std::move(request)));

  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::NaturalEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fitx::result decoded =
          ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
            event;
        event_handler()->OnEmptyResponse(event);
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>(
          std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
            event = ::fidl::internal::NaturalMessageConverter<::fidl::Event<
                ::test_protocols::WithAndWithoutRequestResponse::
                    OnWithResponse>>::FromDomainObject(std::move(decoded
                                                                     .value()));
        event_handler()->OnWithResponse(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status result = _inner().SendEvent(_encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  _encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{_encoded_message});
}

::fitx::result<::fidl::Error> fidl::internal::NaturalWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status result = _inner().SendEvent(_encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::NaturalEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest
            payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  _encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{_encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               NoRequestWithResponse>&& response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Response<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>::IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::fidl::Response<::test_protocols::WithAndWithoutRequestResponse::
                               WithRequestWithResponse>&& response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Response<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>::IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestNoResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestNoResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestEmptyResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->NoRequestWithResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::
                  WithAndWithoutRequestResponseWithRequestNoResponseRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestNoResponse>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestNoResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestNoResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::
                  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestEmptyResponse>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestEmptyResponse(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::
                  WithAndWithoutRequestResponseWithRequestWithResponseRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithAndWithoutRequestResponse::
                          WithRequestWithResponse>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>::Sync completer(txn);
          static_cast<
              ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>*>(
              interface)
              ->WithRequestWithResponse(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

void fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    Dispatch(
        ::fidl::Server<::test_protocols::WithAndWithoutRequestResponse>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithAndWithoutRequestResponse>::
    dispatch_message(
        ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
        ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithAndWithoutRequestResponse>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;

[[maybe_unused]] constexpr inline uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;

[[maybe_unused]] constexpr inline uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::internal::NaturalThenable<::test_protocols::Transitional::Request>
fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::Request(
    ::fidl::Request<::test_protocols::Transitional::Request> request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kTransitional_Request_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::Transitional::Request>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::Transitional::Request>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::Transitional>::OneWay(
    ::fidl::Request<::test_protocols::Transitional::OneWay> request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kTransitional_OneWay_Ordinal};
  _encoder.EncodeBody(::fidl::internal::NaturalMessageConverter<
                      ::fidl::Request<::test_protocols::Transitional::OneWay>>::
                          IntoDomainObject(std::move(request)));

  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::TransitionalEventRequest>(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<::test_protocols::Transitional::Event> event =
            ::fidl::internal::NaturalMessageConverter<
                ::fidl::Event<::test_protocols::Transitional::Event>>::
                FromDomainObject(std::move(decoded.value()));
        event_handler()->Event(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error>
fidl::internal::NaturalWeakEventSender<::test_protocols::Transitional>::Event(
    ::test_protocols::TransitionalEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kTransitional_Event_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status result = _inner().SendEvent(_encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocols::Transitional>::Event(
    ::test_protocols::TransitionalEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kTransitional_Event_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  _encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{_encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::Transitional::Request>::Reply(
        ::fidl::Response<::test_protocols::Transitional::Request>&& response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kTransitional_Request_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::Transitional::Request>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::Transitional>::entries_[] = {
    {
        ::test_protocols::kTransitional_Request_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::TransitionalRequestRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::Transitional::Request> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::Transitional::Request>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::Transitional::Request>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::Transitional>*>(
              interface)
              ->Request(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kTransitional_OneWay_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::TransitionalOneWayRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::Transitional::OneWay> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::Transitional::OneWay>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::Transitional::OneWay>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::Transitional>*>(
              interface)
              ->OneWay(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::Transitional>::entries_end_ = &entries_[2];

void fidl::internal::NaturalServerDispatcher<::test_protocols::Transitional>::
    Dispatch(::fidl::Server<::test_protocols::Transitional>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::Transitional>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::Transitional>::Dispatch(this, std::move(msg),
                                                std::move(transport_context),
                                                txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kMethodWithUnion_UnionMethod_Ordinal = 4124874338266649112lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod> request)
        const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>>::
          IntoDomainObject(std::move(request)));

  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_[] = {
    {
        ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::MethodWithUnionUnionMethodRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::MethodWithUnion::UnionMethod>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::MethodWithUnion::UnionMethod>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::MethodWithUnion::UnionMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::MethodWithUnion>*>(
              interface)
              ->UnionMethod(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_end_ = &entries_[1];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::MethodWithUnion>::Dispatch(
        ::fidl::Server<::test_protocols::MethodWithUnion>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ClientEnds_Ordinal = 5870448041025163330lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_ServerEnds_Ordinal = 8115535094437022259lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::internal::NaturalThenable<
    ::test_protocols::WithProtocolEnds::ClientEnds>
fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>
                   request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithProtocolEnds::ClientEnds>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithProtocolEnds::ServerEnds>
fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>
                   request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithProtocolEnds::ServerEnds>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
fidl::internal::NaturalClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(
        ::fidl::Request<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Request<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(
        ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>&&
            response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ClientEnds>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(
        ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>&&
            response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::WithProtocolEnds::ServerEnds>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::fidl::Response<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>&&
              response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Response<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_[] = {
    {
        ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::WithProtocolEndsClientEndsRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithProtocolEnds::ClientEnds>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithProtocolEnds::ClientEnds>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::ClientEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ClientEnds(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::WithProtocolEndsServerEndsRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithProtocolEnds::ServerEnds>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::WithProtocolEnds::ServerEnds>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::ServerEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ServerEnds(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::WithProtocolEndsStructContainingEndsRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>
              request = ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::WithProtocolEnds::
                                      StructContainingEnds>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->StructContainingEnds(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_end_ = &entries_[3];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::WithProtocolEnds>::Dispatch(
        ::fidl::Server<::test_protocols::WithProtocolEnds>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithProtocolEnds>::Dispatch(this, std::move(msg),
                                                    std::move(
                                                        transport_context),
                                                    txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ManyParameters>::Fifteen(
    ::fidl::Request<::test_protocols::ManyParameters::Fifteen> request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kManyParameters_Fifteen_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>::
          IntoDomainObject(std::move(request)));

  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>::entries_[] = {
    {
        ::test_protocols::kManyParameters_Fifteen_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ManyParametersFifteenRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ManyParameters::Fifteen> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::ManyParameters::Fifteen>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ManyParameters>*>(
              interface)
              ->Fifteen(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ManyParameters>::entries_end_ = &entries_[1];

void fidl::internal::NaturalServerDispatcher<::test_protocols::ManyParameters>::
    Dispatch(::fidl::Server<::test_protocols::ManyParameters>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::ManyParameters>::Dispatch(this, std::move(msg),
                                                  std::move(transport_context),
                                                  txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;

[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;

[[maybe_unused]] constexpr inline uint64_t
    kHandleRightsProtocol_AnEvent_Ordinal = 476727631355490611lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::internal::NaturalThenable<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
fidl::internal::NaturalClientImpl<::test_protocols::HandleRightsProtocol>::
    ResponseMethod(
        ::fidl::Request<::test_protocols::HandleRightsProtocol::ResponseMethod>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Request<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalClientImpl<::test_protocols::HandleRightsProtocol>::NoResponseMethod(
        ::fidl::Request<
            ::test_protocols::HandleRightsProtocol::NoResponseMethod>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Request<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>>::
          IntoDomainObject(std::move(request)));

  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::HandleRightsProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::HandleRightsProtocolAnEventRequest>(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<::test_protocols::HandleRightsProtocol::AnEvent> event =
            ::fidl::internal::NaturalMessageConverter<::fidl::Event<
                ::test_protocols::HandleRightsProtocol::AnEvent>>::
                FromDomainObject(std::move(decoded.value()));
        event_handler()->AnEvent(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(
        ::test_protocols::HandleRightsProtocolAnEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status result = _inner().SendEvent(_encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error> fidl::internal::
    NaturalEventSender<::test_protocols::HandleRightsProtocol>::AnEvent(
        ::test_protocols::HandleRightsProtocolAnEventRequest payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  _encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{_encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::fidl::Response<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>&& response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Response<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_[] = {
    {
        ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>
              request = ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::HandleRightsProtocol::
                                      NoResponseMethod>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->NoResponseMethod(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::HandleRightsProtocolResponseMethodRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::HandleRightsProtocol::ResponseMethod>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->ResponseMethod(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_end_ = &entries_[2];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ResponseAsStruct_Ordinal = 268248568430741139lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsPrimitive_Ordinal = 6930994461233198567lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_ErrorAsEnum_Ordinal = 5491891352371277635lu;

[[maybe_unused]] constexpr inline uint64_t
    kWithErrorSyntax_HandleInResult_Ordinal = 1371676333068455103lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::internal::NaturalThenable<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithErrorSyntax>::ResponseAsStruct() const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsEnum() const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::WithErrorSyntax::HandleInResult>
fidl::internal::NaturalClientImpl<
    ::test_protocols::WithErrorSyntax>::HandleInResult() const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::WithErrorSyntax::HandleInResult>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(
        ::fidl::Response<::test_protocols::WithErrorSyntax::ResponseAsStruct>&&
            response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Response<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(
        ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>&&
            response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<::fidl::Response<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::
    NaturalCompleterBase<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(
        ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>&&
            response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::WithErrorSyntax::ErrorAsEnum>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    Reply(::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>&&
              response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::WithErrorSyntax::HandleInResult>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_[] = {
    {
        ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::ResponseAsStruct>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ResponseAsStruct(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ErrorAsPrimitive(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::ErrorAsEnum>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->ErrorAsEnum(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::WithErrorSyntax::HandleInResult>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::WithErrorSyntax::HandleInResult>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::WithErrorSyntax>*>(
              interface)
              ->HandleInResult(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_end_ = &entries_[4];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::WithErrorSyntax>::Dispatch(
        ::fidl::Server<::test_protocols::WithErrorSyntax>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t
    kDiscoverableProtocol_Method_Ordinal = 3455873048082739435lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fitx::result<::fidl::Error> fidl::internal::NaturalClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kDiscoverableProtocol_Method_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo>
fidl::internal::NaturalEventDispatcher<::test_protocols::DiscoverableProtocol>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_[] = {
    {
        ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded =
              ::fidl::internal::DecodeTransactionalMessage(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::DiscoverableProtocol::Method>
              request;
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::DiscoverableProtocol::Method>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::DiscoverableProtocol>*>(
              interface)
              ->Method(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_end_ = &entries_[1];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;

[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;

[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;

[[maybe_unused]] constexpr inline uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;

[[maybe_unused]] constexpr inline uint64_t
    kChannelProtocol_MutateSocket_Ordinal = 7411742788430590287lu;

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::MethodB>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::MethodB(
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_MethodB_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::ChannelProtocol::MethodB>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<::test_protocols::ChannelProtocol::TakeHandle>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    TakeHandle(::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>
                   request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::ChannelProtocol::TakeHandle>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fidl::internal::NaturalThenable<
    ::test_protocols::ChannelProtocol::MutateSocket>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::
    MutateSocket(
        ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>
            request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>>::
          IntoDomainObject(std::move(request)));
  return ::fidl::internal::NaturalThenable<
      ::test_protocols::ChannelProtocol::MutateSocket>(
      &client_base(), {}, std::move(_encoder),
      [](::fidl::internal::ThenableBase* base,
         ::fidl::internal::NaturalMessageEncoder& encoder,
         ::fidl::internal::ResponseContext* response_context) {
        ::fidl::OutgoingMessage msg = encoder.GetMessage();
        return base->SendTwoWay(msg, response_context);
      });
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalClientImpl<::test_protocols::ChannelProtocol>::MethodA(
    ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> request) const {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_MethodA_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>::
          IntoDomainObject(std::move(request)));

  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status status = client_base().SendOneWay(_encoded_message);
  return ::fidl::internal::ToFitxResult(status);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

std::optional<::fidl::UnbindInfo> fidl::internal::
    NaturalEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
          ::test_protocols::ChannelProtocolEventARequest>(std::move(msg));
      if (decoded.is_error()) {
        return ::fidl::UnbindInfo(decoded.error_value());
      }
      if (event_handler()) {
        ::fidl::Event<::test_protocols::ChannelProtocol::EventA> event =
            ::fidl::internal::NaturalMessageConverter<
                ::fidl::Event<::test_protocols::ChannelProtocol::EventA>>::
                FromDomainObject(std::move(decoded.value()));
        event_handler()->EventA(event);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fitx::result<::fidl::Error> fidl::internal::
    NaturalWeakEventSender<::test_protocols::ChannelProtocol>::EventA(
        ::test_protocols::ChannelProtocolEventARequest payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_EventA_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  ::fidl::Status result = _inner().SendEvent(_encoded_message);
  return ::fidl::internal::ToFitxResult(result);
}

::fitx::result<::fidl::Error>
fidl::internal::NaturalEventSender<::test_protocols::ChannelProtocol>::EventA(
    ::test_protocols::ChannelProtocolEventARequest payload) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_EventA_Ordinal};
  _encoder.EncodeBody(std::move(payload));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  _encoded_message.Write(_transport());
  return ::fidl::internal::ToFitxResult(::fidl::Status{_encoded_message});
}

#endif  // __Fuchsia__

void fidl::internal::
    NaturalCompleterBase<::test_protocols::ChannelProtocol::MethodB>::Reply(
        ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>&&
            response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_MethodB_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::ChannelProtocol::MethodB>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_TakeHandle_Ordinal};
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

void fidl::internal::NaturalCompleterBase<
    ::test_protocols::ChannelProtocol::MutateSocket>::
    Reply(::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>&&
              response) {
  ::fidl::internal::NaturalMessageEncoder _encoder{
      &::fidl::internal::ChannelTransport::VTable,
      ::test_protocols::kChannelProtocol_MutateSocket_Ordinal};
  _encoder.EncodeBody(
      ::fidl::internal::NaturalMessageConverter<
          ::fidl::Response<::test_protocols::ChannelProtocol::MutateSocket>>::
          IntoDomainObject(std::move(response)));
  ::fidl::OutgoingMessage _encoded_message = _encoder.GetMessage();
  SendReply(&_encoded_message, ::fidl::internal::OutgoingTransportContext{});
}

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_[] = {
    {
        ::test_protocols::kChannelProtocol_MethodA_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolMethodARequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodA> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::ChannelProtocol::MethodA>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MethodA(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MethodB_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolMethodBRequest>(std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::MethodB> request =
              ::fidl::internal::NaturalMessageConverter<
                  ::fidl::Request<::test_protocols::ChannelProtocol::MethodB>>::
                  FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MethodB(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolTakeHandleRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::TakeHandle>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::ChannelProtocol::TakeHandle>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::TakeHandle>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->TakeHandle(request, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fitx::result decoded = ::fidl::internal::DecodeTransactionalMessage<
              ::test_protocols::ChannelProtocolMutateSocketRequest>(
              std::move(msg));
          if (decoded.is_error()) {
            return decoded.error_value().status();
          }
          ::fidl::Request<::test_protocols::ChannelProtocol::MutateSocket>
              request =
                  ::fidl::internal::NaturalMessageConverter<::fidl::Request<
                      ::test_protocols::ChannelProtocol::MutateSocket>>::
                      FromDomainObject(std::move(decoded.value()));
          ::fidl::internal::NaturalCompleter<
              ::test_protocols::ChannelProtocol::MutateSocket>::Sync
              completer(txn);
          static_cast<::fidl::Server<::test_protocols::ChannelProtocol>*>(
              interface)
              ->MutateSocket(request, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::NaturalServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_end_ = &entries_[4];

void fidl::internal::
    NaturalServerDispatcher<::test_protocols::ChannelProtocol>::Dispatch(
        ::fidl::Server<::test_protocols::ChannelProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::Server<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::NaturalServerDispatcher<
      ::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__
