// WARNING: This file is machine generated by fidlgen_llcpp.

#pragma once

#include <fidl/test.protocolpayloads.imported/cpp/natural_messaging.h>
#include <fidl/test.protocolpayloads/cpp/markers.h>
#include <fidl/test.protocolpayloads/cpp/natural_types.h>
#include <fidl/test.protocolpayloads/cpp/wire_messaging.h>
#include <lib/fidl/cpp/channel.h>
#include <lib/fidl/cpp/client.h>
#include <lib/fidl/cpp/internal/thenable.h>
#include <lib/fidl/cpp/natural_types.h>
#include <lib/fidl/cpp/unified_messaging.h>

namespace fidl {}  // namespace fidl
template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayComposed> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayComposed>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayComposed>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayLocal> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayLocal>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayLocal>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayImport> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayImport>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayImport>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayAnon> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayAnon>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayAnon>&)>;

  static constexpr bool HasApplicationError = false;

  static constexpr bool IsAbsentBody = false;
};

template <>
struct ::fidl::internal::NaturalMethodTypes<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError> {
  using Completer = fidl::Completer<::fidl::internal::NaturalCompleterBase<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>;

  using ResultCallback = ::fit::callback<void(
      ::fidl::Result<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&)>;

  static constexpr bool HasApplicationError = true;

  static constexpr bool IsEmptyStructPayload = false;

  static constexpr bool IsAbsentBody = false;
};
namespace test_protocolpayloads {
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_imported_ImportStructPayloadTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_imported_ComposedProtocolTwoWayComposedWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_imported_ComposedProtocolOnComposedWithErrorRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_LocalStructPayloadTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayLocalWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayImportWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOneWayAnonRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonTopResponseTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable;
__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonWithErrorTopResponseTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnAnonRequestTable;

__LOCAL extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable;

#ifdef __Fuchsia__
}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed> final
    : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Event(::test_protocolpayloads_imported::ImportStructPayload v)
      : ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposedWithError>
    final
    : public ::fitx::result<
          uint32_t, ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      uint32_t, ::test_protocolpayloads_imported::ImportStructPayload>::result;
  Event(::fitx::result<uint32_t,
                       ::test_protocolpayloads_imported::ImportStructPayload>
            v)
      : result(std::move(v)) {}
  Event() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposedWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::
      ComposedProtocolOnComposedWithErrorRequest;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposedWithError>> {
  using DomainObject = ::test_protocolpayloads_imported::
      ComposedProtocolOnComposedWithErrorRequest;

 public:
  static ::fidl::Event<
      ::test_protocolpayloads::MainProtocol::OnComposedWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Event<
          ::test_protocolpayloads::MainProtocol::OnComposedWithError>&& m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocolpayloads_imported::
               ComposedProtocolOnComposedWithErrorResult::WithErr(
                   m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocolpayloads_imported::
               ComposedProtocolOnComposedWithErrorResult::WithResponse(
                   std::move(m.value()))}};
    }
  }
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal> final
    : public ::test_protocolpayloads::LocalStructPayload {
 public:
  using ::test_protocolpayloads::LocalStructPayload::LocalStructPayload;
  Event(::test_protocolpayloads::LocalStructPayload v)
      : LocalStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>
    final : public ::fitx::result<uint32_t,
                                  ::test_protocolpayloads::LocalStructPayload> {
 public:
  using ::fitx::result<uint32_t,
                       ::test_protocolpayloads::LocalStructPayload>::result;
  Event(::fitx::result<uint32_t, ::test_protocolpayloads::LocalStructPayload> v)
      : result(std::move(v)) {}
  Event() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>> {
  using DomainObject =
      ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest;

 public:
  static ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>&&
          m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocolpayloads::
               MainProtocolOnLocalWithErrorResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocolpayloads::
                               MainProtocolOnLocalWithErrorResult::WithResponse(
                                   std::move(m.value()))}};
    }
  }
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport> final
    : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Event(::test_protocolpayloads_imported::ImportStructPayload v)
      : ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>
    final
    : public ::fitx::result<
          uint32_t, ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      uint32_t, ::test_protocolpayloads_imported::ImportStructPayload>::result;
  Event(::fitx::result<uint32_t,
                       ::test_protocolpayloads_imported::ImportStructPayload>
            v)
      : result(std::move(v)) {}
  Event() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>> {
  using DomainObject =
      ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest;

 public:
  static ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImportWithError>&&
          m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocolpayloads::
               MainProtocolOnImportWithErrorResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{
          {.result =
               ::test_protocolpayloads::MainProtocolOnImportWithErrorResult::
                   WithResponse(std::move(m.value()))}};
    }
  }
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon> final
    : public ::test_protocolpayloads::MainProtocolOnAnonRequest {
 public:
  using ::test_protocolpayloads::MainProtocolOnAnonRequest::
      MainProtocolOnAnonRequest;
  Event(::test_protocolpayloads::MainProtocolOnAnonRequest v)
      : MainProtocolOnAnonRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnAnonRequest;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>
    final : public ::fitx::result<
                uint32_t,
                ::test_protocolpayloads::MainProtocolOnAnonWithErrorResponse> {
 public:
  using ::fitx::result<
      uint32_t,
      ::test_protocolpayloads::MainProtocolOnAnonWithErrorResponse>::result;
  Event(::fitx::result<
        uint32_t, ::test_protocolpayloads::MainProtocolOnAnonWithErrorResponse>
            v)
      : result(std::move(v)) {}
  Event() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest;
};
template <>
class ::fidl::internal::NaturalMessageConverter<
    ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>> {
  using DomainObject =
      ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest;

 public:
  static ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>&&
          m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocolpayloads::
               MainProtocolOnAnonWithErrorResult::WithErr(m.error_value())}};
    } else {
      return DomainObject{{.result = ::test_protocolpayloads::
                               MainProtocolOnAnonWithErrorResult::WithResponse(
                                   std::move(m.value()))}};
    }
  }
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayComposed>
    final : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Response(::test_protocolpayloads_imported::ImportStructPayload v)
      : ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
namespace test_protocolpayloads {}  // namespace test_protocolpayloads
template <>
class ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayComposed>
    final : public ::fitx::result<
                ::fidl::Error,
                ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocolpayloads_imported::ImportStructPayload>::result;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    final
    : public ::fitx::result<
          uint32_t, ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      uint32_t, ::test_protocolpayloads_imported::ImportStructPayload>::result;
  Response(::fitx::result<uint32_t,
                          ::test_protocolpayloads_imported::ImportStructPayload>
               v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>> {
  using DomainObject = ::test_protocolpayloads_imported::
      ComposedProtocolTwoWayComposedWithErrorTopResponse;

 public:
  static ::fidl::Response<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&& m) {
    if (m.is_error()) {
      return DomainObject{
          {.result = ::test_protocolpayloads_imported::
               ComposedProtocolTwoWayComposedWithErrorResult::WithErr(
                   m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocolpayloads_imported::
               ComposedProtocolTwoWayComposedWithErrorResult::WithResponse(
                   std::move(m.value()))}};
    }
  }
};
template <>
class ::fidl::Result<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<
              ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>,
          ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      ::fidl::AnyErrorIn<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>,
      ::test_protocolpayloads_imported::ImportStructPayload>::result;
};

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal> final
    : public ::test_protocolpayloads::LocalStructPayload {
 public:
  using ::test_protocolpayloads::LocalStructPayload::LocalStructPayload;
  Response(::test_protocolpayloads::LocalStructPayload v)
      : LocalStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
template <>
class ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayLocal> final
    : public ::fitx::result<::fidl::Error,
                            ::test_protocolpayloads::LocalStructPayload> {
 public:
  using ::fitx::result<::fidl::Error,
                       ::test_protocolpayloads::LocalStructPayload>::result;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    final : public ::fitx::result<uint32_t,
                                  ::test_protocolpayloads::LocalStructPayload> {
 public:
  using ::fitx::result<uint32_t,
                       ::test_protocolpayloads::LocalStructPayload>::result;
  Response(
      ::fitx::result<uint32_t, ::test_protocolpayloads::LocalStructPayload> v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>> {
  using DomainObject =
      ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorTopResponse;

 public:
  static ::fidl::Response<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocolpayloads::
                               MainProtocolTwoWayLocalWithErrorResult::WithErr(
                                   m.error_value())}};
    } else {
      return DomainObject{
          {.result =
               ::test_protocolpayloads::MainProtocolTwoWayLocalWithErrorResult::
                   WithResponse(std::move(m.value()))}};
    }
  }
};
template <>
class ::fidl::Result<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<
              ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>,
          ::test_protocolpayloads::LocalStructPayload> {
 public:
  using ::fitx::result<
      ::fidl::AnyErrorIn<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>,
      ::test_protocolpayloads::LocalStructPayload>::result;
};

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>
    final : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Response(::test_protocolpayloads_imported::ImportStructPayload v)
      : ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
template <>
class ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayImport> final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocolpayloads_imported::ImportStructPayload>::result;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    final
    : public ::fitx::result<
          uint32_t, ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      uint32_t, ::test_protocolpayloads_imported::ImportStructPayload>::result;
  Response(::fitx::result<uint32_t,
                          ::test_protocolpayloads_imported::ImportStructPayload>
               v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>> {
  using DomainObject =
      ::test_protocolpayloads::MainProtocolTwoWayImportWithErrorTopResponse;

 public:
  static ::fidl::Response<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocolpayloads::
                               MainProtocolTwoWayImportWithErrorResult::WithErr(
                                   m.error_value())}};
    } else {
      return DomainObject{
          {.result = ::test_protocolpayloads::
               MainProtocolTwoWayImportWithErrorResult::WithResponse(
                   std::move(m.value()))}};
    }
  }
};
template <>
class ::fidl::Result<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<
              ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>,
          ::test_protocolpayloads_imported::ImportStructPayload> {
 public:
  using ::fitx::result<
      ::fidl::AnyErrorIn<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>,
      ::test_protocolpayloads_imported::ImportStructPayload>::result;
};

template <>
class ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon> final
    : public ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse {
 public:
  using ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse::
      MainProtocolTwoWayAnonTopResponse;
  Response(::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse v)
      : MainProtocolTwoWayAnonTopResponse(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse;
};
template <>
class ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayAnon> final
    : public ::fitx::result<
          ::fidl::Error,
          ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse> {
 public:
  using ::fitx::result<
      ::fidl::Error,
      ::test_protocolpayloads::MainProtocolTwoWayAnonTopResponse>::result;
};

template <>
class ::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    final
    : public ::fitx::result<
          uint32_t,
          ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse> {
 public:
  using ::fitx::result<
      uint32_t,
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse>::result;
  Response(::fitx::result<
           uint32_t,
           ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse>
               v)
      : result(std::move(v)) {}
  Response() = delete;
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse;
};
template <>
class ::fidl::internal::NaturalMessageConverter<::fidl::Response<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>> {
  using DomainObject =
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorTopResponse;

 public:
  static ::fidl::Response<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
  FromDomainObject(DomainObject o) {
    if (o.result().err().has_value()) {
      return ::fitx::error(std::move(o.result().err().value()));
    } else {
      ZX_DEBUG_ASSERT(o.result().response().has_value());
      return ::fitx::ok(std::move(o.result().response().value()));
    }
  }

  static DomainObject IntoDomainObject(
      ::fidl::Response<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&& m) {
    if (m.is_error()) {
      return DomainObject{{.result = ::test_protocolpayloads::
                               MainProtocolTwoWayAnonWithErrorResult::WithErr(
                                   m.error_value())}};
    } else {
      return DomainObject{
          {.result =
               ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResult::
                   WithResponse(std::move(m.value()))}};
    }
  }
};
template <>
class ::fidl::Result<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    final
    : public ::fitx::result<
          ::fidl::AnyErrorIn<
              ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>,
          ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse> {
 public:
  using ::fitx::result<
      ::fidl::AnyErrorIn<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>,
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorResponse>::result;
};

template <>
class ::fidl::internal::NaturalClientImpl<::test_protocolpayloads::MainProtocol>
    final : public ::fidl::internal::NaturalClientBase {
 public:
  using NaturalClientBase::NaturalClientBase;
  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayComposed>
  TwoWayComposed(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>
          request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
  TwoWayComposedWithError(
      ::fidl::Request<
          ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
          request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayLocal>
  TwoWayLocal(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal>
          request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
  TwoWayLocalWithError(
      ::fidl::Request<
          ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
          request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayImport>
  TwoWayImport(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport>
          request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
  TwoWayImportWithError(
      ::fidl::Request<
          ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
          request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayAnon>
  TwoWayAnon(::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon>
                 request) const;

  ::fidl::internal::NaturalThenable<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
  TwoWayAnonWithError(
      ::fidl::Request<
          ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
          request) const;

  ::fitx::result<::fidl::Error> OneWayComposed(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>
          request) const;

  ::fitx::result<::fidl::Error> OneWayLocal(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal>
          request) const;

  ::fitx::result<::fidl::Error> OneWayImport(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport>
          request) const;

  ::fitx::result<::fidl::Error> OneWayAnon(
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon>
          request) const;
};
namespace test_protocolpayloads {
#endif  // __Fuchsia__

}  // namespace test_protocolpayloads
#ifdef __Fuchsia__

template <>
class ::fidl::internal::NaturalEventHandlerInterface<
    ::test_protocolpayloads::MainProtocol> {
 public:
  NaturalEventHandlerInterface() = default;
  virtual ~NaturalEventHandlerInterface() = default;
  virtual void OnComposed(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnComposed>&) {}
  virtual void OnComposedWithError(
      ::fidl::Event<
          ::test_protocolpayloads::MainProtocol::OnComposedWithError>&) {}
  virtual void OnLocal(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocal>&) {}
  virtual void OnLocalWithError(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnLocalWithError>&) {
  }
  virtual void OnImport(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnImport>&) {}
  virtual void OnImportWithError(
      ::fidl::Event<
          ::test_protocolpayloads::MainProtocol::OnImportWithError>&) {}
  virtual void OnAnon(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnon>&) {}
  virtual void OnAnonWithError(
      ::fidl::Event<::test_protocolpayloads::MainProtocol::OnAnonWithError>&) {}
};

template <>
class ::fidl::AsyncEventHandler<::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::NaturalEventHandlerInterface<
          ::test_protocolpayloads::MainProtocol>,
      public ::fidl::internal::AsyncEventHandler {
 public:
  AsyncEventHandler() = default;
};

template <>
class ::fidl::internal::NaturalEventDispatcher<
    ::test_protocolpayloads::MainProtocol>
    final
    : public ::fidl::internal::IncomingEventDispatcher<
          ::fidl::AsyncEventHandler<::test_protocolpayloads::MainProtocol>> {
 public:
  explicit NaturalEventDispatcher(
      ::fidl::AsyncEventHandler<::test_protocolpayloads::MainProtocol>*
          event_handler)
      : IncomingEventDispatcher(event_handler) {}

 private:
  std::optional<::fidl::UnbindInfo> DispatchEvent(
      ::fidl::IncomingMessage& msg,
      internal::IncomingTransportContext transport_context) override;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
template <>
class ::fidl::internal::NaturalWeakEventSender<
    ::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::WeakEventSenderBase {
 public:
  using WeakEventSenderBase::WeakEventSenderBase;

  ::fitx::result<::fidl::Error> OnComposed(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnComposedWithError(
      ::test_protocolpayloads_imported::
          ComposedProtocolOnComposedWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnLocal(
      ::test_protocolpayloads::LocalStructPayload payload);

  ::fitx::result<::fidl::Error> OnLocalWithError(
      ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnImport(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnImportWithError(
      ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnAnon(
      ::test_protocolpayloads::MainProtocolOnAnonRequest payload);

  ::fitx::result<::fidl::Error> OnAnonWithError(
      ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload);
};

template <>
class ::fidl::internal::NaturalEventSender<
    ::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::SyncEndpointManagedVeneer<
          ::fidl::internal::NaturalEventSender<
              ::test_protocolpayloads::MainProtocol>> {
 public:
  using SyncEndpointManagedVeneer::SyncEndpointManagedVeneer;

  ::fitx::result<::fidl::Error> OnComposed(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnComposedWithError(
      ::test_protocolpayloads_imported::
          ComposedProtocolOnComposedWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnLocal(
      ::test_protocolpayloads::LocalStructPayload payload);

  ::fitx::result<::fidl::Error> OnLocalWithError(
      ::test_protocolpayloads::MainProtocolOnLocalWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnImport(
      ::test_protocolpayloads_imported::ImportStructPayload payload);

  ::fitx::result<::fidl::Error> OnImportWithError(
      ::test_protocolpayloads::MainProtocolOnImportWithErrorRequest payload);

  ::fitx::result<::fidl::Error> OnAnon(
      ::test_protocolpayloads::MainProtocolOnAnonRequest payload);

  ::fitx::result<::fidl::Error> OnAnonWithError(
      ::test_protocolpayloads::MainProtocolOnAnonWithErrorRequest payload);
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>
    final : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Request(::test_protocolpayloads_imported::ImportStructPayload v)
      : ::test_protocolpayloads_imported::ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>
    final : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Request(::test_protocolpayloads_imported::ImportStructPayload v)
      : ::test_protocolpayloads_imported::ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    final : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Request(::test_protocolpayloads_imported::ImportStructPayload v)
      : ::test_protocolpayloads_imported::ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal> final
    : public ::test_protocolpayloads::LocalStructPayload {
 public:
  using ::test_protocolpayloads::LocalStructPayload::LocalStructPayload;
  Request(::test_protocolpayloads::LocalStructPayload v)
      : ::test_protocolpayloads::LocalStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal> final
    : public ::test_protocolpayloads::LocalStructPayload {
 public:
  using ::test_protocolpayloads::LocalStructPayload::LocalStructPayload;
  Request(::test_protocolpayloads::LocalStructPayload v)
      : ::test_protocolpayloads::LocalStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    final : public ::test_protocolpayloads::LocalStructPayload {
 public:
  using ::test_protocolpayloads::LocalStructPayload::LocalStructPayload;
  Request(::test_protocolpayloads::LocalStructPayload v)
      : ::test_protocolpayloads::LocalStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::LocalStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport> final
    : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Request(::test_protocolpayloads_imported::ImportStructPayload v)
      : ::test_protocolpayloads_imported::ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport> final
    : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Request(::test_protocolpayloads_imported::ImportStructPayload v)
      : ::test_protocolpayloads_imported::ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    final : public ::test_protocolpayloads_imported::ImportStructPayload {
 public:
  using ::test_protocolpayloads_imported::ImportStructPayload::
      ImportStructPayload;
  Request(::test_protocolpayloads_imported::ImportStructPayload v)
      : ::test_protocolpayloads_imported::ImportStructPayload(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads_imported::ImportStructPayload;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon> final
    : public ::test_protocolpayloads::MainProtocolOneWayAnonRequest {
 public:
  using ::test_protocolpayloads::MainProtocolOneWayAnonRequest::
      MainProtocolOneWayAnonRequest;
  Request(::test_protocolpayloads::MainProtocolOneWayAnonRequest v)
      : ::test_protocolpayloads::MainProtocolOneWayAnonRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolOneWayAnonRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon> final
    : public ::test_protocolpayloads::MainProtocolTwoWayAnonRequest {
 public:
  using ::test_protocolpayloads::MainProtocolTwoWayAnonRequest::
      MainProtocolTwoWayAnonRequest;
  Request(::test_protocolpayloads::MainProtocolTwoWayAnonRequest v)
      : ::test_protocolpayloads::MainProtocolTwoWayAnonRequest(std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload = ::test_protocolpayloads::MainProtocolTwoWayAnonRequest;
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__

template <>
class ::fidl::Request<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    final
    : public ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest {
 public:
  using ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest::
      MainProtocolTwoWayAnonWithErrorRequest;
  Request(::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest v)
      : ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest(
            std::move(v)) {}
};

template <>
struct ::fidl::internal::MessageTraits<
    ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>>
    final {
 public:
  static constexpr bool kHasPayload = true;
  using Payload =
      ::test_protocolpayloads::MainProtocolTwoWayAnonWithErrorRequest;
};
#endif  // __Fuchsia__

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayComposed>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayComposed>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<
             ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayLocal>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayLocal>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<
             ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayImport>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayImport>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>
    : public ::fidl::CompleterBase {
 public:
  void Reply(::fidl::Response<
             ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>&&
                 response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayAnon>
    : public ::fidl::CompleterBase {
 public:
  void Reply(
      ::fidl::Response<::test_protocolpayloads::MainProtocol::TwoWayAnon>&&
          response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::internal::NaturalCompleterBase<
    ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>
    : public ::fidl::CompleterBase {
 public:
  void
  Reply(::fidl::Response<
        ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>&& response);

 protected:
  using ::fidl::CompleterBase::CompleterBase;
};

template <>
class ::fidl::Server<::test_protocolpayloads::MainProtocol>
    : public ::fidl::internal::IncomingMessageDispatcher {
 public:
  Server() = default;
  virtual ~Server() = default;

  // The FIDL protocol type that is implemented by this server.
  using _EnclosingProtocol = ::test_protocolpayloads::MainProtocol;

  using OneWayComposedRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayComposed>;
  using OneWayComposedCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayComposed>;

  virtual void OneWayComposed(OneWayComposedRequest& request,
                              OneWayComposedCompleter::Sync& completer) = 0;

  using TwoWayComposedRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayComposed>;
  using TwoWayComposedCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayComposed>;

  virtual void TwoWayComposed(TwoWayComposedRequest& request,
                              TwoWayComposedCompleter::Sync& completer) = 0;

  using TwoWayComposedWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>;
  using TwoWayComposedWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayComposedWithError>;

  virtual void TwoWayComposedWithError(
      TwoWayComposedWithErrorRequest& request,
      TwoWayComposedWithErrorCompleter::Sync& completer) = 0;

  using OneWayLocalRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayLocal>;
  using OneWayLocalCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayLocal>;

  virtual void OneWayLocal(OneWayLocalRequest& request,
                           OneWayLocalCompleter::Sync& completer) = 0;

  using TwoWayLocalRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayLocal>;
  using TwoWayLocalCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayLocal>;

  virtual void TwoWayLocal(TwoWayLocalRequest& request,
                           TwoWayLocalCompleter::Sync& completer) = 0;

  using TwoWayLocalWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>;
  using TwoWayLocalWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayLocalWithError>;

  virtual void TwoWayLocalWithError(
      TwoWayLocalWithErrorRequest& request,
      TwoWayLocalWithErrorCompleter::Sync& completer) = 0;

  using OneWayImportRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayImport>;
  using OneWayImportCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayImport>;

  virtual void OneWayImport(OneWayImportRequest& request,
                            OneWayImportCompleter::Sync& completer) = 0;

  using TwoWayImportRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayImport>;
  using TwoWayImportCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayImport>;

  virtual void TwoWayImport(TwoWayImportRequest& request,
                            TwoWayImportCompleter::Sync& completer) = 0;

  using TwoWayImportWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>;
  using TwoWayImportWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayImportWithError>;

  virtual void TwoWayImportWithError(
      TwoWayImportWithErrorRequest& request,
      TwoWayImportWithErrorCompleter::Sync& completer) = 0;

  using OneWayAnonRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::OneWayAnon>;
  using OneWayAnonCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::OneWayAnon>;

  virtual void OneWayAnon(OneWayAnonRequest& request,
                          OneWayAnonCompleter::Sync& completer) = 0;

  using TwoWayAnonRequest =
      ::fidl::Request<::test_protocolpayloads::MainProtocol::TwoWayAnon>;
  using TwoWayAnonCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayAnon>;

  virtual void TwoWayAnon(TwoWayAnonRequest& request,
                          TwoWayAnonCompleter::Sync& completer) = 0;

  using TwoWayAnonWithErrorRequest = ::fidl::Request<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>;
  using TwoWayAnonWithErrorCompleter = ::fidl::internal::NaturalCompleter<
      ::test_protocolpayloads::MainProtocol::TwoWayAnonWithError>;

  virtual void TwoWayAnonWithError(
      TwoWayAnonWithErrorRequest& request,
      TwoWayAnonWithErrorCompleter::Sync& completer) = 0;

 private:
  void dispatch_message(
      ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
      ::fidl::internal::IncomingTransportContext transport_context) final;
};

#ifdef __Fuchsia__

template <>
struct ::fidl::internal::NaturalServerDispatcher<
    ::test_protocolpayloads::MainProtocol>
    final {
  NaturalServerDispatcher() = delete;
  static void Dispatch(
      ::fidl::Server<::test_protocolpayloads::MainProtocol>* impl,
      ::fidl::IncomingMessage&& msg,
      internal::IncomingTransportContext transport_context,
      ::fidl::Transaction* txn);

 private:
  static const ::fidl::internal::MethodEntry entries_[];
  static const ::fidl::internal::MethodEntry* entries_end_;
};
#endif  // __Fuchsia__
