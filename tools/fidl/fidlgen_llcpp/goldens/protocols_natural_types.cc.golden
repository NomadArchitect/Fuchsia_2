// WARNING: This file is machine generated by fidlgen.

#include <fidl/test.protocols/cpp/natural_types.h>

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_HandleInResult_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_HandleInResult_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_HandleInResult_Response>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntax_HandleInResult_Response::
    WithErrorSyntax_HandleInResult_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::handle>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxHandleInResultTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxHandleInResultTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntaxHandleInResultTopResponse::
    WithErrorSyntaxHandleInResultTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_HandleInResult_Result>(&decoder,
                                                                   0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolResponseMethodTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolResponseMethodTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::HandleRightsProtocolResponseMethodTopResponse::
    HandleRightsProtocolResponseMethodTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolResponseMethodRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolResponseMethodRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolResponseMethodRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::HandleRightsProtocolResponseMethodRequest::
    HandleRightsProtocolResponseMethodRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolNoResponseMethodRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolNoResponseMethodRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::HandleRightsProtocolNoResponseMethodRequest::
    HandleRightsProtocolNoResponseMethodRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::HandleRightsProtocolAnEventRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::HandleRightsProtocolAnEventRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::HandleRightsProtocolAnEventRequest>::Encode(&encoder,
                                                                    this,
                                                                    offset);
}

::test_protocols::HandleRightsProtocolAnEventRequest::
    HandleRightsProtocolAnEventRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolTakeHandleRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolTakeHandleRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolTakeHandleRequest>::Encode(&encoder,
                                                                  this, offset);
}

::test_protocols::ChannelProtocolTakeHandleRequest::
    ChannelProtocolTakeHandleRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::handle>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMutateSocketTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::ChannelProtocolMutateSocketTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolMutateSocketTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::ChannelProtocolMutateSocketTopResponse::
    ChannelProtocolMutateSocketTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMutateSocketRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::ChannelProtocolMutateSocketRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolMutateSocketRequest>::Encode(&encoder,
                                                                    this,
                                                                    offset);
}

::test_protocols::ChannelProtocolMutateSocketRequest::
    ChannelProtocolMutateSocketRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::zx::socket>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsServerEndsTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithProtocolEndsServerEndsTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsServerEndsTopResponse>::Encode(&encoder,
                                                                       this,
                                                                       offset);
}

::test_protocols::WithProtocolEndsServerEndsTopResponse::
    WithProtocolEndsServerEndsTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsServerEndsRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithProtocolEndsServerEndsRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsServerEndsRequest>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::WithProtocolEndsServerEndsRequest::
    WithProtocolEndsServerEndsRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsClientEndsTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithProtocolEndsClientEndsTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsClientEndsTopResponse>::Encode(&encoder,
                                                                       this,
                                                                       offset);
}

::test_protocols::WithProtocolEndsClientEndsTopResponse::
    WithProtocolEndsClientEndsTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsClientEndsRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithProtocolEndsClientEndsRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsClientEndsRequest>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::WithProtocolEndsClientEndsRequest::
    WithProtocolEndsClientEndsRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntax_ResponseAsStruct_Response::
    WithErrorSyntax_ResponseAsStruct_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8),
                ::fidl::DecodeAs<int64_t>(&decoder, 16)}) {}
#endif  // __Fuchsia__

::test_protocols::WithErrorSyntax_ResponseAsStruct_Response::Storage
test_protocols::WithErrorSyntax_ResponseAsStruct_Response::CloneStorage()
    const {
  return Storage{::fidl::internal::NaturalClone(storage_.a),
                 ::fidl::internal::NaturalClone(storage_.b),
                 ::fidl::internal::NaturalClone(storage_.c)};
}
#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntaxResponseAsStructTopResponse::
    WithErrorSyntaxResponseAsStructTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithErrorSyntaxResponseAsStructTopResponse::Storage
test_protocols::WithErrorSyntaxResponseAsStructTopResponse::CloneStorage()
    const {
  return Storage{::fidl::internal::NaturalClone(storage_.result)};
}
#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response::
    WithErrorSyntax_ErrorAsPrimitive_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<uint8_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response::Storage
test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response::CloneStorage()
    const {
  return Storage{::fidl::internal::NaturalClone(storage_.__reserved)};
}
#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse::
    WithErrorSyntaxErrorAsPrimitiveTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>(&decoder,
                                                                     0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse::Storage
test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse::CloneStorage()
    const {
  return Storage{::fidl::internal::NaturalClone(storage_.result)};
}
#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>::Encode(&encoder,
                                                                      this,
                                                                      offset);
}

::test_protocols::WithErrorSyntax_ErrorAsEnum_Response::
    WithErrorSyntax_ErrorAsEnum_Response(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<uint8_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithErrorSyntax_ErrorAsEnum_Response::Storage
test_protocols::WithErrorSyntax_ErrorAsEnum_Response::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.__reserved)};
}
#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::Storage
    test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse::
            CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.ret)};
}
#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestWithResponseRequest::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::
                    WithAndWithoutRequestResponseWithRequestWithResponseRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest::
    WithAndWithoutRequestResponseWithRequestWithResponseRequest(
        ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithAndWithoutRequestResponseWithRequestWithResponseRequest::
    Storage
    test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest::
            CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.arg)};
}
#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestNoResponseRequest::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::
                    WithAndWithoutRequestResponseWithRequestNoResponseRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest::
    WithAndWithoutRequestResponseWithRequestNoResponseRequest(
        ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest::
    Storage
    test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest::
        CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.arg)};
}
#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
    WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
        ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
    Storage
    test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest::
            CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.arg)};
}
#ifdef __Fuchsia__

void ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::
    WithAndWithoutRequestResponseOnWithResponseRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::Storage
test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest::
    CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.ret)};
}
#ifdef __Fuchsia__

void ::test_protocols::
    WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::
        EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::
              WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::
    WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::std::string>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::
    WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::Storage
    test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse::
            CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.ret)};
}
#ifdef __Fuchsia__

void ::test_protocols::TransitionalRequestTopResponse::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::TransitionalRequestTopResponse, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::TransitionalRequestTopResponse>::Encode(&encoder, this,
                                                                offset);
}

::test_protocols::TransitionalRequestTopResponse::
    TransitionalRequestTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::TransitionalRequestTopResponse::Storage
test_protocols::TransitionalRequestTopResponse::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.y)};
}
#ifdef __Fuchsia__

void ::test_protocols::TransitionalRequestRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::TransitionalRequestRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::TransitionalRequestRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::TransitionalRequestRequest::TransitionalRequestRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::TransitionalRequestRequest::Storage
test_protocols::TransitionalRequestRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.x)};
}
#ifdef __Fuchsia__

void ::test_protocols::TransitionalOneWayRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::TransitionalOneWayRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::TransitionalOneWayRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::TransitionalOneWayRequest::TransitionalOneWayRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::TransitionalOneWayRequest::Storage
test_protocols::TransitionalOneWayRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.x)};
}
#ifdef __Fuchsia__

void ::test_protocols::TransitionalEventRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::TransitionalEventRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::TransitionalEventRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::TransitionalEventRequest::TransitionalEventRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::TransitionalEventRequest::Storage
test_protocols::TransitionalEventRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.x)};
}
#ifdef __Fuchsia__

void ::test_protocols::MethodWithUnionUnionMethodRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::MethodWithUnionUnionMethodRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::MethodWithUnionUnionMethodRequest>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::MethodWithUnionUnionMethodRequest::
    MethodWithUnionUnionMethodRequest(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<::test_protocols::TheUnion>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::MethodWithUnionUnionMethodRequest::Storage
test_protocols::MethodWithUnionUnionMethodRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.u)};
}
#ifdef __Fuchsia__

void ::test_protocols::SyscallProtocolMethodCRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::SyscallProtocolMethodCRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<::test_protocols::SyscallProtocolMethodCRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::SyscallProtocolMethodCRequest::SyscallProtocolMethodCRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

::test_protocols::SyscallProtocolMethodCRequest::Storage
test_protocols::SyscallProtocolMethodCRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.a),
                 ::fidl::internal::NaturalClone(storage_.b)};
}
#ifdef __Fuchsia__

void ::test_protocols::ProtocolEnds::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<::test_protocols::ProtocolEnds,
                                           ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::ProtocolEnds>::Encode(&encoder, this,
                                                               offset);
}

::test_protocols::ProtocolEnds::ProtocolEnds(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
                    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>>(
                    &decoder, 0),
                ::fidl::DecodeAs<
                    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>>(
                    &decoder, 4),
                ::fidl::DecodeAs<
                    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>>(
                    &decoder, 8),
                ::fidl::DecodeAs<
                    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>>(
                    &decoder, 12)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse,
          ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithProtocolEndsStructContainingEndsTopResponse::
    WithProtocolEndsStructContainingEndsTopResponse(::fidl::Decoder& decoder)
    : storage_(
          {::fidl::DecodeAs<::test_protocols::ProtocolEnds>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::WithProtocolEndsStructContainingEndsRequest::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithProtocolEndsStructContainingEndsRequest,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest>::
      Encode(&encoder, this, offset);
}

::test_protocols::WithProtocolEndsStructContainingEndsRequest::
    WithProtocolEndsStructContainingEndsRequest(::fidl::Decoder& decoder)
    : storage_(
          {::fidl::DecodeAs<::test_protocols::ProtocolEnds>(&decoder, 0)}) {}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::test_protocols::ManyParametersFifteenRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::ManyParametersFifteenRequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::ManyParametersFifteenRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ManyParametersFifteenRequest::ManyParametersFifteenRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<bool>(&decoder, 0),
                ::fidl::DecodeAs<bool>(&decoder, 1),
                ::fidl::DecodeAs<bool>(&decoder, 2),
                ::fidl::DecodeAs<bool>(&decoder, 3),
                ::fidl::DecodeAs<bool>(&decoder, 4),
                ::fidl::DecodeAs<bool>(&decoder, 5),
                ::fidl::DecodeAs<bool>(&decoder, 6),
                ::fidl::DecodeAs<bool>(&decoder, 7),
                ::fidl::DecodeAs<bool>(&decoder, 8),
                ::fidl::DecodeAs<bool>(&decoder, 9),
                ::fidl::DecodeAs<bool>(&decoder, 10),
                ::fidl::DecodeAs<bool>(&decoder, 11),
                ::fidl::DecodeAs<bool>(&decoder, 12),
                ::fidl::DecodeAs<bool>(&decoder, 13),
                ::fidl::DecodeAs<bool>(&decoder, 14)}) {}
#endif  // __Fuchsia__

::test_protocols::ManyParametersFifteenRequest::Storage
test_protocols::ManyParametersFifteenRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.p1),
                 ::fidl::internal::NaturalClone(storage_.p2),
                 ::fidl::internal::NaturalClone(storage_.p3),
                 ::fidl::internal::NaturalClone(storage_.p4),
                 ::fidl::internal::NaturalClone(storage_.p5),
                 ::fidl::internal::NaturalClone(storage_.p6),
                 ::fidl::internal::NaturalClone(storage_.p7),
                 ::fidl::internal::NaturalClone(storage_.p8),
                 ::fidl::internal::NaturalClone(storage_.p9),
                 ::fidl::internal::NaturalClone(storage_.p10),
                 ::fidl::internal::NaturalClone(storage_.p11),
                 ::fidl::internal::NaturalClone(storage_.p12),
                 ::fidl::internal::NaturalClone(storage_.p13),
                 ::fidl::internal::NaturalClone(storage_.p14),
                 ::fidl::internal::NaturalClone(storage_.p15)};
}
#ifdef __Fuchsia__

void ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(::fidl::EncodingInlineSize<
                ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse,
                ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<
      ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>::Encode(&encoder,
                                                                       this,
                                                                       offset);
}

::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse::
    WithErrorSyntaxErrorAsEnumTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<
          ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>(&decoder, 0)}) {
}
#endif  // __Fuchsia__

::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse::Storage
test_protocols::WithErrorSyntaxErrorAsEnumTopResponse::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.result)};
}
#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMethodBTopResponse::
    EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolMethodBTopResponse, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<
      ::test_protocols::ChannelProtocolMethodBTopResponse>::Encode(&encoder,
                                                                   this,
                                                                   offset);
}

::test_protocols::ChannelProtocolMethodBTopResponse::
    ChannelProtocolMethodBTopResponse(::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0)}) {}
#endif  // __Fuchsia__

::test_protocols::ChannelProtocolMethodBTopResponse::Storage
test_protocols::ChannelProtocolMethodBTopResponse::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.result)};
}
#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMethodBRequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolMethodBRequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<::test_protocols::ChannelProtocolMethodBRequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ChannelProtocolMethodBRequest::ChannelProtocolMethodBRequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

::test_protocols::ChannelProtocolMethodBRequest::Storage
test_protocols::ChannelProtocolMethodBRequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.a),
                 ::fidl::internal::NaturalClone(storage_.b)};
}
#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolMethodARequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<
          ::test_protocols::ChannelProtocolMethodARequest, ::fidl::Encoder>(
          &encoder));
  ::fidl::CodingTraits<::test_protocols::ChannelProtocolMethodARequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ChannelProtocolMethodARequest::ChannelProtocolMethodARequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

::test_protocols::ChannelProtocolMethodARequest::Storage
test_protocols::ChannelProtocolMethodARequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.a),
                 ::fidl::internal::NaturalClone(storage_.b)};
}
#ifdef __Fuchsia__

void ::test_protocols::ChannelProtocolEventARequest::EncodeWithoutValidating(
    ::fidl::Encoder& encoder, size_t offset) {
  encoder.Alloc(
      ::fidl::EncodingInlineSize<::test_protocols::ChannelProtocolEventARequest,
                                 ::fidl::Encoder>(&encoder));
  ::fidl::CodingTraits<::test_protocols::ChannelProtocolEventARequest>::Encode(
      &encoder, this, offset);
}

::test_protocols::ChannelProtocolEventARequest::ChannelProtocolEventARequest(
    ::fidl::Decoder& decoder)
    : storage_({::fidl::DecodeAs<int64_t>(&decoder, 0),
                ::fidl::DecodeAs<int64_t>(&decoder, 8)}) {}
#endif  // __Fuchsia__

::test_protocols::ChannelProtocolEventARequest::Storage
test_protocols::ChannelProtocolEventARequest::CloneStorage() const {
  return Storage{::fidl::internal::NaturalClone(storage_.a),
                 ::fidl::internal::NaturalClone(storage_.b)};
}

std::shared_ptr<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Storage>
test_protocols::WithErrorSyntax_ResponseAsStruct_Result::CloneStorage() const {
  const Storage& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage>();
  }
}

std::shared_ptr<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Storage>
test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::CloneStorage() const {
  const Storage& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage>();
  }
}

std::shared_ptr<::test_protocols::TheUnion::Storage>
test_protocols::TheUnion::CloneStorage() const {
  const Storage& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    default:
      return std::make_shared<Storage>();
  }
}

std::shared_ptr<::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Storage>
test_protocols::WithErrorSyntax_ErrorAsEnum_Result::CloneStorage() const {
  const Storage& storage = *storage_;
  switch (storage_->index()) {
    case 1:
      return std::make_shared<Storage>(
          std::in_place_index<1>,
          ::fidl::internal::NaturalClone(std::get<1>(storage)));
    case 2:
      return std::make_shared<Storage>(
          std::in_place_index<2>,
          ::fidl::internal::NaturalClone(std::get<2>(storage)));
    default:
      return std::make_shared<Storage>();
  }
}
