// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.anonymous/cpp/common_types.h>
#include <fidl/test.anonymous/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/internal/codable_base.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>

#endif  // __Fuchsia__

namespace test_anonymous {
class TableData;

class SomeProtocolSomeMethodRequest;

class OverrideTest;

class SomeProtocol_SomeMethod_Response;

class SomeProtocolSomeMethodTopResponse;

class TableMember;

class FunctionApplication;

class UnionMember;

class Expression;

class SomeProtocol_SomeMethod_Result;

extern "C" const fidl_type_t test_anonymous_UnionMemberTable;

class UnionMember final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kUnionData = 2,  // 0x2
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

 private:
  using Storage = cpp17::variant<cpp17::monostate, uint8_t>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_anonymous::UnionMember>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 2>
      Members = {std::nullopt, std::nullopt};

  explicit UnionMember(std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_anonymous::UnionMember::Tag tag) {
    switch (tag) {
      case ::test_anonymous::UnionMember::Tag::kUnionData:
        return 1;
      case ::test_anonymous::UnionMember::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_anonymous::UnionMember::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_anonymous::UnionMember::Tag::kUnionData;
      default:
        return ::test_anonymous::UnionMember::Tag::kUnknown;
    }
  }

 public:
  // Create an unknown value of this union.
  UnionMember() : storage_(std::make_shared<Storage>()) {}

  UnionMember(UnionMember&&) noexcept = default;
  UnionMember& operator=(UnionMember&&) noexcept = default;
  UnionMember(const UnionMember& other) noexcept
      : UnionMember(other.CloneStorage()) {}
  UnionMember& operator=(const UnionMember& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_anonymous::UnionMember::Tag Which() const {
    return UnionMember::IndexToTag(storage_->index());
  }
  static UnionMember WithUnionData(uint8_t val) {
    return UnionMember(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_anonymous::UnionMember::Tag::kUnionData)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> union_data() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> union_data() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
};

extern "C" const fidl_type_t test_anonymous_TableDataTable;

class TableData final : public ::fidl::internal::CodableBase<TableData> {
 private:
  friend ::fidl::internal::CodableBase<TableData>;
  friend ::fidl::CodingTraits<TableData>;
  TableData(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t data{};
  };

  TableData(Storage storage) noexcept : storage_(std::move(storage)) {}
  TableData(uint8_t data) noexcept : storage_({.data = std::move(data)}) {}
  TableData() : TableData(Storage{}) {}

  TableData(TableData&&) noexcept = default;
  TableData& operator=(TableData&&) noexcept = default;
  TableData(const TableData& other) noexcept
      : TableData(other.CloneStorage()) {}
  TableData& operator=(const TableData& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t data() const { return storage_.data; }

  uint8_t& data() { return storage_.data; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_anonymous_TableMemberTable;

class TableMember final {
 public:
  struct Storage final {
    ::cpp17::optional<::std::vector<::test_anonymous::TableData>> table_data{};
  };

  TableMember(Storage storage) noexcept : storage_(std::move(storage)) {}
  TableMember() noexcept = default;
  TableMember(TableMember&&) noexcept = default;
  TableMember& operator=(TableMember&&) noexcept = default;
  TableMember(const TableMember& other) noexcept
      : TableMember(other.CloneStorage()) {}
  TableMember& operator=(const TableMember& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  bool IsEmpty() const { return !(storage_.table_data.has_value()); }

  size_t MaxOrdinal() const;

  const cpp17::optional<::std::vector<::test_anonymous::TableData>>&
  table_data() const {
    return storage_.table_data;
  }
  ::cpp17::optional<::std::vector<::test_anonymous::TableData>>& table_data() {
    return storage_.table_data;
  }

 private:
  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage storage_;
  Storage CloneStorage() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<
      ::test_anonymous::TableMember>;
  static constexpr auto Members =
      std::make_tuple(std::make_tuple(2, &Storage::table_data, std::nullopt));
};

extern "C" const fidl_type_t test_anonymous_SomeProtocolSomeMethodRequestTable;

class SomeProtocolSomeMethodRequest final
    : public ::fidl::internal::CodableBase<SomeProtocolSomeMethodRequest> {
 private:
  friend ::fidl::internal::CodableBase<SomeProtocolSomeMethodRequest>;
  friend ::fidl::CodingTraits<SomeProtocolSomeMethodRequest>;
  SomeProtocolSomeMethodRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_anonymous::UnionMember union_member{};
    ::test_anonymous::TableMember table_member{};
  };

  SomeProtocolSomeMethodRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  SomeProtocolSomeMethodRequest(
      ::test_anonymous::UnionMember union_member,
      ::test_anonymous::TableMember table_member) noexcept
      : storage_({.union_member = std::move(union_member),
                  .table_member = std::move(table_member)}) {}
  SomeProtocolSomeMethodRequest() : SomeProtocolSomeMethodRequest(Storage{}) {}

  SomeProtocolSomeMethodRequest(SomeProtocolSomeMethodRequest&&) noexcept =
      default;
  SomeProtocolSomeMethodRequest& operator=(
      SomeProtocolSomeMethodRequest&&) noexcept = default;
  SomeProtocolSomeMethodRequest(
      const SomeProtocolSomeMethodRequest& other) noexcept
      : SomeProtocolSomeMethodRequest(other.CloneStorage()) {}
  SomeProtocolSomeMethodRequest& operator=(
      const SomeProtocolSomeMethodRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::test_anonymous::UnionMember& union_member() const {
    return storage_.union_member;
  }

  ::test_anonymous::UnionMember& union_member() {
    return storage_.union_member;
  }

  const ::test_anonymous::TableMember& table_member() const {
    return storage_.table_member;
  }

  ::test_anonymous::TableMember& table_member() {
    return storage_.table_member;
  }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_anonymous_OverrideTestTable;

class OverrideTest final : public ::fidl::internal::CodableBase<OverrideTest> {
 private:
  friend ::fidl::internal::CodableBase<OverrideTest>;
  friend ::fidl::CodingTraits<OverrideTest>;
  OverrideTest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_anonymous::Op op{};
    ::std::unique_ptr<::test_anonymous::Expression> left{};
    ::std::unique_ptr<::test_anonymous::Expression> right{};
  };

  OverrideTest(Storage storage) noexcept : storage_(std::move(storage)) {}
  OverrideTest(::test_anonymous::Op op,
               ::std::unique_ptr<::test_anonymous::Expression> left,
               ::std::unique_ptr<::test_anonymous::Expression> right) noexcept
      : storage_({.op = std::move(op),
                  .left = std::move(left),
                  .right = std::move(right)}) {}
  OverrideTest() : OverrideTest(Storage{}) {}

  OverrideTest(OverrideTest&&) noexcept = default;
  OverrideTest& operator=(OverrideTest&&) noexcept = default;
  OverrideTest(const OverrideTest& other) noexcept
      : OverrideTest(other.CloneStorage()) {}
  OverrideTest& operator=(const OverrideTest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  ::test_anonymous::Op op() const { return storage_.op; }

  ::test_anonymous::Op& op() { return storage_.op; }

  const ::std::unique_ptr<::test_anonymous::Expression>& left() const {
    return storage_.left;
  }

  ::std::unique_ptr<::test_anonymous::Expression>& left() {
    return storage_.left;
  }

  const ::std::unique_ptr<::test_anonymous::Expression>& right() const {
    return storage_.right;
  }

  ::std::unique_ptr<::test_anonymous::Expression>& right() {
    return storage_.right;
  }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_anonymous_FunctionApplicationTable;

class FunctionApplication final {
 public:
  struct Storage final {
    ::cpp17::optional<::std::string> func{};
    ::cpp17::optional<
        ::std::vector<::std::unique_ptr<::test_anonymous::Expression>>>
        args{};
    ::cpp17::optional<::test_anonymous::Flags> flags{};
  };

  FunctionApplication(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  FunctionApplication() noexcept = default;
  FunctionApplication(FunctionApplication&&) noexcept = default;
  FunctionApplication& operator=(FunctionApplication&&) noexcept = default;
  FunctionApplication(const FunctionApplication& other) noexcept
      : FunctionApplication(other.CloneStorage()) {}
  FunctionApplication& operator=(const FunctionApplication& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  bool IsEmpty() const {
    return !(storage_.func.has_value() || storage_.args.has_value() ||
             storage_.flags.has_value());
  }

  size_t MaxOrdinal() const;

  const cpp17::optional<::std::string>& func() const { return storage_.func; }
  ::cpp17::optional<::std::string>& func() { return storage_.func; }

  const cpp17::optional<
      ::std::vector<::std::unique_ptr<::test_anonymous::Expression>>>&
  args() const {
    return storage_.args;
  }
  ::cpp17::optional<
      ::std::vector<::std::unique_ptr<::test_anonymous::Expression>>>&
  args() {
    return storage_.args;
  }

  const cpp17::optional<::test_anonymous::Flags>& flags() const {
    return storage_.flags;
  }
  ::cpp17::optional<::test_anonymous::Flags>& flags() { return storage_.flags; }

 private:
  // TODO(https://fxbug.dev/91252): Box the storage.
  Storage storage_;
  Storage CloneStorage() const;
  friend struct ::fidl::internal::NaturalTableCodingTraits<
      ::test_anonymous::FunctionApplication>;
  static constexpr auto Members =
      std::make_tuple(std::make_tuple(1, &Storage::func, std::nullopt),
                      std::make_tuple(3, &Storage::args, std::nullopt),
                      std::make_tuple(4, &Storage::flags, std::nullopt));
};

extern "C" const fidl_type_t test_anonymous_ExpressionTable;

class Expression final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kValue = 1,                // 0x1
    kBinOp = 2,                // 0x2
    kFunctionApplication = 3,  // 0x3
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

 private:
  using Storage =
      cpp17::variant<cpp17::monostate, uint64_t, ::test_anonymous::OverrideTest,
                     ::test_anonymous::FunctionApplication>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_anonymous::Expression>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 4>
      Members = {std::nullopt, std::nullopt, std::nullopt, std::nullopt};

  explicit Expression(std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_anonymous::Expression::Tag tag) {
    switch (tag) {
      case ::test_anonymous::Expression::Tag::kValue:
        return 1;
      case ::test_anonymous::Expression::Tag::kBinOp:
        return 2;
      case ::test_anonymous::Expression::Tag::kFunctionApplication:
        return 3;
      case ::test_anonymous::Expression::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_anonymous::Expression::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_anonymous::Expression::Tag::kValue;
      case 2:
        return ::test_anonymous::Expression::Tag::kBinOp;
      case 3:
        return ::test_anonymous::Expression::Tag::kFunctionApplication;
      default:
        return ::test_anonymous::Expression::Tag::kUnknown;
    }
  }

 public:
  // Create an unknown value of this union.
  Expression() : storage_(std::make_shared<Storage>()) {}

  Expression(Expression&&) noexcept = default;
  Expression& operator=(Expression&&) noexcept = default;
  Expression(const Expression& other) noexcept
      : Expression(other.CloneStorage()) {}
  Expression& operator=(const Expression& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_anonymous::Expression::Tag Which() const {
    return Expression::IndexToTag(storage_->index());
  }
  static Expression WithValue(uint64_t val) {
    return Expression(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_anonymous::Expression::Tag::kValue)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> value() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> value() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  static Expression WithBinOp(::test_anonymous::OverrideTest val) {
    return Expression(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_anonymous::Expression::Tag::kBinOp)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage> bin_op() const {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage> bin_op() {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  static Expression WithFunctionApplication(
      ::test_anonymous::FunctionApplication val) {
    return Expression(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_anonymous::Expression::Tag::kFunctionApplication)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<3, Storage> function_application()
      const {
    return ::fidl::internal::UnionMemberView<3, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<3, Storage> function_application() {
    return ::fidl::internal::UnionMemberView<3, Storage>(storage_);
  }
};

extern "C" const fidl_type_t
    test_anonymous_SomeProtocol_SomeMethod_ResponseTable;

class SomeProtocol_SomeMethod_Response final
    : public ::fidl::internal::CodableBase<SomeProtocol_SomeMethod_Response> {
 private:
  friend ::fidl::internal::CodableBase<SomeProtocol_SomeMethod_Response>;
  friend ::fidl::CodingTraits<SomeProtocol_SomeMethod_Response>;
  SomeProtocol_SomeMethod_Response(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_anonymous::BitsMember bits_member{};
  };

  SomeProtocol_SomeMethod_Response(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  SomeProtocol_SomeMethod_Response(
      ::test_anonymous::BitsMember bits_member) noexcept
      : storage_({.bits_member = std::move(bits_member)}) {}
  SomeProtocol_SomeMethod_Response()
      : SomeProtocol_SomeMethod_Response(Storage{}) {}

  SomeProtocol_SomeMethod_Response(
      SomeProtocol_SomeMethod_Response&&) noexcept = default;
  SomeProtocol_SomeMethod_Response& operator=(
      SomeProtocol_SomeMethod_Response&&) noexcept = default;
  SomeProtocol_SomeMethod_Response(
      const SomeProtocol_SomeMethod_Response& other) noexcept
      : SomeProtocol_SomeMethod_Response(other.CloneStorage()) {}
  SomeProtocol_SomeMethod_Response& operator=(
      const SomeProtocol_SomeMethod_Response& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  ::test_anonymous::BitsMember bits_member() const {
    return storage_.bits_member;
  }

  ::test_anonymous::BitsMember& bits_member() { return storage_.bits_member; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_anonymous_SomeProtocol_SomeMethod_ResultTable;

class SomeProtocol_SomeMethod_Result final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

 private:
  using Storage =
      cpp17::variant<cpp17::monostate,
                     ::test_anonymous::SomeProtocol_SomeMethod_Response,
                     ::test_anonymous::SomeProtocol_SomeMethod_Error>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_anonymous::SomeProtocol_SomeMethod_Result>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 3>
      Members = {std::nullopt, std::nullopt, std::nullopt};

  explicit SomeProtocol_SomeMethod_Result(std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag tag) {
    switch (tag) {
      case ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse:
        return 1;
      case ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag
  IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse;
      case 2:
        return ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::kResponse;
    }
  }

 public:
  // Create an unknown value of this union.
  SomeProtocol_SomeMethod_Result() : storage_(std::make_shared<Storage>()) {}

  SomeProtocol_SomeMethod_Result(SomeProtocol_SomeMethod_Result&&) noexcept =
      default;
  SomeProtocol_SomeMethod_Result& operator=(
      SomeProtocol_SomeMethod_Result&&) noexcept = default;
  SomeProtocol_SomeMethod_Result(
      const SomeProtocol_SomeMethod_Result& other) noexcept
      : SomeProtocol_SomeMethod_Result(other.CloneStorage()) {}
  SomeProtocol_SomeMethod_Result& operator=(
      const SomeProtocol_SomeMethod_Result& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag Which()
      const {
    return SomeProtocol_SomeMethod_Result::IndexToTag(storage_->index());
  }
  static SomeProtocol_SomeMethod_Result WithResponse(
      ::test_anonymous::SomeProtocol_SomeMethod_Response val) {
    return SomeProtocol_SomeMethod_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::
                kResponse)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> response() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  static SomeProtocol_SomeMethod_Result WithErr(
      ::test_anonymous::SomeProtocol_SomeMethod_Error val) {
    return SomeProtocol_SomeMethod_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_anonymous::SomeProtocol_SomeMethod_Result::Tag::kErr)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage> err() {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
};

extern "C" const fidl_type_t
    test_anonymous_SomeProtocolSomeMethodTopResponseTable;

class SomeProtocolSomeMethodTopResponse final
    : public ::fidl::internal::CodableBase<SomeProtocolSomeMethodTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<SomeProtocolSomeMethodTopResponse>;
  friend ::fidl::CodingTraits<SomeProtocolSomeMethodTopResponse>;
  SomeProtocolSomeMethodTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_anonymous::SomeProtocol_SomeMethod_Result result{};
  };

  SomeProtocolSomeMethodTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  SomeProtocolSomeMethodTopResponse(
      ::test_anonymous::SomeProtocol_SomeMethod_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  SomeProtocolSomeMethodTopResponse()
      : SomeProtocolSomeMethodTopResponse(Storage{}) {}

  SomeProtocolSomeMethodTopResponse(
      SomeProtocolSomeMethodTopResponse&&) noexcept = default;
  SomeProtocolSomeMethodTopResponse& operator=(
      SomeProtocolSomeMethodTopResponse&&) noexcept = default;
  SomeProtocolSomeMethodTopResponse(
      const SomeProtocolSomeMethodTopResponse& other) noexcept
      : SomeProtocolSomeMethodTopResponse(other.CloneStorage()) {}
  SomeProtocolSomeMethodTopResponse& operator=(
      const SomeProtocolSomeMethodTopResponse& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::test_anonymous::SomeProtocol_SomeMethod_Result& result() const {
    return storage_.result;
  }

  ::test_anonymous::SomeProtocol_SomeMethod_Result& result() {
    return storage_.result;
  }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

}  // namespace test_anonymous
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_anonymous_TableDataTable;

template <>
struct IsFidlType<::test_anonymous::TableData> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_anonymous::TableData> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_TableDataTable;
};

template <>
struct CodingTraits<::test_anonymous::TableData> {
  static constexpr size_t inline_size_v1_no_ee = 1;
  static constexpr size_t inline_size_v2 = 1;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::TableData* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.data, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_anonymous::TableData* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.data, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_anonymous_SomeProtocolSomeMethodRequestTable;

template <>
struct IsFidlType<::test_anonymous::SomeProtocolSomeMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_anonymous::SomeProtocolSomeMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_SomeProtocolSomeMethodRequestTable;
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocolSomeMethodRequest> {
  static constexpr size_t inline_size_v1_no_ee = 40;
  static constexpr size_t inline_size_v2 = 32;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocolSomeMethodRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.union_member,
                   offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 24
                                                                           : 16;
    ::fidl::Encode(encoder, &value->storage_.table_member,
                   offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocolSomeMethodRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.union_member, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.table_member, offset + 16);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_anonymous_OverrideTestTable;

template <>
struct IsFidlType<::test_anonymous::OverrideTest> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_anonymous::OverrideTest> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_OverrideTestTable;
};

template <>
struct CodingTraits<::test_anonymous::OverrideTest> {
  static constexpr size_t inline_size_v1_no_ee = 56;
  static constexpr size_t inline_size_v2 = 40;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::OverrideTest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.op, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.left, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 32
                                                                           : 24;
    ::fidl::Encode(encoder, &value->storage_.right, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::OverrideTest* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.op, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.left, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.right, offset + 24);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_anonymous_SomeProtocol_SomeMethod_ResponseTable;

template <>
struct IsFidlType<::test_anonymous::SomeProtocol_SomeMethod_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_anonymous::SomeProtocol_SomeMethod_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_SomeProtocol_SomeMethod_ResponseTable;
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocol_SomeMethod_Response> {
  static constexpr size_t inline_size_v1_no_ee = 4;
  static constexpr size_t inline_size_v2 = 4;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocol_SomeMethod_Response* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.bits_member,
                   offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocol_SomeMethod_Response* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.bits_member, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_anonymous_SomeProtocolSomeMethodTopResponseTable;

template <>
struct IsFidlType<::test_anonymous::SomeProtocolSomeMethodTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_anonymous::SomeProtocolSomeMethodTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_anonymous_SomeProtocolSomeMethodTopResponseTable;
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocolSomeMethodTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocolSomeMethodTopResponse* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocolSomeMethodTopResponse* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

template <>
struct IsFidlType<::test_anonymous::TableMember> : public std::true_type {};

template <>
struct CodingTraits<::test_anonymous::TableMember>
    : public ::fidl::internal::NaturalTableCodingTraits<
          ::test_anonymous::TableMember> {};

template <>
struct IsFidlType<::test_anonymous::FunctionApplication>
    : public std::true_type {};

template <>
struct CodingTraits<::test_anonymous::FunctionApplication>
    : public ::fidl::internal::NaturalTableCodingTraits<
          ::test_anonymous::FunctionApplication> {};

template <>
struct IsFidlType<::test_anonymous::UnionMember> : public std::true_type {};

template <>
struct CodingTraits<::test_anonymous::UnionMember> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_anonymous::UnionMember> {};

template <>
struct IsFidlType<::test_anonymous::Expression> : public std::true_type {};

template <>
struct CodingTraits<::test_anonymous::Expression> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_anonymous::Expression> {};

template <>
struct IsFidlType<::test_anonymous::SomeProtocol_SomeMethod_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test_anonymous::SomeProtocol_SomeMethod_Result> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_anonymous::SomeProtocol_SomeMethod_Result> {};

template <>
struct CodingTraits<::test_anonymous::Flags> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint16_t);
  static constexpr size_t inline_size_v2 = sizeof(uint16_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::Flags* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_anonymous::Flags* value,
                     size_t offset) {
    // TODO: decode
  }
};
template <>
struct CodingTraits<::test_anonymous::BitsMember> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::BitsMember* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_anonymous::BitsMember* value,
                     size_t offset) {
    // TODO: decode
  }
};

template <>
struct CodingTraits<::test_anonymous::SomeProtocol_SomeMethod_Error> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_anonymous::SomeProtocol_SomeMethod_Error* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_anonymous::SomeProtocol_SomeMethod_Error* value,
                     size_t offset) {
    // TODO: decode
  }
};
template <>
struct CodingTraits<::test_anonymous::Op> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_anonymous::Op* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_anonymous::Op* value,
                     size_t offset) {
    // TODO: decode
  }
};

}  // namespace fidl
