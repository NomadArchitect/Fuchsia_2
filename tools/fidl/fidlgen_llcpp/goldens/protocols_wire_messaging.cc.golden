// WARNING: This file is machine generated by fidlgen.

#include <fidl/test.protocols/cpp/wire_messaging.h>

#include <memory>

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal =
        5413654872775949227lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_NoRequestNoResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal =
        1631193469798418024lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal =
        9037369643591427517lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal =
        7326057319832554103lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal =
        2877322062572412767lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal =
        6417226585456833969lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal =
        5397663296507358806lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_OnEmptyResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

[[maybe_unused]] constexpr uint64_t
    kWithAndWithoutRequestResponse_OnWithResponse_Ordinal =
        5811598563493228968lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestNoResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestNoResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestEmptyResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestEmptyResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestEmptyResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestWithResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       NoRequestWithResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              NoRequestWithResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestNoResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestNoResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestEmptyResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>(client.handle(), bytes_.data(),
                                     static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestEmptyResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>(client.handle(), bytes_.data(),
                                     static_cast<uint32_t>(bytes_.size()),
                                     fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestEmptyResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>>(client_end.handle(), response_bytes,
                                     response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestWithResponse>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>(client.handle(), bytes_.data(),
                                    static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    WireResult(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                   client,
               ::fidl::internal::TransactionalRequest<
                   ::test_protocols::WithAndWithoutRequestResponse::
                       WithRequestWithResponse>* request,
               zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>(client.handle(), bytes_.data(),
                                    static_cast<uint32_t>(bytes_.size()),
                                    fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    WireUnownedResult(::fidl::UnownedClientEnd<
                          ::test_protocols::WithAndWithoutRequestResponse>
                          client_end,
                      ::fidl::internal::AnyBufferAllocator& allocator,
                      ::fidl::internal::TransactionalRequest<
                          ::test_protocols::WithAndWithoutRequestResponse::
                              WithRequestWithResponse>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>>(client_end.handle(), response_bytes,
                                    response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
      _request_object{};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(::fidl::StringView arg) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
      _request_object{arg};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

::fidl::internal::WireThenable<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _request{};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _request{};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(::fidl::StringView arg) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _request{arg};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>{_client_base(), ::fidl::WriteOptions{},
                                    ::fidl::internal::AllowUnownedInputRef{},
                                    &_request};
}

::fidl::internal::WireThenable<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(::fidl::StringView arg) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _request{arg};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestNoResponse() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestNoResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>
      _request{arg};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestNoResponse>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _request{};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _request{};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _request{arg};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>{_client_base(), ::fidl::WriteOptions{},
                                    _allocator(), _buffer_size, &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(::fidl::StringView arg) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _request{arg};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestEmptyResponse() {
  return _client_base()->MakeSyncCallWith([&](std::shared_ptr<
                                              ::fidl::internal::AnyTransport>
                                                  _transport) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
        _request{};
    return ::fidl::WireResult<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>(
        ::fidl::UnownedClientEnd<
            ::test_protocols::WithAndWithoutRequestResponse>(
            _transport->get<::fidl::internal::ChannelTransport>()),
        &_request);
  });
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::NoRequestWithResponse() {
  return _client_base()->MakeSyncCallWith([&](std::shared_ptr<
                                              ::fidl::internal::AnyTransport>
                                                  _transport) {
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
        _request{};
    return ::fidl::WireResult<
        ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>(
        ::fidl::UnownedClientEnd<
            ::test_protocols::WithAndWithoutRequestResponse>(
            _transport->get<::fidl::internal::ChannelTransport>()),
        &_request);
  });
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestEmptyResponse(::fidl::StringView arg) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>
            _request{arg};
        return ::fidl::WireResult<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestEmptyResponse>(
            ::fidl::UnownedClientEnd<
                ::test_protocols::WithAndWithoutRequestResponse>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithAndWithoutRequestResponse>::
    WithRequestWithResponse(::fidl::StringView arg) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>
            _request{arg};
        return ::fidl::WireResult<
            ::test_protocols::WithAndWithoutRequestResponse::
                WithRequestWithResponse>(
            ::fidl::UnownedClientEnd<
                ::test_protocols::WithAndWithoutRequestResponse>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::WithAndWithoutRequestResponse>::
    HandleOneEvent(::fidl::UnownedClientEnd<
                   ::test_protocols::WithAndWithoutRequestResponse>
                       client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::
            kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>::
          kMaxNumHandles;
    }
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
            kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>::
          kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::BoxedMessageBuffer<ZX_CHANNEL_MAX_MSG_BYTES> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Status(decoded);
      }
      ::fidl::WireEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
          empty_event;
      auto* primary = &empty_event;
      got_transitional_ = false;
      OnEmptyResponse(primary);
      if (got_transitional_) {
        return ::fidl::Status::UnexpectedMessage(
            ZX_ERR_NOT_SUPPORTED,
            ::fidl::internal::kErrorSyncEventUnhandledTransitionalEvent);
      }
      return ::fidl::Status::Ok();
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Status(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      got_transitional_ = false;
      OnWithResponse(primary);
      if (got_transitional_) {
        return ::fidl::Status::UnexpectedMessage(
            ZX_ERR_NOT_SUPPORTED,
            ::fidl::internal::kErrorSyncEventUnhandledTransitionalEvent);
      }
      return ::fidl::Status::Ok();
    }
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::WireEventDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        ::fidl::WireEvent<
            ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
            empty_event;
        auto* primary = &empty_event;
        event_handler()->OnEmptyResponse(primary);
      }
      return std::nullopt;
    }
    case ::test_protocols::
        kWithAndWithoutRequestResponse_OnWithResponse_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->OnWithResponse(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_[] = {
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestNoResponse>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestNoResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->NoRequestNoResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestEmptyResponse>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestEmptyResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->NoRequestEmptyResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithAndWithoutRequestResponse::
                                  NoRequestWithResponse>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  NoRequestWithResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->NoRequestWithResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestNoResponse>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestNoResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->WithRequestNoResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestEmptyResponse>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestEmptyResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->WithRequestEmptyResponse(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::
            kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithAndWithoutRequestResponse::
                      WithRequestWithResponse>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithAndWithoutRequestResponse::
                  WithRequestWithResponse>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<
              ::test_protocols::WithAndWithoutRequestResponse>*>(interface)
              ->WithRequestWithResponse(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::entries_end_ =
    &entries_[6];

::fidl::DispatchResult fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    TryDispatch(::fidl::WireServer<
                    ::test_protocols::WithAndWithoutRequestResponse>* impl,
                ::fidl::IncomingMessage& msg,
                internal::IncomingTransportContext transport_context,
                ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<
    ::test_protocols::WithAndWithoutRequestResponse>::
    Dispatch(::fidl::WireServer<
                 ::test_protocols::WithAndWithoutRequestResponse>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::WithAndWithoutRequestResponse>::
    dispatch_message(
        ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
        ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::WithAndWithoutRequestResponse>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>
      _response{};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          NoRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>
      _response{ret};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              NoRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>
      _response{};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    Reply(::fidl::StringView ret) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>
      _response{ret};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::
          WithRequestWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithAndWithoutRequestResponse::
              WithRequestWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestNoResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestNoResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestEmptyResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestEmptyResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::NoRequestWithResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_NoRequestWithResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestNoResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestNoResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestEmptyResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestEmptyResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithAndWithoutRequestResponse::WithRequestWithResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_WithRequestWithResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kWithAndWithoutRequestResponse_OnEmptyResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_OnEmptyResponse_DynamicFlags);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>::
    _InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kWithAndWithoutRequestResponse_OnWithResponse_Ordinal,
      ::test_protocols::
          kWithAndWithoutRequestResponse_OnWithResponse_DynamicFlags);
}

#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::OnEmptyResponse() {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>
      _response{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnEmptyResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireWeakEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<
    ::test_protocols::WithAndWithoutRequestResponse>::
    OnWithResponse(::fidl::StringView ret) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>
      _response{ret};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::WithAndWithoutRequestResponse::OnWithResponse>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kTransitional_Request_Ordinal =
    5849263021838298888lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kTransitional_Request_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

[[maybe_unused]] constexpr uint64_t kTransitional_OneWay_Ordinal =
    4336658926562441191lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kTransitional_OneWay_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

[[maybe_unused]] constexpr uint64_t kTransitional_Event_Ordinal =
    8507647465196374081lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kTransitional_Event_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::Transitional::Request>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::Request>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::Transitional::Request>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::Request>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::Transitional::Request>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::Transitional::Request>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::Transitional::Request>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity =
      ::fidl::MaxSizeInChannel<::fidl::internal::TransactionalRequest<
                                   ::test_protocols::Transitional::Request>,
                               ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::Request>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::Transitional::OneWay>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::Transitional::OneWay>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::Transitional::OneWay>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::Transitional::OneWay>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::Transitional::OneWay>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::Transitional>::OneWay(int64_t x) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>
      _request_object{x};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

::fidl::internal::WireThenable<::test_protocols::Transitional::Request>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::Transitional>::Request(int64_t x) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::Transitional::Request>
      _request{x};
  return ::fidl::internal::WireThenable<
      ::test_protocols::Transitional::Request>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::Transitional>::OneWay(int64_t x) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::Transitional::OneWay>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<::test_protocols::Transitional::OneWay>
      _request{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::Transitional::OneWay>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::Transitional::Request>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::Transitional>::Request(int64_t x) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::Transitional::Request>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::Transitional::Request>
      _request{x};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::Transitional::Request>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}

::fidl::WireResult<::test_protocols::Transitional::Request>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::Transitional>::Request(
    int64_t x) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::Transitional::Request>
            _request{x};
        return ::fidl::WireResult<::test_protocols::Transitional::Request>(
            ::fidl::UnownedClientEnd<::test_protocols::Transitional>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::Transitional>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::Transitional> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::Transitional::Event>>::kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>>::kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<24> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Status(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      got_transitional_ = false;
      Event(primary);
      if (got_transitional_) {
        return ::fidl::Status::UnexpectedMessage(
            ZX_ERR_NOT_SUPPORTED,
            ::fidl::internal::kErrorSyncEventUnhandledTransitionalEvent);
      }
      return ::fidl::Status::Ok();
    }
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::Transitional>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kTransitional_Event_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->Event(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::Transitional>::entries_[] = {
    {
        ::test_protocols::kTransitional_Request_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::Transitional::Request>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::Transitional::Request>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<::test_protocols::Transitional>*>(
              interface)
              ->Request(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kTransitional_OneWay_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::Transitional::OneWay>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::Transitional::OneWay>::Sync completer(txn);
          reinterpret_cast<::fidl::WireServer<::test_protocols::Transitional>*>(
              interface)
              ->OneWay(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::Transitional>::entries_end_ = &entries_[2];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::Transitional>::TryDispatch(
        ::fidl::WireServer<::test_protocols::Transitional>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::Transitional>::
    Dispatch(::fidl::WireServer<::test_protocols::Transitional>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::Transitional>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::Transitional>::Dispatch(this, std::move(msg),
                                                std::move(transport_context),
                                                txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::Transitional::Request>::Reply(int64_t y) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>
      _response{y};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::Transitional::Request>::Reply(int64_t y) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::Transitional::Request>
      _response{y};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::Transitional::Request>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::Transitional::Request>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::Request>::_InitHeader() {
  ::fidl::InitTxnHeader(&header, 0,
                        ::test_protocols::kTransitional_Request_Ordinal,
                        ::test_protocols::kTransitional_Request_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::Transitional::Request>::_InitHeader() {
  ::fidl::InitTxnHeader(&header, 0,
                        ::test_protocols::kTransitional_Request_Ordinal,
                        ::test_protocols::kTransitional_Request_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::Transitional::OneWay>::_InitHeader() {
  ::fidl::InitTxnHeader(&header, 0,
                        ::test_protocols::kTransitional_OneWay_Ordinal,
                        ::test_protocols::kTransitional_OneWay_DynamicFlags);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::Transitional::Event>::_InitHeader() {
  ::fidl::InitTxnHeader(&header, 0,
                        ::test_protocols::kTransitional_Event_Ordinal,
                        ::test_protocols::kTransitional_Event_DynamicFlags);
}

#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::Transitional::Event>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<
    ::test_protocols::Transitional>::Event(int64_t x) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::Transitional::Event>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<::test_protocols::Transitional::Event>
      _response{x};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::Transitional::Event>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kMethodWithUnion_UnionMethod_Ordinal =
    4124874338266649112lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kMethodWithUnion_UnionMethod_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::MethodWithUnion::UnionMethod>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::MethodWithUnion::UnionMethod>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::MethodWithUnion::UnionMethod>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::MethodWithUnion::UnionMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::MethodWithUnion::UnionMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::
    WireWeakOnewayClientImpl<::test_protocols::MethodWithUnion>::UnionMethod(
        ::test_protocols::wire::TheUnion u) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::MethodWithUnion::UnionMethod>
      _request_object{u};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::MethodWithUnion>::
    UnionMethod(::test_protocols::wire::TheUnion u) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::MethodWithUnion::UnionMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::MethodWithUnion::UnionMethod>
      _request{u};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::MethodWithUnion::UnionMethod>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::MethodWithUnion>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::MethodWithUnion> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<16> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::MethodWithUnion>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_[] = {
    {
        ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::MethodWithUnion::UnionMethod>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::MethodWithUnion::UnionMethod>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::MethodWithUnion>*>(interface)
              ->UnionMethod(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::MethodWithUnion>::entries_end_ = &entries_[1];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::MethodWithUnion>::TryDispatch(
        ::fidl::WireServer<::test_protocols::MethodWithUnion>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::MethodWithUnion>::
    Dispatch(::fidl::WireServer<::test_protocols::MethodWithUnion>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::MethodWithUnion>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::MethodWithUnion>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::MethodWithUnion::UnionMethod>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kMethodWithUnion_UnionMethod_Ordinal,
      ::test_protocols::kMethodWithUnion_UnionMethod_DynamicFlags);
}

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kWithProtocolEnds_ClientEnds_Ordinal =
    5870448041025163330lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithProtocolEnds_ClientEnds_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithProtocolEnds_ServerEnds_Ordinal =
    8115535094437022259lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithProtocolEnds_ServerEnds_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

[[maybe_unused]] constexpr uint64_t
    kWithProtocolEnds_StructContainingEnds_Ordinal = 4076866772260025813lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithProtocolEnds_StructContainingEnds_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ClientEnds>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ClientEnds>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ClientEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ClientEnds>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithProtocolEnds::ServerEnds>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithProtocolEnds::ServerEnds>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ServerEnds>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::ServerEnds>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*
            request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>*
            request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ClientEnds>
fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _request{std::move(in)};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithProtocolEnds::ClientEnds>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<::test_protocols::WithProtocolEnds::ServerEnds>
fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _request{std::move(in)};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithProtocolEnds::ServerEnds>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
fidl::internal::WireWeakAsyncClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _request{std::move(in)};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithProtocolEnds::ClientEnds>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>::
    ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _request{std::move(in)};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithProtocolEnds::ClientEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithProtocolEnds::ServerEnds>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>::
    ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _request{std::move(in)};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithProtocolEnds::ServerEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithProtocolEnds>::
    StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _request{std::move(in)};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ClientEnds>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::
    ClientEnds(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& in) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ClientEnds>
            _request{std::move(in)};
        return ::fidl::WireResult<
            ::test_protocols::WithProtocolEnds::ClientEnds>(
            ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::ServerEnds>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::
    ServerEnds(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& in) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::ServerEnds>
            _request{std::move(in)};
        return ::fidl::WireResult<
            ::test_protocols::WithProtocolEnds::ServerEnds>(
            ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithProtocolEnds::StructContainingEnds>
fidl::internal::WireWeakSyncClientImpl<::test_protocols::WithProtocolEnds>::
    StructContainingEnds(::test_protocols::wire::ProtocolEnds&& in) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>
            _request{std::move(in)};
        return ::fidl::WireResult<
            ::test_protocols::WithProtocolEnds::StructContainingEnds>(
            ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::WithProtocolEnds>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::WithProtocolEnds> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<32> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::WithProtocolEnds>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_[] = {
    {
        ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithProtocolEnds::ClientEnds>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithProtocolEnds::ClientEnds>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ClientEnds(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithProtocolEnds::ServerEnds>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithProtocolEnds::ServerEnds>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->ServerEnds(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::WithProtocolEnds::StructContainingEnds>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithProtocolEnds::StructContainingEnds>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithProtocolEnds>*>(
              interface)
              ->StructContainingEnds(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::WithProtocolEnds>::entries_end_ = &entries_[3];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::WithProtocolEnds>::TryDispatch(
        ::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::
    Dispatch(::fidl::WireServer<::test_protocols::WithProtocolEnds>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::WithProtocolEnds>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<::test_protocols::WithProtocolEnds>::
      Dispatch(this, std::move(msg), std::move(transport_context), txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::
    WireCompleterImpl<::test_protocols::WithProtocolEnds::ClientEnds>::Reply(
        ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _response{std::move(out)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::ClientEnds>::
    Reply(::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ClientEnds>
      _response{std::move(out)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ClientEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ClientEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::
    WireCompleterImpl<::test_protocols::WithProtocolEnds::ServerEnds>::Reply(
        ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _response{std::move(out)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::ServerEnds>::
    Reply(::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::ServerEnds>
      _response{std::move(out)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::ServerEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::ServerEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _response{std::move(out)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::
    Reply(::test_protocols::wire::ProtocolEnds&& out) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>
      _response{std::move(out)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithProtocolEnds::StructContainingEnds>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithProtocolEnds::StructContainingEnds>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ClientEnds>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
      ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ClientEnds>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithProtocolEnds_ClientEnds_Ordinal,
      ::test_protocols::kWithProtocolEnds_ClientEnds_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::ServerEnds>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
      ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::ServerEnds>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithProtocolEnds_ServerEnds_Ordinal,
      ::test_protocols::kWithProtocolEnds_ServerEnds_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithProtocolEnds::StructContainingEnds>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_Ordinal,
      ::test_protocols::kWithProtocolEnds_StructContainingEnds_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kManyParameters_Fifteen_Ordinal =
    6423043252952467815lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kManyParameters_Fifteen_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ManyParameters::Fifteen>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ManyParameters::Fifteen>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ManyParameters::Fifteen>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ManyParameters::Fifteen>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ManyParameters::Fifteen>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3,
                                               bool p4, bool p5, bool p6,
                                               bool p7, bool p8, bool p9,
                                               bool p10, bool p11, bool p12,
                                               bool p13, bool p14, bool p15) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ManyParameters::Fifteen>
      _request_object{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
                      p9, p10, p11, p12, p13, p14, p15};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::ManyParameters>::Fifteen(bool p1, bool p2, bool p3,
                                               bool p4, bool p5, bool p6,
                                               bool p7, bool p8, bool p9,
                                               bool p10, bool p11, bool p12,
                                               bool p13, bool p14, bool p15) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ManyParameters::Fifteen>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ManyParameters::Fifteen>
      _request{p1, p2,  p3,  p4,  p5,  p6,  p7, p8,
               p9, p10, p11, p12, p13, p14, p15};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ManyParameters::Fifteen>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::ManyParameters>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::ManyParameters> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<16> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::ManyParameters>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::ManyParameters>::entries_[] = {
    {
        ::test_protocols::kManyParameters_Fifteen_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ManyParameters::Fifteen>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ManyParameters::Fifteen>::Sync completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ManyParameters>*>(interface)
              ->Fifteen(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::ManyParameters>::entries_end_ = &entries_[1];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::ManyParameters>::TryDispatch(
        ::fidl::WireServer<::test_protocols::ManyParameters>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::ManyParameters>::
    Dispatch(::fidl::WireServer<::test_protocols::ManyParameters>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::ManyParameters>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::ManyParameters>::Dispatch(this, std::move(msg),
                                                  std::move(transport_context),
                                                  txn);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ManyParameters::Fifteen>::_InitHeader() {
  ::fidl::InitTxnHeader(&header, 0,
                        ::test_protocols::kManyParameters_Fifteen_Ordinal,
                        ::test_protocols::kManyParameters_Fifteen_DynamicFlags);
}

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t
    kHandleRightsProtocol_NoResponseMethod_Ordinal = 1155044649514904573lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kHandleRightsProtocol_NoResponseMethod_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

[[maybe_unused]] constexpr uint64_t
    kHandleRightsProtocol_ResponseMethod_Ordinal = 5956276128041940295lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kHandleRightsProtocol_ResponseMethod_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

[[maybe_unused]] constexpr uint64_t kHandleRightsProtocol_AnEvent_Ordinal =
    476727631355490611lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kHandleRightsProtocol_AnEvent_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::HandleRightsProtocol::NoResponseMethod>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::NoResponseMethod>*
            request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
            client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::NoResponseMethod>*
            request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
            client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&&
                                                                  h) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>
      _request_object{std::move(h)};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

::fidl::internal::WireThenable<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _request{std::move(h)};
  return ::fidl::internal::WireThenable<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>::NoResponseMethod(::zx::socket&&
                                                                  h) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::NoResponseMethod>
      _request{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _request{std::move(h)};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}

::fidl::WireResult<::test_protocols::HandleRightsProtocol::ResponseMethod>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::HandleRightsProtocol>::ResponseMethod(::zx::socket&& h) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>
            _request{std::move(h)};
        return ::fidl::WireResult<
            ::test_protocols::HandleRightsProtocol::ResponseMethod>(
            ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::HandleRightsProtocol>::
    HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::HandleRightsProtocol>
            client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::HandleRightsProtocol::AnEvent>>::kMaxNumHandles >=
        x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>>::kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<24> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Status(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      got_transitional_ = false;
      AnEvent(primary);
      if (got_transitional_) {
        return ::fidl::Status::UnexpectedMessage(
            ZX_ERR_NOT_SUPPORTED,
            ::fidl::internal::kErrorSyncEventUnhandledTransitionalEvent);
      }
      return ::fidl::Status::Ok();
    }
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::HandleRightsProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->AnEvent(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_[] = {
    {
        ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::HandleRightsProtocol::NoResponseMethod>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::HandleRightsProtocol::NoResponseMethod>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->NoResponseMethod(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::HandleRightsProtocol::ResponseMethod>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::HandleRightsProtocol::ResponseMethod>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::HandleRightsProtocol>*>(
              interface)
              ->ResponseMethod(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::HandleRightsProtocol>::entries_end_ = &entries_[2];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::HandleRightsProtocol>::TryDispatch(
        ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::
    WireServerDispatcher<::test_protocols::HandleRightsProtocol>::Dispatch(
        ::fidl::WireServer<::test_protocols::HandleRightsProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::HandleRightsProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::HandleRightsProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _response{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::
    Reply(::zx::socket&& h) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>
      _response{std::move(h)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::ResponseMethod>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::HandleRightsProtocol::ResponseMethod>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::NoResponseMethod>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kHandleRightsProtocol_NoResponseMethod_Ordinal,
      ::test_protocols::kHandleRightsProtocol_NoResponseMethod_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::HandleRightsProtocol::ResponseMethod>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_Ordinal,
      ::test_protocols::kHandleRightsProtocol_ResponseMethod_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::HandleRightsProtocol::AnEvent>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kHandleRightsProtocol_AnEvent_Ordinal,
      ::test_protocols::kHandleRightsProtocol_AnEvent_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<
    ::test_protocols::HandleRightsProtocol>::AnEvent(::zx::socket&& h) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::HandleRightsProtocol::AnEvent>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::HandleRightsProtocol::AnEvent>
      _response{std::move(h)};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::HandleRightsProtocol::AnEvent>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ResponseAsStruct_Ordinal =
    268248568430741139lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithErrorSyntax_ResponseAsStruct_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsPrimitive_Ordinal =
    6930994461233198567lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_ErrorAsEnum_Ordinal =
    5491891352371277635lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithErrorSyntax_ErrorAsEnum_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

[[maybe_unused]] constexpr uint64_t kWithErrorSyntax_HandleInResult_Ordinal =
    1371676333068455103lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kWithErrorSyntax_HandleInResult_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok(&(raw_response->result.response()));
    }
  }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok(&(raw_response->result.response()));
    }
  }
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  if (outgoing.ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ResponseAsStruct>*>(
        bytes_ + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok(&(raw_response->result.response()));
    }
  }
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok();
    }
  }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok();
    }
  }
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  if (outgoing.ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>*>(
        bytes_ + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok();
    }
  }
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok();
    }
  }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok();
    }
  }
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  if (outgoing.ok()) {
    auto* raw_response = reinterpret_cast<
        ::fidl::WireResponse<::test_protocols::WithErrorSyntax::ErrorAsEnum>*>(
        bytes_ + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok();
    }
  }
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok(&(raw_response->result.response()));
    }
  }
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>::
    WireResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>* request,
        zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
  if (ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_.data() + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok(&(raw_response->result.response()));
    }
  }
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::WithErrorSyntax::HandleInResult>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::WithErrorSyntax::HandleInResult>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  if (outgoing.ok()) {
    auto* raw_response = reinterpret_cast<::fidl::WireResponse<
        ::test_protocols::WithErrorSyntax::HandleInResult>*>(
        bytes_ + sizeof(fidl_message_header_t));
    if (raw_response->result.is_err()) {
      result_ = fitx::error(raw_response->result.err());
    } else if (raw_response->result.is_response()) {
      result_ = fitx::ok(&(raw_response->result.response()));
    }
  }
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::internal::WireThenable<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _request{};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _request{};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<::test_protocols::WithErrorSyntax::ErrorAsEnum>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _request{};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<
    ::test_protocols::WithErrorSyntax::HandleInResult>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::WithErrorSyntax>::HandleInResult() {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _request{};
  return ::fidl::internal::WireThenable<
      ::test_protocols::WithErrorSyntax::HandleInResult>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _request{};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _request{};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _request{};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::WithErrorSyntax::HandleInResult>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::WithErrorSyntax>::HandleInResult() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _request{};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::WithErrorSyntax::HandleInResult>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ResponseAsStruct>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ResponseAsStruct() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::ResponseAsStruct>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsPrimitive() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::ErrorAsEnum>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::ErrorAsEnum() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::ErrorAsEnum>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::WithErrorSyntax::HandleInResult>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::WithErrorSyntax>::HandleInResult() {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::WithErrorSyntax::HandleInResult>
            _request{};
        return ::fidl::WireResult<
            ::test_protocols::WithErrorSyntax::HandleInResult>(
            ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::WithErrorSyntax>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::WithErrorSyntax> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<64> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::WithErrorSyntax>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_[] = {
    {
        ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::ResponseAsStruct>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->ResponseAsStruct(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->ErrorAsPrimitive(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithErrorSyntax::ErrorAsEnum>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::ErrorAsEnum>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->ErrorAsEnum(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::WithErrorSyntax::HandleInResult>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::WithErrorSyntax::HandleInResult>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::WithErrorSyntax>*>(interface)
              ->HandleInResult(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::WithErrorSyntax>::entries_end_ = &entries_[4];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::WithErrorSyntax>::TryDispatch(
        ::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::WithErrorSyntax>::
    Dispatch(::fidl::WireServer<::test_protocols::WithErrorSyntax>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::WithErrorSyntax>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::WithErrorSyntax>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplySuccess(int64_t a, int64_t b, int64_t c) {
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response =
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse{
          .a = std::move(a),
          .b = std::move(b),
          .c = std::move(c),
      };

  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
          WithResponse(
              ::fidl::ObjectView<::test_protocols::wire::
                                     WithErrorSyntaxResponseAsStructResponse>::
                  FromExternal(&_response)));
}

void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(
          std::move(error)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ResponseAsStruct>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ResponseAsStruct>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplySuccess(int64_t a, int64_t b, int64_t c) {
  ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse _response =
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResponse{
          .a = std::move(a),
          .b = std::move(b),
          .c = std::move(c),
      };

  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::
          WithResponse(
              ::fidl::ObjectView<::test_protocols::wire::
                                     WithErrorSyntaxResponseAsStructResponse>::
                  FromExternal(&_response)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxResponseAsStructResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse _response =
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse{};

  return Reply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                   WithResponse(std::move(_response)));
}

void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(
          std::move(error)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    Reply(
        ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse _response =
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResponse{};

  return Reply(::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::
                   WithResponse(std::move(_response)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::
    ReplyError(uint32_t error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsPrimitiveResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::
    WireCompleterImpl<::test_protocols::WithErrorSyntax::ErrorAsEnum>::Reply(
        ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse _response =
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse{};

  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse(
          std::move(_response)));
}

void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    ReplyError(::test_protocols::wire::ErrorEnum error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(
          std::move(error)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    Reply(::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::ErrorAsEnum>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::ErrorAsEnum>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::ReplySuccess() {
  ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse _response =
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResponse{};

  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithResponse(
          std::move(_response)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::
    ReplyError(::test_protocols::wire::ErrorEnum error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxErrorAsEnumResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::
    WireCompleterImpl<::test_protocols::WithErrorSyntax::HandleInResult>::Reply(
        ::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _response{std::move(result)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    ReplySuccess(::zx::handle&& h) {
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response =
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse{
          .h = std::move(h),
      };

  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(
          std::move(_response)));
}

void fidl::internal::WireCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t
                                                                       error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(
          std::move(error)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    Reply(::test_protocols::wire::WithErrorSyntaxHandleInResultResult result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::WithErrorSyntax::HandleInResult>
      _response{std::move(result)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::WithErrorSyntax::HandleInResult>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::WithErrorSyntax::HandleInResult>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::
    ReplySuccess(::zx::handle&& h) {
  ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse _response =
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResponse{
          .h = std::move(h),
      };

  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithResponse(
          std::move(_response)));
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::WithErrorSyntax::HandleInResult>::ReplyError(uint32_t
                                                                       error) {
  return Reply(
      ::test_protocols::wire::WithErrorSyntaxHandleInResultResult::WithErr(
          std::move(error)));
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ResponseAsStruct>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_ResponseAsStruct_Ordinal,
      ::test_protocols::kWithErrorSyntax_ResponseAsStruct_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsPrimitive>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_Ordinal,
      ::test_protocols::kWithErrorSyntax_ErrorAsPrimitive_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::ErrorAsEnum>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_ErrorAsEnum_Ordinal,
      ::test_protocols::kWithErrorSyntax_ErrorAsEnum_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::WithErrorSyntax::HandleInResult>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
      ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
}

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::WithErrorSyntax::HandleInResult>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kWithErrorSyntax_HandleInResult_Ordinal,
      ::test_protocols::kWithErrorSyntax_HandleInResult_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kDiscoverableProtocol_Method_Ordinal =
    3455873048082739435lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kDiscoverableProtocol_Method_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::DiscoverableProtocol::Method>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::DiscoverableProtocol::Method>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::DiscoverableProtocol::Method>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>
            client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::DiscoverableProtocol::Method>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::DiscoverableProtocol::Method>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::DiscoverableProtocol::Method>
      _request_object{};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::DiscoverableProtocol>::Method() {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::DiscoverableProtocol::Method>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::DiscoverableProtocol::Method>
      _request{};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::DiscoverableProtocol::Method>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::DiscoverableProtocol>::
    HandleOneEvent(
        ::fidl::UnownedClientEnd<::test_protocols::DiscoverableProtocol>
            client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<16> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::DiscoverableProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_[] = {
    {
        ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::WireRequest<::test_protocols::DiscoverableProtocol::Method>
              empty_request;
          auto* primary = &empty_request;
          ::fidl::internal::WireCompleter<
              ::test_protocols::DiscoverableProtocol::Method>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::DiscoverableProtocol>*>(
              interface)
              ->Method(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::DiscoverableProtocol>::entries_end_ = &entries_[1];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::DiscoverableProtocol>::TryDispatch(
        ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::
    WireServerDispatcher<::test_protocols::DiscoverableProtocol>::Dispatch(
        ::fidl::WireServer<::test_protocols::DiscoverableProtocol>* impl,
        ::fidl::IncomingMessage&& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::DiscoverableProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::DiscoverableProtocol>::Dispatch(this, std::move(msg),
                                                        std::move(
                                                            transport_context),
                                                        txn);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::DiscoverableProtocol::Method>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kDiscoverableProtocol_Method_Ordinal,
      ::test_protocols::kDiscoverableProtocol_Method_DynamicFlags);
}

#ifdef __Fuchsia__

#endif  // __Fuchsia__

namespace test_protocols {
[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodA_Ordinal =
    3155008840945527714lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kChannelProtocol_MethodA_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_EventA_Ordinal =
    2220452875311597006lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kChannelProtocol_EventA_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_MethodB_Ordinal =
    8903004957800778182lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kChannelProtocol_MethodB_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_TakeHandle_Ordinal =
    591935489944717925lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kChannelProtocol_TakeHandle_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

[[maybe_unused]] constexpr uint64_t kChannelProtocol_MutateSocket_Ordinal =
    7411742788430590287lu;

[[maybe_unused]] constexpr ::fidl::MessageDynamicFlags
    kChannelProtocol_MutateSocket_DynamicFlags =
        ::fidl::MessageDynamicFlags::kStrictMethod;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;
#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::MethodA>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodA>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client.handle());
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodA>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MethodA>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MethodA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  uint32_t request_byte_capacity = buffer_size;
  uint8_t* request_bytes = buffer;

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Write(client_end.handle());
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodB>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MethodB>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MethodB>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MethodB>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MethodB>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity =
      ::fidl::MaxSizeInChannel<::fidl::internal::TransactionalRequest<
                                   ::test_protocols::ChannelProtocol::MethodB>,
                               ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodB>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::TakeHandle>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::TakeHandle>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::TakeHandle>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::TakeHandle>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::TakeHandle>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>* request) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()));
  SetStatus(outgoing);
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>::WireResult(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client,
    ::fidl::internal::TransactionalRequest<
        ::test_protocols::ChannelProtocol::MutateSocket>* request,
    zx_time_t deadline) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      request_message(::fidl::internal::AllowUnownedInputRef{}, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>>(
      client.handle(), bytes_.data(), static_cast<uint32_t>(bytes_.size()),
      fidl::CallOptions{.deadline = deadline});
  SetStatus(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

#ifdef __Fuchsia__
}  // namespace test_protocols
::fidl::WireUnownedResult<::test_protocols::ChannelProtocol::MutateSocket>::
    WireUnownedResult(
        ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end,
        ::fidl::internal::AnyBufferAllocator& allocator,
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MutateSocket>* request) {
  constexpr uint32_t buffer_size = ::fidl::SyncClientMethodBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MutateSocket>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> allocation =
      allocator.TryAllocate(buffer_size);
  if (!allocation.is_ok()) {
    ::fidl::Status::operator=(allocation.error_value());
    return;
  }
  uint8_t* buffer = allocation->data;
  constexpr uint32_t request_byte_capacity = ::fidl::MaxSizeInChannel<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::MessageDirection::kSending>();
  uint8_t* request_bytes = buffer;
  static_assert(buffer_size > request_byte_capacity);
  uint32_t response_byte_capacity = buffer_size - request_byte_capacity;
  uint8_t* response_bytes = &buffer[request_byte_capacity];

  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MutateSocket>>
      request_message(request_bytes, request_byte_capacity, request);
  auto& outgoing = request_message.GetOutgoingMessage();
  outgoing.Call<::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>>(
      client_end.handle(), response_bytes, response_byte_capacity);
  bytes_ = response_bytes;
  ::fidl::Status::operator=(outgoing);
}
namespace test_protocols {
#endif  // __Fuchsia__

}  // namespace test_protocols
#ifdef __Fuchsia__

::fidl::Status fidl::internal::WireWeakOnewayClientImpl<
    ::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodA>
      _request_object{a, b};
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>,
      ::fidl::internal::ChannelTransport>
      _request_message(::fidl::internal::AllowUnownedInputRef{},
                       &_request_object);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}

::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MethodB>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodB>
      _request{a, b};
  return ::fidl::internal::WireThenable<
      ::test_protocols::ChannelProtocol::MethodB>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::TakeHandle>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _request{std::move(h)};
  return ::fidl::internal::WireThenable<
      ::test_protocols::ChannelProtocol::TakeHandle>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}

::fidl::internal::WireThenable<::test_protocols::ChannelProtocol::MutateSocket>
fidl::internal::WireWeakAsyncClientImpl<
    ::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _request{std::move(a)};
  return ::fidl::internal::WireThenable<
      ::test_protocols::ChannelProtocol::MutateSocket>{
      _client_base(), ::fidl::WriteOptions{},
      ::fidl::internal::AllowUnownedInputRef{}, &_request};
}
::fidl::Status fidl::internal::WireWeakOnewayBufferClientImpl<
    ::test_protocols::ChannelProtocol>::MethodA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::MethodA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodA>
      _request{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalRequest<
          ::test_protocols::ChannelProtocol::MethodA>>
      _request_message(_allocation->data, _buffer_size, &_request);
  return _client_base()->SendOneWay(_request_message.GetOutgoingMessage());
}
::fidl::internal::WireBufferThenable<::test_protocols::ChannelProtocol::MethodB>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::MethodB>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MethodB>
      _request{a, b};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::ChannelProtocol::MethodB>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::ChannelProtocol::TakeHandle>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::TakeHandle>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _request{std::move(h)};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::ChannelProtocol::TakeHandle>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}
::fidl::internal::WireBufferThenable<
    ::test_protocols::ChannelProtocol::MutateSocket>
fidl::internal::WireWeakAsyncBufferClientImpl<
    ::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
  constexpr uint32_t _buffer_size =
      ::fidl::AsyncClientMethodBufferSizeInChannel<
          ::test_protocols::ChannelProtocol::MutateSocket>();
  ::fidl::internal::TransactionalRequest<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _request{std::move(a)};
  return ::fidl::internal::WireBufferThenable<
      ::test_protocols::ChannelProtocol::MutateSocket>{
      _client_base(), ::fidl::WriteOptions{}, _allocator(), _buffer_size,
      &_request};
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>::MethodB(int64_t a, int64_t b) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MethodB>
            _request{a, b};
        return ::fidl::WireResult<::test_protocols::ChannelProtocol::MethodB>(
            ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::ChannelProtocol::TakeHandle>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>::TakeHandle(::zx::handle&& h) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::TakeHandle>
            _request{std::move(h)};
        return ::fidl::WireResult<
            ::test_protocols::ChannelProtocol::TakeHandle>(
            ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}

::fidl::WireResult<::test_protocols::ChannelProtocol::MutateSocket>
fidl::internal::WireWeakSyncClientImpl<
    ::test_protocols::ChannelProtocol>::MutateSocket(::zx::socket&& a) {
  return _client_base()->MakeSyncCallWith(
      [&](std::shared_ptr<::fidl::internal::AnyTransport> _transport) {
        ::fidl::internal::TransactionalRequest<
            ::test_protocols::ChannelProtocol::MutateSocket>
            _request{std::move(a)};
        return ::fidl::WireResult<
            ::test_protocols::ChannelProtocol::MutateSocket>(
            ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol>(
                _transport->get<::fidl::internal::ChannelTransport>()),
            &_request);
      });
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

::fidl::Status
fidl::WireSyncEventHandler<::test_protocols::ChannelProtocol>::HandleOneEvent(
    ::fidl::UnownedClientEnd<::test_protocols::ChannelProtocol> client_end) {
  zx_status_t status = client_end.channel()->wait_one(
      ZX_CHANNEL_READABLE | ZX_CHANNEL_PEER_CLOSED, ::zx::time::infinite(),
      nullptr);
  if (status != ZX_OK) {
    return ::fidl::Status::TransportError(
        status, ::fidl::internal::kErrorWaitOneFailed);
  }
  constexpr uint32_t kHandleAllocSize = ([]() constexpr {
    uint32_t x = 0;
    if (::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
            ::test_protocols::ChannelProtocol::EventA>>::kMaxNumHandles >= x) {
      x = ::fidl::TypeTraits<::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>>::kMaxNumHandles;
    }
    if (x > ZX_CHANNEL_MAX_MSG_HANDLES) {
      x = ZX_CHANNEL_MAX_MSG_HANDLES;
    }
    return x;
  })();
  static_assert(kHandleAllocSize <= ZX_CHANNEL_MAX_MSG_HANDLES);
  ::fidl::internal::InlineMessageBuffer<32> read_storage;
  std::array<zx_handle_t, kHandleAllocSize> read_handles;
  // TODO(fxbug.dev/85734) Remove this channel-specific allocation.
  std::array<fidl_channel_handle_metadata_t, kHandleAllocSize>
      read_handle_metadata;
  ::fidl::IncomingMessage msg = ::fidl::MessageRead(
      zx::unowned_channel(client_end.handle()), read_storage.view(),
      read_handles.data(), read_handle_metadata.data(), kHandleAllocSize,
      ReadOptions{.discardable = true});
  if (msg.status() == ZX_ERR_BUFFER_TOO_SMALL) {
    // Message size is unexpectedly larger than calculated.
    // This can only be due to a newer version of the protocol defining a new
    // event, whose size exceeds the maximum of known events in the current
    // protocol.
    return ::fidl::Status::UnexpectedMessage(
        ZX_ERR_BUFFER_TOO_SMALL,
        ::fidl::internal::kErrorSyncEventBufferTooSmall);
  }
  if (!msg.ok()) {
    return msg;
  }
  fidl_message_header_t* hdr = msg.header();
  switch (hdr->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>>
          decoded{::std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::Status(decoded);
      }
      auto* primary = &decoded.PrimaryObject()->body;
      got_transitional_ = false;
      EventA(primary);
      if (got_transitional_) {
        return ::fidl::Status::UnexpectedMessage(
            ZX_ERR_NOT_SUPPORTED,
            ::fidl::internal::kErrorSyncEventUnhandledTransitionalEvent);
      }
      return ::fidl::Status::Ok();
    }
    default: {
      return ::fidl::Status::UnknownOrdinal();
    }
  }
}

std::optional<::fidl::UnbindInfo> fidl::internal::
    WireEventDispatcher<::test_protocols::ChannelProtocol>::DispatchEvent(
        ::fidl::IncomingMessage& msg,
        ::fidl::internal::IncomingTransportContext transport_context) {
  switch (msg.header()->ordinal) {
    case ::test_protocols::kChannelProtocol_EventA_Ordinal: {
      ::fidl::unstable::DecodedMessage<::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>>
          decoded{std::move(msg)};
      if (!decoded.ok()) {
        return ::fidl::UnbindInfo{decoded};
      }
      if (event_handler()) {
        auto* primary = &decoded.PrimaryObject()->body;
        event_handler()->EventA(primary);
      }
      return std::nullopt;
    }
    default:
      break;
  }
  return ::fidl::UnbindInfo::UnknownOrdinal();
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

constexpr ::fidl::internal::MethodEntry fidl::internal::WireServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_[] = {
    {
        ::test_protocols::kChannelProtocol_MethodA_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MethodA>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::MethodA>::Sync completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->MethodA(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MethodB_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MethodB>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::MethodB>::Sync completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->MethodB(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::TakeHandle>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::TakeHandle>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->TakeHandle(primary, completer);
          return ZX_OK;
        },
    },
    {
        ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
        [](void* interface, ::fidl::IncomingMessage&& msg,
           internal::IncomingTransportContext transport_context,
           ::fidl::Transaction* txn) {
          ::fidl::unstable::DecodedMessage<
              ::fidl::internal::TransactionalRequest<
                  ::test_protocols::ChannelProtocol::MutateSocket>>
              decoded{std::move(msg)};
          if (unlikely(!decoded.ok())) {
            return decoded.status();
          }
          auto* primary = &decoded.PrimaryObject()->body;
          ::fidl::internal::WireCompleter<
              ::test_protocols::ChannelProtocol::MutateSocket>::Sync
              completer(txn);
          reinterpret_cast<
              ::fidl::WireServer<::test_protocols::ChannelProtocol>*>(interface)
              ->MutateSocket(primary, completer);
          return ZX_OK;
        },
    },
};

const ::fidl::internal::MethodEntry* fidl::internal::WireServerDispatcher<
    ::test_protocols::ChannelProtocol>::entries_end_ = &entries_[4];

::fidl::DispatchResult fidl::internal::
    WireServerDispatcher<::test_protocols::ChannelProtocol>::TryDispatch(
        ::fidl::WireServer<::test_protocols::ChannelProtocol>* impl,
        ::fidl::IncomingMessage& msg,
        internal::IncomingTransportContext transport_context,
        ::fidl::Transaction* txn) {
  return ::fidl::internal::TryDispatch(impl, msg, std::move(transport_context),
                                       txn, entries_, entries_end_);
}

void fidl::internal::WireServerDispatcher<::test_protocols::ChannelProtocol>::
    Dispatch(::fidl::WireServer<::test_protocols::ChannelProtocol>* impl,
             ::fidl::IncomingMessage&& msg,
             internal::IncomingTransportContext transport_context,
             ::fidl::Transaction* txn) {
  ::fidl::internal::Dispatch(impl, msg, std::move(transport_context), txn,
                             entries_, entries_end_);
}
void fidl::WireServer<::test_protocols::ChannelProtocol>::dispatch_message(
    ::fidl::IncomingMessage&& msg, ::fidl::Transaction* txn,
    ::fidl::internal::IncomingTransportContext transport_context) {
  ::fidl::internal::WireServerDispatcher<
      ::test_protocols::ChannelProtocol>::Dispatch(this, std::move(msg),
                                                   std::move(transport_context),
                                                   txn);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>
      _response{result};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::MethodB>::Reply(int64_t result) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MethodB>
      _response{result};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MethodB>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MethodB>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _response{};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::TakeHandle>::Reply() {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::TakeHandle>
      _response{};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::TakeHandle>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::TakeHandle>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__
void fidl::internal::WireCompleterImpl<
    ::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _response{std::move(b)};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}

void fidl::internal::WireBufferCompleterImpl<
    ::test_protocols::ChannelProtocol::MutateSocket>::Reply(::zx::socket&& b) {
  ::fidl::internal::TransactionalResponse<
      ::test_protocols::ChannelProtocol::MutateSocket>
      _response{std::move(b)};
  constexpr uint32_t _buffer_size = ::fidl::ServerReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::MutateSocket>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    ::fidl::OutgoingMessage _failure{_allocation.error_value()};
    return _core()->SendReply(&_failure,
                              ::fidl::internal::OutgoingTransportContext());
  }
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalResponse<
          ::test_protocols::ChannelProtocol::MutateSocket>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _core()->SendReply(&_response_message.GetOutgoingMessage(),
                            ::fidl::internal::OutgoingTransportContext());
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodA>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_MethodA_Ordinal,
      ::test_protocols::kChannelProtocol_MethodA_DynamicFlags);
}

void ::fidl::internal::TransactionalEvent<
    ::test_protocols::ChannelProtocol::EventA>::_InitHeader() {
  ::fidl::InitTxnHeader(&header, 0,
                        ::test_protocols::kChannelProtocol_EventA_Ordinal,
                        ::test_protocols::kChannelProtocol_EventA_DynamicFlags);
}

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MethodB>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal,
      ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
}

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MethodB>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_MethodB_Ordinal,
      ::test_protocols::kChannelProtocol_MethodB_DynamicFlags);
}

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::TakeHandle>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
      ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
}
#endif  // __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::TakeHandle>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_TakeHandle_Ordinal,
      ::test_protocols::kChannelProtocol_TakeHandle_DynamicFlags);
}

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalRequest<
    ::test_protocols::ChannelProtocol::MutateSocket>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
      ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

void ::fidl::internal::TransactionalResponse<
    ::test_protocols::ChannelProtocol::MutateSocket>::_InitHeader() {
  ::fidl::InitTxnHeader(
      &header, 0, ::test_protocols::kChannelProtocol_MutateSocket_Ordinal,
      ::test_protocols::kChannelProtocol_MutateSocket_DynamicFlags);
}
#endif  // __Fuchsia__

#ifdef __Fuchsia__

fidl::Status fidl::internal::WireWeakEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireWeakBufferEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::EventA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    _inner().HandleSendError(_allocation.error_value());
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  return _inner().SendEvent(_response_message.GetOutgoingMessage());
}

fidl::Status fidl::internal::WireEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  FIDL_INTERNAL_DISABLE_AUTO_VAR_INIT
  ::fidl::unstable::OwnedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message{::fidl::internal::AllowUnownedInputRef{}, &_response};
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

fidl::Status fidl::internal::WireBufferEventSender<
    ::test_protocols::ChannelProtocol>::EventA(int64_t a, int64_t b) {
  constexpr uint32_t _buffer_size = ::fidl::EventReplyBufferSizeInChannel<
      ::test_protocols::ChannelProtocol::EventA>();
  ::fitx::result<::fidl::Error, ::fidl::BufferSpan> _allocation =
      _allocator().TryAllocate(_buffer_size);
  if (!_allocation.is_ok()) {
    return _allocation.error_value();
  }

  ::fidl::internal::TransactionalEvent<
      ::test_protocols::ChannelProtocol::EventA>
      _response{a, b};
  ::fidl::unstable::UnownedEncodedMessage<
      ::fidl::internal::TransactionalEvent<
          ::test_protocols::ChannelProtocol::EventA>,
      ::fidl::internal::ChannelTransport>
      _response_message(_allocation->data, _buffer_size, &_response);
  auto& _message = _response_message.GetOutgoingMessage();
  _message.Write(_transport());
  return ::fidl::Status{_message};
}

#endif  // __Fuchsia__
