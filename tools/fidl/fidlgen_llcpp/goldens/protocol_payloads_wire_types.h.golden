// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <lib/fidl/llcpp/array.h>
#include <lib/fidl/llcpp/coding.h>
#include <lib/fidl/llcpp/envelope.h>
#include <lib/fidl/llcpp/message.h>
#include <lib/fidl/llcpp/message_storage.h>
#include <lib/fidl/llcpp/object_view.h>
#include <lib/fidl/llcpp/string_view.h>
#include <lib/fidl/llcpp/traits.h>
#include <lib/fidl/llcpp/wire_types.h>
#include <lib/stdcompat/optional.h>

#include <cinttypes>
#ifdef __Fuchsia__
#include <lib/zx/channel.h>

#endif  // __Fuchsia__

#include <fidl/test.protocolpayloads.imported/cpp/wire_types.h>
#include <fidl/test.protocolpayloads/cpp/common_types.h>
#include <fidl/test.protocolpayloads/cpp/markers.h>

namespace test_protocolpayloads {
namespace wire {
struct MainProtocolTwoWayImportWithErrorTopResponse;

struct MainProtocolTwoWayAnonWithErrorResponse;

struct MainProtocolTwoWayAnonWithErrorTopResponse;

struct MainProtocolOnImportWithErrorRequest;

struct MainProtocolOnAnonWithErrorResponse;

struct MainProtocolOnAnonWithErrorRequest;

struct MainProtocolTwoWayAnonWithErrorRequest;

struct MainProtocolTwoWayAnonTopResponse;

struct MainProtocolTwoWayAnonRequest;

struct MainProtocolOneWayAnonRequest;

struct MainProtocolOnAnonRequest;

struct LocalStructPayload;

struct MainProtocolTwoWayLocalWithErrorTopResponse;

struct MainProtocolOnLocalWithErrorRequest;

class MainProtocolTwoWayImportWithErrorResult;

class MainProtocolTwoWayAnonWithErrorResult;

class MainProtocolOnImportWithErrorResult;

class MainProtocolOnAnonWithErrorResult;

class MainProtocolTwoWayLocalWithErrorResult;

class MainProtocolOnLocalWithErrorResult;

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayImportWithError_ResultTable;

class MainProtocolTwoWayImportWithErrorResult {
 public:
  MainProtocolTwoWayImportWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolTwoWayImportWithErrorResult::Ordinal::Invalid),
        envelope_{} {}

  MainProtocolTwoWayImportWithErrorResult(
      const MainProtocolTwoWayImportWithErrorResult&) = default;
  MainProtocolTwoWayImportWithErrorResult& operator=(
      const MainProtocolTwoWayImportWithErrorResult&) = default;
  MainProtocolTwoWayImportWithErrorResult(
      MainProtocolTwoWayImportWithErrorResult&&) = default;
  MainProtocolTwoWayImportWithErrorResult& operator=(
      MainProtocolTwoWayImportWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse;
  }

  static MainProtocolTwoWayImportWithErrorResult WithResponse(
      ::test_protocolpayloads_imported::wire::ImportStructPayload val) {
    MainProtocolTwoWayImportWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse;
    result.envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .set_data(std::move(val));
    return result;
  }

  ::test_protocolpayloads_imported::wire::ImportStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads_imported::wire::ImportStructPayload& response()
      const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr;
  }

  static MainProtocolTwoWayImportWithErrorResult WithErr(uint32_t val) {
    MainProtocolTwoWayImportWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolTwoWayImportWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult::
      Ordinal ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResultTable;

class MainProtocolTwoWayAnonWithErrorResult {
 public:
  using Response =
      test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse;

  MainProtocolTwoWayAnonWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid),
        envelope_{} {}

  MainProtocolTwoWayAnonWithErrorResult(
      const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(
      const MainProtocolTwoWayAnonWithErrorResult&) = default;
  MainProtocolTwoWayAnonWithErrorResult(
      MainProtocolTwoWayAnonWithErrorResult&&) = default;
  MainProtocolTwoWayAnonWithErrorResult& operator=(
      MainProtocolTwoWayAnonWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
  }

  static MainProtocolTwoWayAnonWithErrorResult WithResponse(
      ::fidl::ObjectView<::test_protocolpayloads::wire::
                             MainProtocolTwoWayAnonWithErrorResponse>
          val) {
    MainProtocolTwoWayAnonWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse;
    result.envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolTwoWayAnonWithErrorResponse>()
        .set_data(std::move(val));
    return result;
  }

  template <typename... Args>
  static MainProtocolTwoWayAnonWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(
        ::fidl::ObjectView<::test_protocolpayloads::wire::
                               MainProtocolTwoWayAnonWithErrorResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolTwoWayAnonWithErrorResponse>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolTwoWayAnonWithErrorResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr;
  }

  static MainProtocolTwoWayAnonWithErrorResult WithErr(uint32_t val) {
    MainProtocolTwoWayAnonWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolTwoWayAnonWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnImportWithError_ResultTable;

class MainProtocolOnImportWithErrorResult {
 public:
  MainProtocolOnImportWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolOnImportWithErrorResult::Ordinal::Invalid),
        envelope_{} {}

  MainProtocolOnImportWithErrorResult(
      const MainProtocolOnImportWithErrorResult&) = default;
  MainProtocolOnImportWithErrorResult& operator=(
      const MainProtocolOnImportWithErrorResult&) = default;
  MainProtocolOnImportWithErrorResult(MainProtocolOnImportWithErrorResult&&) =
      default;
  MainProtocolOnImportWithErrorResult& operator=(
      MainProtocolOnImportWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::
               Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::
               Ordinal::kResponse;
  }

  static MainProtocolOnImportWithErrorResult WithResponse(
      ::test_protocolpayloads_imported::wire::ImportStructPayload val) {
    MainProtocolOnImportWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnImportWithErrorResult::Ordinal::kResponse;
    result.envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .set_data(std::move(val));
    return result;
  }

  ::test_protocolpayloads_imported::wire::ImportStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads_imported::wire::ImportStructPayload& response()
      const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads_imported::wire::ImportStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnImportWithErrorResult::Ordinal::kErr;
  }

  static MainProtocolOnImportWithErrorResult WithErr(uint32_t val) {
    MainProtocolOnImportWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnImportWithErrorResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnImportWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolOnImportWithErrorResult::Tag>(ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnAnonWithError_ResultTable;

class MainProtocolOnAnonWithErrorResult {
 public:
  using Response =
      test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse;

  MainProtocolOnAnonWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolOnAnonWithErrorResult::Ordinal::Invalid),
        envelope_{} {}

  MainProtocolOnAnonWithErrorResult(const MainProtocolOnAnonWithErrorResult&) =
      default;
  MainProtocolOnAnonWithErrorResult& operator=(
      const MainProtocolOnAnonWithErrorResult&) = default;
  MainProtocolOnAnonWithErrorResult(MainProtocolOnAnonWithErrorResult&&) =
      default;
  MainProtocolOnAnonWithErrorResult& operator=(
      MainProtocolOnAnonWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnAnonWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::
               Ordinal::kResponse;
  }

  static MainProtocolOnAnonWithErrorResult WithResponse(
      ::fidl::ObjectView<
          ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
          val) {
    MainProtocolOnAnonWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnAnonWithErrorResult::Ordinal::kResponse;
    result.envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolOnAnonWithErrorResponse>()
        .set_data(std::move(val));
    return result;
  }

  template <typename... Args>
  static MainProtocolOnAnonWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(
        ::fidl::ObjectView<
            ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse&
  response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolOnAnonWithErrorResponse>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse&
  response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::
                  Ordinal::kResponse);
    return envelope_
        .As<::test_protocolpayloads::wire::
                MainProtocolOnAnonWithErrorResponse>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnAnonWithErrorResult::Ordinal::kErr;
  }

  static MainProtocolOnAnonWithErrorResult WithErr(uint32_t val) {
    MainProtocolOnAnonWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnAnonWithErrorResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::
                              MainProtocolOnAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ == ::test_protocolpayloads::wire::
                              MainProtocolOnAnonWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayLocalWithError_ResultTable;

class MainProtocolTwoWayLocalWithErrorResult {
 public:
  MainProtocolTwoWayLocalWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid),
        envelope_{} {}

  MainProtocolTwoWayLocalWithErrorResult(
      const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(
      const MainProtocolTwoWayLocalWithErrorResult&) = default;
  MainProtocolTwoWayLocalWithErrorResult(
      MainProtocolTwoWayLocalWithErrorResult&&) = default;
  MainProtocolTwoWayLocalWithErrorResult& operator=(
      MainProtocolTwoWayLocalWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
  }

  static MainProtocolTwoWayLocalWithErrorResult WithResponse(
      ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>
          val) {
    MainProtocolTwoWayLocalWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse;
    result.envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .set_data(std::move(val));
    return result;
  }

  template <typename... Args>
  static MainProtocolTwoWayLocalWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(
        ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::LocalStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::LocalStructPayload& response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr;
  }

  static MainProtocolTwoWayLocalWithErrorResult WithErr(uint32_t val) {
    MainProtocolTwoWayLocalWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Tag
  Which() const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<::test_protocolpayloads::wire::
                           MainProtocolTwoWayLocalWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnLocalWithError_ResultTable;

class MainProtocolOnLocalWithErrorResult {
 public:
  MainProtocolOnLocalWithErrorResult()
      : ordinal_(::test_protocolpayloads::wire::
                     MainProtocolOnLocalWithErrorResult::Ordinal::Invalid),
        envelope_{} {}

  MainProtocolOnLocalWithErrorResult(
      const MainProtocolOnLocalWithErrorResult&) = default;
  MainProtocolOnLocalWithErrorResult& operator=(
      const MainProtocolOnLocalWithErrorResult&) = default;
  MainProtocolOnLocalWithErrorResult(MainProtocolOnLocalWithErrorResult&&) =
      default;
  MainProtocolOnLocalWithErrorResult& operator=(
      MainProtocolOnLocalWithErrorResult&&) = default;

  enum class Tag : fidl_xunion_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  bool has_invalid_tag() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnLocalWithErrorResult::Ordinal::Invalid;
  }

  bool is_response() const {
    return ordinal_ ==
           ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::
               Ordinal::kResponse;
  }

  static MainProtocolOnLocalWithErrorResult WithResponse(
      ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>
          val) {
    MainProtocolOnLocalWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnLocalWithErrorResult::Ordinal::kResponse;
    result.envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .set_data(std::move(val));
    return result;
  }

  template <typename... Args>
  static MainProtocolOnLocalWithErrorResult WithResponse(
      ::fidl::AnyArena& allocator, Args&&... args) {
    return WithResponse(
        ::fidl::ObjectView<::test_protocolpayloads::wire::LocalStructPayload>(
            allocator, std::forward<Args>(args)...));
  }

  ::test_protocolpayloads::wire::LocalStructPayload& response() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }
  const ::test_protocolpayloads::wire::LocalStructPayload& response() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kResponse);
    return envelope_.As<::test_protocolpayloads::wire::LocalStructPayload>()
        .get_data();
  }

  bool is_err() const {
    return ordinal_ == ::test_protocolpayloads::wire::
                           MainProtocolOnLocalWithErrorResult::Ordinal::kErr;
  }

  static MainProtocolOnLocalWithErrorResult WithErr(uint32_t val) {
    MainProtocolOnLocalWithErrorResult result;
    result.ordinal_ = ::test_protocolpayloads::wire::
        MainProtocolOnLocalWithErrorResult::Ordinal::kErr;
    result.envelope_.As<uint32_t>().set_data(std::move(val));
    return result;
  }

  uint32_t& err() {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  const uint32_t& err() const {
    ZX_ASSERT(ordinal_ ==
              ::test_protocolpayloads::wire::
                  MainProtocolOnLocalWithErrorResult::Ordinal::kErr);
    return envelope_.As<uint32_t>().get_data();
  }
  ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::Tag Which()
      const {
    ZX_ASSERT(!has_invalid_tag());
    return static_cast<
        ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::Tag>(
        ordinal_);
  }

 private:
  enum class Ordinal : fidl_xunion_tag_t {
    Invalid = 0,
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  static void SizeAndOffsetAssertionHelper();
  ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult::Ordinal
      ordinal_;
  FIDL_ALIGNDECL
  ::fidl::UntypedEnvelope envelope_;
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayImportWithErrorTopResponseTable;

struct MainProtocolTwoWayImportWithErrorTopResponse {
  using Result =
      test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult;

  ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult
      result = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResponseTable;

struct MainProtocolTwoWayAnonWithErrorResponse {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonWithErrorTopResponseTable;

struct MainProtocolTwoWayAnonWithErrorTopResponse {
  using Result =
      test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult;

  ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult result =
      {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable;

struct MainProtocolOnImportWithErrorRequest {
  using Result =
      test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult;

  ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult result =
      {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocol_OnAnonWithError_ResponseTable;

struct MainProtocolOnAnonWithErrorResponse {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable;

struct MainProtocolOnAnonWithErrorRequest {
  using Result = test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult;

  ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult result = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable;

struct MainProtocolTwoWayAnonWithErrorRequest {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonTopResponseTable;

struct MainProtocolTwoWayAnonTopResponse {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayAnonRequestTable;

struct MainProtocolTwoWayAnonRequest {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOneWayAnonRequestTable;

struct MainProtocolOneWayAnonRequest {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnAnonRequestTable;

struct MainProtocolOnAnonRequest {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t test_protocolpayloads_LocalStructPayloadTable;

struct LocalStructPayload {
  uint32_t a = {};

  uint32_t b = {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolTwoWayLocalWithErrorTopResponseTable;

struct MainProtocolTwoWayLocalWithErrorTopResponse {
  using Result =
      test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult;

  ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult result =
      {};
};

extern "C" const fidl_type_t
    test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable;

struct MainProtocolOnLocalWithErrorRequest {
  using Result =
      test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult;

  ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult result = {};
};

}  // namespace wire
}  // namespace test_protocolpayloads
namespace fidl {

template <>
struct TypeTraits<::test_protocolpayloads::wire::
                      MainProtocolTwoWayImportWithErrorTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolTwoWayImportWithErrorTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorTopResponse>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocolpayloads::wire::
                  MainProtocolTwoWayImportWithErrorTopResponse>);
static_assert(offsetof(::test_protocolpayloads::wire::
                           MainProtocolTwoWayImportWithErrorTopResponse,
                       result) == 0);
static_assert(
    sizeof(::test_protocolpayloads::wire::
               MainProtocolTwoWayImportWithErrorTopResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayImportWithErrorTopResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_protocolpayloads::wire::
                                  MainProtocolTwoWayAnonWithErrorResponse>);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse,
        a) == 0);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResponse,
        b) == 4);
static_assert(
    sizeof(::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayAnonWithErrorResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolTwoWayAnonWithErrorTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_protocolpayloads::wire::
                                  MainProtocolTwoWayAnonWithErrorTopResponse>);
static_assert(offsetof(::test_protocolpayloads::wire::
                           MainProtocolTwoWayAnonWithErrorTopResponse,
                       result) == 0);
static_assert(
    sizeof(::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorTopResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayAnonWithErrorTopResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolOnImportWithErrorRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorRequest>);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorRequest,
        result) == 0);
static_assert(
    sizeof(
        ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorRequest) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolOnImportWithErrorRequest>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnAnonWithError_ResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse,
             a) == 0);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse,
             b) == 4);
static_assert(
    sizeof(
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolOnAnonWithErrorResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolOnAnonWithErrorRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorRequest>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorRequest,
             result) == 0);
static_assert(
    sizeof(::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorRequest) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolOnAnonWithErrorRequest>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolTwoWayAnonWithErrorRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest>);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest,
        a) == 0);
static_assert(
    offsetof(
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorRequest,
        b) == 4);
static_assert(
    sizeof(::test_protocolpayloads::wire::
               MainProtocolTwoWayAnonWithErrorRequest) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayAnonWithErrorRequest>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolTwoWayAnonTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse,
             a) == 0);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse,
             b) == 4);
static_assert(
    sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonTopResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayAnonTopResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolTwoWayAnonRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, a) ==
    0);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest, b) ==
    4);
static_assert(
    sizeof(::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest) ==
    TypeTraits<::test_protocolpayloads::wire::MainProtocolTwoWayAnonRequest>::
        kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolOneWayAnonRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, a) ==
    0);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest, b) ==
    4);
static_assert(
    sizeof(::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest) ==
    TypeTraits<::test_protocolpayloads::wire::MainProtocolOneWayAnonRequest>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolOnAnonRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocolpayloads::wire::MainProtocolOnAnonRequest>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocolpayloads::wire::MainProtocolOnAnonRequest>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocolpayloads::wire::MainProtocolOnAnonRequest>);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest,
                       a) == 0);
static_assert(offsetof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest,
                       b) == 4);
static_assert(
    sizeof(::test_protocolpayloads::wire::MainProtocolOnAnonRequest) ==
    TypeTraits<::test_protocolpayloads::wire::MainProtocolOnAnonRequest>::
        kPrimarySize);

template <>
struct TypeTraits<::test_protocolpayloads::wire::LocalStructPayload> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_LocalStructPayloadTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 8;
  static constexpr uint32_t kPrimarySizeV1 = 8;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 0;
  static constexpr bool kHasPointer = false;
};

template <>
struct IsFidlType<::test_protocolpayloads::wire::LocalStructPayload>
    : public std::true_type {};
template <>
struct IsStruct<::test_protocolpayloads::wire::LocalStructPayload>
    : public std::true_type {};
static_assert(std::is_standard_layout_v<
              ::test_protocolpayloads::wire::LocalStructPayload>);
static_assert(offsetof(::test_protocolpayloads::wire::LocalStructPayload, a) ==
              0);
static_assert(offsetof(::test_protocolpayloads::wire::LocalStructPayload, b) ==
              4);
static_assert(sizeof(::test_protocolpayloads::wire::LocalStructPayload) ==
              TypeTraits<::test_protocolpayloads::wire::LocalStructPayload>::
                  kPrimarySize);

template <>
struct TypeTraits<::test_protocolpayloads::wire::
                      MainProtocolTwoWayLocalWithErrorTopResponse> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolTwoWayLocalWithErrorTopResponseTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorTopResponse>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorTopResponse>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_protocolpayloads::wire::
                                  MainProtocolTwoWayLocalWithErrorTopResponse>);
static_assert(offsetof(::test_protocolpayloads::wire::
                           MainProtocolTwoWayLocalWithErrorTopResponse,
                       result) == 0);
static_assert(
    sizeof(::test_protocolpayloads::wire::
               MainProtocolTwoWayLocalWithErrorTopResponse) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolTwoWayLocalWithErrorTopResponse>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorRequest> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocolOnLocalWithErrorRequestTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorRequest>
    : public std::true_type {};
template <>
struct IsStruct<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorRequest>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorRequest>);
static_assert(
    offsetof(::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorRequest,
             result) == 0);
static_assert(
    sizeof(
        ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorRequest) ==
    TypeTraits<::test_protocolpayloads::wire::
                   MainProtocolOnLocalWithErrorRequest>::kPrimarySize);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayImportWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolTwoWayImportWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<::test_protocolpayloads::wire::
                                  MainProtocolTwoWayImportWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayAnonWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolTwoWayAnonWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnImportWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 0;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnImportWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnAnonWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnAnonWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_TwoWayLocalWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolTwoWayLocalWithErrorResult>);

template <>
struct TypeTraits<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult> {
  static constexpr const fidl_type_t* kType =
      &::test_protocolpayloads::wire::
          test_protocolpayloads_MainProtocol_OnLocalWithError_ResultTable;
  static constexpr uint32_t kMaxNumHandles = 0;
  static constexpr uint32_t kPrimarySize = 16;
  static constexpr uint32_t kPrimarySizeV1 = 24;
  [[maybe_unused]] static constexpr uint32_t kMaxOutOfLine = 8;
  static constexpr uint32_t kMaxOutOfLineV1 = 8;
  static constexpr bool kHasPointer = true;
};

template <>
struct IsFidlType<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult>
    : public std::true_type {};
template <>
struct IsUnion<
    ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult>
    : public std::true_type {};
static_assert(
    std::is_standard_layout_v<
        ::test_protocolpayloads::wire::MainProtocolOnLocalWithErrorResult>);

}  // namespace fidl
