// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.protocols/cpp/common_types.h>
#include <fidl/test.protocols/cpp/markers.h>
#include <lib/fidl/cpp/natural_coding_traits.h>
#include <lib/fidl/cpp/natural_types.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>

#endif  // __Fuchsia__

namespace test_protocols {
class WithErrorSyntax_HandleInResult_Response;

class WithErrorSyntaxHandleInResultTopResponse;

class HandleRightsProtocolResponseMethodTopResponse;

class HandleRightsProtocolResponseMethodRequest;

class HandleRightsProtocolNoResponseMethodRequest;

class HandleRightsProtocolAnEventRequest;

class ChannelProtocolTakeHandleRequest;

class ChannelProtocolMutateSocketTopResponse;

class ChannelProtocolMutateSocketRequest;

class WithProtocolEndsServerEndsTopResponse;

class WithProtocolEndsServerEndsRequest;

class WithProtocolEndsClientEndsTopResponse;

class WithProtocolEndsClientEndsRequest;

class WithErrorSyntax_ResponseAsStruct_Response;

class WithErrorSyntaxResponseAsStructTopResponse;

class WithErrorSyntax_ErrorAsPrimitive_Response;

class WithErrorSyntaxErrorAsPrimitiveTopResponse;

class WithErrorSyntax_ErrorAsEnum_Response;

class WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;

class WithAndWithoutRequestResponseWithRequestWithResponseRequest;

class WithAndWithoutRequestResponseWithRequestNoResponseRequest;

class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

class WithAndWithoutRequestResponseOnWithResponseRequest;

class WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;

class TransitionalRequestTopResponse;

class TransitionalRequestRequest;

class TransitionalOneWayRequest;

class TransitionalEventRequest;

class MethodWithUnionUnionMethodRequest;

class SyscallProtocolMethodCRequest;

class ProtocolEnds;

class WithProtocolEndsStructContainingEndsTopResponse;

class WithProtocolEndsStructContainingEndsRequest;

class ManyParametersFifteenRequest;

class WithErrorSyntaxErrorAsEnumTopResponse;

class ChannelProtocolMethodBTopResponse;

class ChannelProtocolMethodBRequest;

class ChannelProtocolMethodARequest;

class ChannelProtocolEventARequest;

class WithErrorSyntax_HandleInResult_Result;

class WithErrorSyntax_ResponseAsStruct_Result;

class WithErrorSyntax_ErrorAsPrimitive_Result;

class TheUnion;

class WithErrorSyntax_ErrorAsEnum_Result;

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

class WithErrorSyntax_HandleInResult_Response {
 private:
  struct Storage_;

 public:
  WithErrorSyntax_HandleInResult_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_HandleInResult_Response(::zx::handle h) noexcept
      : storage_({.h = std::move(h)}) {}
  WithErrorSyntax_HandleInResult_Response()
      : WithErrorSyntax_HandleInResult_Response(Storage_{}) {}

  WithErrorSyntax_HandleInResult_Response(
      WithErrorSyntax_HandleInResult_Response&&) noexcept = default;
  WithErrorSyntax_HandleInResult_Response& operator=(
      WithErrorSyntax_HandleInResult_Response&&) noexcept = default;

  const ::zx::handle& h() const { return storage_.h; }

  ::zx::handle& h() { return storage_.h; }

 private:
  struct Storage_ final {
    ::zx::handle h{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntax_HandleInResult_Response, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntax_HandleInResult_Response>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::handle,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE,
                                                        0x80000000, false>>{
          &Storage_::h, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

class WithErrorSyntax_HandleInResult_Result {
 private:
  using Storage_ =
      cpp17::variant<cpp17::monostate,
                     ::test_protocols::WithErrorSyntax_HandleInResult_Response,
                     uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  WithErrorSyntax_HandleInResult_Result()
      : storage_(std::make_shared<Storage_>()) {}

  WithErrorSyntax_HandleInResult_Result(
      WithErrorSyntax_HandleInResult_Result&&) noexcept = default;
  WithErrorSyntax_HandleInResult_Result& operator=(
      WithErrorSyntax_HandleInResult_Result&&) noexcept = default;

  constexpr ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag Which()
      const {
    return WithErrorSyntax_HandleInResult_Result::IndexToTag(storage_->index());
  }
  static WithErrorSyntax_HandleInResult_Result WithResponse(
      ::test_protocols::WithErrorSyntax_HandleInResult_Response val) {
    return WithErrorSyntax_HandleInResult_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static WithErrorSyntax_HandleInResult_Result WithErr(uint32_t val) {
    return WithErrorSyntax_HandleInResult_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_HandleInResult_Result>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalUnionMember<
                          ::fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntax_HandleInResult_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::fidl::internal::NaturalDecoder* decoder,
      ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
        return 2;
      default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag
  IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kResponse;
    }
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

class WithErrorSyntaxHandleInResultTopResponse {
 private:
  struct Storage_;

 public:
  WithErrorSyntaxHandleInResultTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxHandleInResultTopResponse(
      ::test_protocols::WithErrorSyntax_HandleInResult_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxHandleInResultTopResponse()
      : WithErrorSyntaxHandleInResultTopResponse(Storage_{}) {}

  WithErrorSyntaxHandleInResultTopResponse(
      WithErrorSyntaxHandleInResultTopResponse&&) noexcept = default;
  WithErrorSyntaxHandleInResultTopResponse& operator=(
      WithErrorSyntaxHandleInResultTopResponse&&) noexcept = default;

  const ::test_protocols::WithErrorSyntax_HandleInResult_Result& result()
      const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_HandleInResult_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_protocols::WithErrorSyntax_HandleInResult_Result result{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::WithErrorSyntax_HandleInResult_Result,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::result, 0,
                                                        0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

class HandleRightsProtocolResponseMethodTopResponse {
 private:
  struct Storage_;

 public:
  HandleRightsProtocolResponseMethodTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolResponseMethodTopResponse(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolResponseMethodTopResponse()
      : HandleRightsProtocolResponseMethodTopResponse(Storage_{}) {}

  HandleRightsProtocolResponseMethodTopResponse(
      HandleRightsProtocolResponseMethodTopResponse&&) noexcept = default;
  HandleRightsProtocolResponseMethodTopResponse& operator=(
      HandleRightsProtocolResponseMethodTopResponse&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  struct Storage_ final {
    ::zx::socket h{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::zx::socket,
                      fidl::internal::NaturalCodingConstraintHandle<
                          ZX_OBJ_TYPE_SOCKET, 0x1, false>>{&Storage_::h, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

class HandleRightsProtocolResponseMethodRequest {
 private:
  struct Storage_;

 public:
  HandleRightsProtocolResponseMethodRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolResponseMethodRequest(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolResponseMethodRequest()
      : HandleRightsProtocolResponseMethodRequest(Storage_{}) {}

  HandleRightsProtocolResponseMethodRequest(
      HandleRightsProtocolResponseMethodRequest&&) noexcept = default;
  HandleRightsProtocolResponseMethodRequest& operator=(
      HandleRightsProtocolResponseMethodRequest&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  struct Storage_ final {
    ::zx::socket h{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::HandleRightsProtocolResponseMethodRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::HandleRightsProtocolResponseMethodRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::zx::socket,
                      fidl::internal::NaturalCodingConstraintHandle<
                          ZX_OBJ_TYPE_SOCKET, 0x3, false>>{&Storage_::h, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

class HandleRightsProtocolNoResponseMethodRequest {
 private:
  struct Storage_;

 public:
  HandleRightsProtocolNoResponseMethodRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolNoResponseMethodRequest(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolNoResponseMethodRequest()
      : HandleRightsProtocolNoResponseMethodRequest(Storage_{}) {}

  HandleRightsProtocolNoResponseMethodRequest(
      HandleRightsProtocolNoResponseMethodRequest&&) noexcept = default;
  HandleRightsProtocolNoResponseMethodRequest& operator=(
      HandleRightsProtocolNoResponseMethodRequest&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  struct Storage_ final {
    ::zx::socket h{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::zx::socket,
                      fidl::internal::NaturalCodingConstraintHandle<
                          ZX_OBJ_TYPE_SOCKET, 0x3, false>>{&Storage_::h, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

class HandleRightsProtocolAnEventRequest {
 private:
  struct Storage_;

 public:
  HandleRightsProtocolAnEventRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolAnEventRequest(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolAnEventRequest()
      : HandleRightsProtocolAnEventRequest(Storage_{}) {}

  HandleRightsProtocolAnEventRequest(
      HandleRightsProtocolAnEventRequest&&) noexcept = default;
  HandleRightsProtocolAnEventRequest& operator=(
      HandleRightsProtocolAnEventRequest&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  struct Storage_ final {
    ::zx::socket h{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::HandleRightsProtocolAnEventRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::HandleRightsProtocolAnEventRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::zx::socket,
                      fidl::internal::NaturalCodingConstraintHandle<
                          ZX_OBJ_TYPE_SOCKET, 0x3, false>>{&Storage_::h, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

class ChannelProtocolTakeHandleRequest {
 private:
  struct Storage_;

 public:
  ChannelProtocolTakeHandleRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolTakeHandleRequest(::zx::handle h) noexcept
      : storage_({.h = std::move(h)}) {}
  ChannelProtocolTakeHandleRequest()
      : ChannelProtocolTakeHandleRequest(Storage_{}) {}

  ChannelProtocolTakeHandleRequest(
      ChannelProtocolTakeHandleRequest&&) noexcept = default;
  ChannelProtocolTakeHandleRequest& operator=(
      ChannelProtocolTakeHandleRequest&&) noexcept = default;

  const ::zx::handle& h() const { return storage_.h; }

  ::zx::handle& h() { return storage_.h; }

 private:
  struct Storage_ final {
    ::zx::handle h{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolTakeHandleRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolTakeHandleRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::handle,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_NONE,
                                                        0x80000000, false>>{
          &Storage_::h, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

class ChannelProtocolMutateSocketTopResponse {
 private:
  struct Storage_;

 public:
  ChannelProtocolMutateSocketTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMutateSocketTopResponse(::zx::socket b) noexcept
      : storage_({.b = std::move(b)}) {}
  ChannelProtocolMutateSocketTopResponse()
      : ChannelProtocolMutateSocketTopResponse(Storage_{}) {}

  ChannelProtocolMutateSocketTopResponse(
      ChannelProtocolMutateSocketTopResponse&&) noexcept = default;
  ChannelProtocolMutateSocketTopResponse& operator=(
      ChannelProtocolMutateSocketTopResponse&&) noexcept = default;

  const ::zx::socket& b() const { return storage_.b; }

  ::zx::socket& b() { return storage_.b; }

 private:
  struct Storage_ final {
    ::zx::socket b{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolMutateSocketTopResponse, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolMutateSocketTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::socket,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET,
                                                        0x80000000, false>>{
          &Storage_::b, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

class ChannelProtocolMutateSocketRequest {
 private:
  struct Storage_;

 public:
  ChannelProtocolMutateSocketRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMutateSocketRequest(::zx::socket a) noexcept
      : storage_({.a = std::move(a)}) {}
  ChannelProtocolMutateSocketRequest()
      : ChannelProtocolMutateSocketRequest(Storage_{}) {}

  ChannelProtocolMutateSocketRequest(
      ChannelProtocolMutateSocketRequest&&) noexcept = default;
  ChannelProtocolMutateSocketRequest& operator=(
      ChannelProtocolMutateSocketRequest&&) noexcept = default;

  const ::zx::socket& a() const { return storage_.a; }

  ::zx::socket& a() { return storage_.a; }

 private:
  struct Storage_ final {
    ::zx::socket a{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolMutateSocketRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolMutateSocketRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::zx::socket,
          fidl::internal::NaturalCodingConstraintHandle<ZX_OBJ_TYPE_SOCKET,
                                                        0x80000000, false>>{
          &Storage_::a, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

class WithProtocolEndsServerEndsTopResponse {
 private:
  struct Storage_;

 public:
  WithProtocolEndsServerEndsTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsServerEndsTopResponse(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out) noexcept
      : storage_({.out = std::move(out)}) {}
  WithProtocolEndsServerEndsTopResponse()
      : WithProtocolEndsServerEndsTopResponse(Storage_{}) {}

  WithProtocolEndsServerEndsTopResponse(
      WithProtocolEndsServerEndsTopResponse&&) noexcept = default;
  WithProtocolEndsServerEndsTopResponse& operator=(
      WithProtocolEndsServerEndsTopResponse&&) noexcept = default;

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& out() const {
    return storage_.out;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& out() {
    return storage_.out;
  }

 private:
  struct Storage_ final {
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithProtocolEndsServerEndsTopResponse, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithProtocolEndsServerEndsTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
          &Storage_::out, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

class WithProtocolEndsServerEndsRequest {
 private:
  struct Storage_;

 public:
  WithProtocolEndsServerEndsRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsServerEndsRequest(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in) noexcept
      : storage_({.in = std::move(in)}) {}
  WithProtocolEndsServerEndsRequest()
      : WithProtocolEndsServerEndsRequest(Storage_{}) {}

  WithProtocolEndsServerEndsRequest(
      WithProtocolEndsServerEndsRequest&&) noexcept = default;
  WithProtocolEndsServerEndsRequest& operator=(
      WithProtocolEndsServerEndsRequest&&) noexcept = default;

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& in() const {
    return storage_.in;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& in() {
    return storage_.in;
  }

 private:
  struct Storage_ final {
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithProtocolEndsServerEndsRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithProtocolEndsServerEndsRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
          &Storage_::in, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

class WithProtocolEndsClientEndsTopResponse {
 private:
  struct Storage_;

 public:
  WithProtocolEndsClientEndsTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsClientEndsTopResponse(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out) noexcept
      : storage_({.out = std::move(out)}) {}
  WithProtocolEndsClientEndsTopResponse()
      : WithProtocolEndsClientEndsTopResponse(Storage_{}) {}

  WithProtocolEndsClientEndsTopResponse(
      WithProtocolEndsClientEndsTopResponse&&) noexcept = default;
  WithProtocolEndsClientEndsTopResponse& operator=(
      WithProtocolEndsClientEndsTopResponse&&) noexcept = default;

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& out() const {
    return storage_.out;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& out() {
    return storage_.out;
  }

 private:
  struct Storage_ final {
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithProtocolEndsClientEndsTopResponse, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithProtocolEndsClientEndsTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
          &Storage_::out, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

class WithProtocolEndsClientEndsRequest {
 private:
  struct Storage_;

 public:
  WithProtocolEndsClientEndsRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsClientEndsRequest(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in) noexcept
      : storage_({.in = std::move(in)}) {}
  WithProtocolEndsClientEndsRequest()
      : WithProtocolEndsClientEndsRequest(Storage_{}) {}

  WithProtocolEndsClientEndsRequest(
      WithProtocolEndsClientEndsRequest&&) noexcept = default;
  WithProtocolEndsClientEndsRequest& operator=(
      WithProtocolEndsClientEndsRequest&&) noexcept = default;

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& in() const {
    return storage_.in;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& in() {
    return storage_.in;
  }

 private:
  struct Storage_ final {
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithProtocolEndsClientEndsRequest, 4, 4>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithProtocolEndsClientEndsRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
          &Storage_::in, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

class WithErrorSyntax_ResponseAsStruct_Response {
 private:
  struct Storage_;

 public:
  WithErrorSyntax_ResponseAsStruct_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_ResponseAsStruct_Response(int64_t a, int64_t b,
                                            int64_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  WithErrorSyntax_ResponseAsStruct_Response()
      : WithErrorSyntax_ResponseAsStruct_Response(Storage_{}) {}

  WithErrorSyntax_ResponseAsStruct_Response(
      WithErrorSyntax_ResponseAsStruct_Response&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Response& operator=(
      WithErrorSyntax_ResponseAsStruct_Response&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Response(
      const WithErrorSyntax_ResponseAsStruct_Response& other) noexcept
      : WithErrorSyntax_ResponseAsStruct_Response(other.CloneStorage_()) {}
  WithErrorSyntax_ResponseAsStruct_Response& operator=(
      const WithErrorSyntax_ResponseAsStruct_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntax_ResponseAsStruct_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response, 24,
        24>::Equal(this, &other);
  }
  bool operator!=(
      const WithErrorSyntax_ResponseAsStruct_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response, 24,
        24>::Equal(this, &other);
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

  int64_t c() const { return storage_.c; }

  int64_t& c() { return storage_.c; }

 private:
  struct Storage_ final {
    int64_t a{};
    int64_t b{};
    int64_t c{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response, 24, 24>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::a, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::b, 8, 8},
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::c, 16, 16});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

class WithErrorSyntax_ResponseAsStruct_Result {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  WithErrorSyntax_ResponseAsStruct_Result()
      : storage_(std::make_shared<Storage_>()) {}

  WithErrorSyntax_ResponseAsStruct_Result(
      WithErrorSyntax_ResponseAsStruct_Result&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Result& operator=(
      WithErrorSyntax_ResponseAsStruct_Result&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Result(
      const WithErrorSyntax_ResponseAsStruct_Result& other) noexcept
      : WithErrorSyntax_ResponseAsStruct_Result(other.CloneStorage_()) {}
  WithErrorSyntax_ResponseAsStruct_Result& operator=(
      const WithErrorSyntax_ResponseAsStruct_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntax_ResponseAsStruct_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const WithErrorSyntax_ResponseAsStruct_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag
  Which() const {
    return WithErrorSyntax_ResponseAsStruct_Result::IndexToTag(
        storage_->index());
  }
  static WithErrorSyntax_ResponseAsStruct_Result WithResponse(
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response val) {
    return WithErrorSyntax_ResponseAsStruct_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static WithErrorSyntax_ResponseAsStruct_Result WithErr(uint32_t val) {
    return WithErrorSyntax_ResponseAsStruct_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalUnionMember<
                          ::fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntax_ResponseAsStruct_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::fidl::internal::NaturalDecoder* decoder,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr:
        return 2;
      default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::
      Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

class WithErrorSyntaxResponseAsStructTopResponse {
 private:
  struct Storage_;

 public:
  WithErrorSyntaxResponseAsStructTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxResponseAsStructTopResponse(
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxResponseAsStructTopResponse()
      : WithErrorSyntaxResponseAsStructTopResponse(Storage_{}) {}

  WithErrorSyntaxResponseAsStructTopResponse(
      WithErrorSyntaxResponseAsStructTopResponse&&) noexcept = default;
  WithErrorSyntaxResponseAsStructTopResponse& operator=(
      WithErrorSyntaxResponseAsStructTopResponse&&) noexcept = default;
  WithErrorSyntaxResponseAsStructTopResponse(
      const WithErrorSyntaxResponseAsStructTopResponse& other) noexcept
      : WithErrorSyntaxResponseAsStructTopResponse(other.CloneStorage_()) {}
  WithErrorSyntaxResponseAsStructTopResponse& operator=(
      const WithErrorSyntaxResponseAsStructTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntaxResponseAsStructTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const WithErrorSyntaxResponseAsStructTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 24,
        16>::Equal(this, &other);
  }

  const ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result& result()
      const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::result, 0,
                                                        0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

class WithErrorSyntax_ErrorAsPrimitive_Response {
 private:
  struct Storage_;

 public:
  WithErrorSyntax_ErrorAsPrimitive_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_ErrorAsPrimitive_Response(uint8_t __reserved) noexcept
      : storage_({.__reserved = std::move(__reserved)}) {}
  WithErrorSyntax_ErrorAsPrimitive_Response()
      : WithErrorSyntax_ErrorAsPrimitive_Response(Storage_{}) {}

  WithErrorSyntax_ErrorAsPrimitive_Response(
      WithErrorSyntax_ErrorAsPrimitive_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Response& operator=(
      WithErrorSyntax_ErrorAsPrimitive_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Response(
      const WithErrorSyntax_ErrorAsPrimitive_Response& other) noexcept
      : WithErrorSyntax_ErrorAsPrimitive_Response(other.CloneStorage_()) {}
  WithErrorSyntax_ErrorAsPrimitive_Response& operator=(
      const WithErrorSyntax_ErrorAsPrimitive_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntax_ErrorAsPrimitive_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const WithErrorSyntax_ErrorAsPrimitive_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response, 1,
        1>::Equal(this, &other);
  }

  uint8_t __reserved() const { return storage_.__reserved; }

  uint8_t& __reserved() { return storage_.__reserved; }

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::__reserved, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

class WithErrorSyntax_ErrorAsPrimitive_Result {
 private:
  using Storage_ = cpp17::variant<
      cpp17::monostate,
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  WithErrorSyntax_ErrorAsPrimitive_Result()
      : storage_(std::make_shared<Storage_>()) {}

  WithErrorSyntax_ErrorAsPrimitive_Result(
      WithErrorSyntax_ErrorAsPrimitive_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(
      WithErrorSyntax_ErrorAsPrimitive_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Result(
      const WithErrorSyntax_ErrorAsPrimitive_Result& other) noexcept
      : WithErrorSyntax_ErrorAsPrimitive_Result(other.CloneStorage_()) {}
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(
      const WithErrorSyntax_ErrorAsPrimitive_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntax_ErrorAsPrimitive_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const WithErrorSyntax_ErrorAsPrimitive_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag
  Which() const {
    return WithErrorSyntax_ErrorAsPrimitive_Result::IndexToTag(
        storage_->index());
  }
  static WithErrorSyntax_ErrorAsPrimitive_Result WithResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response val) {
    return WithErrorSyntax_ErrorAsPrimitive_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static WithErrorSyntax_ErrorAsPrimitive_Result WithErr(uint32_t val) {
    return WithErrorSyntax_ErrorAsPrimitive_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalUnionMember<
                          ::fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntax_ErrorAsPrimitive_Result(
      std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::fidl::internal::NaturalDecoder* decoder,
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
        return 2;
      default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
      Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

class WithErrorSyntaxErrorAsPrimitiveTopResponse {
 private:
  struct Storage_;

 public:
  WithErrorSyntaxErrorAsPrimitiveTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxErrorAsPrimitiveTopResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxErrorAsPrimitiveTopResponse()
      : WithErrorSyntaxErrorAsPrimitiveTopResponse(Storage_{}) {}

  WithErrorSyntaxErrorAsPrimitiveTopResponse(
      WithErrorSyntaxErrorAsPrimitiveTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsPrimitiveTopResponse& operator=(
      WithErrorSyntaxErrorAsPrimitiveTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsPrimitiveTopResponse(
      const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) noexcept
      : WithErrorSyntaxErrorAsPrimitiveTopResponse(other.CloneStorage_()) {}
  WithErrorSyntaxErrorAsPrimitiveTopResponse& operator=(
      const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 24,
        16>::Equal(this, &other);
  }

  const ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result& result()
      const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::result, 0,
                                                        0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

class WithErrorSyntax_ErrorAsEnum_Response {
 private:
  struct Storage_;

 public:
  WithErrorSyntax_ErrorAsEnum_Response(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_ErrorAsEnum_Response(uint8_t __reserved) noexcept
      : storage_({.__reserved = std::move(__reserved)}) {}
  WithErrorSyntax_ErrorAsEnum_Response()
      : WithErrorSyntax_ErrorAsEnum_Response(Storage_{}) {}

  WithErrorSyntax_ErrorAsEnum_Response(
      WithErrorSyntax_ErrorAsEnum_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Response& operator=(
      WithErrorSyntax_ErrorAsEnum_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Response(
      const WithErrorSyntax_ErrorAsEnum_Response& other) noexcept
      : WithErrorSyntax_ErrorAsEnum_Response(other.CloneStorage_()) {}
  WithErrorSyntax_ErrorAsEnum_Response& operator=(
      const WithErrorSyntax_ErrorAsEnum_Response& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntax_ErrorAsEnum_Response& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response, 1,
        1>::Equal(this, &other);
  }
  bool operator!=(
      const WithErrorSyntax_ErrorAsEnum_Response& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response, 1,
        1>::Equal(this, &other);
  }

  uint8_t __reserved() const { return storage_.__reserved; }

  uint8_t& __reserved() { return storage_.__reserved; }

 private:
  struct Storage_ final {
    uint8_t __reserved = 0u;
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response, 1, 1>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, uint8_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::__reserved, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

class WithAndWithoutRequestResponseWithRequestWithResponseTopResponse {
 private:
  struct Storage_;

 public:
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      ::std::string ret) noexcept
      : storage_({.ret = std::move(ret)}) {}
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse()
      : WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            Storage_{}) {}

  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse& operator=(
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      const WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            other.CloneStorage_()) {}
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse& operator=(
      const WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
          other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
        16, 16>::Equal(this, &other);
  }
  bool operator!=(
      const WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
          other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
        16, 16>::Equal(this, &other);
  }

  const ::std::string& ret() const { return storage_.ret; }

  ::std::string& ret() { return storage_.ret; }

 private:
  struct Storage_ final {
    ::std::string ret{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
      16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::string,
                      fidl::internal::NaturalCodingConstraintString<>>{
          &Storage_::ret, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

class WithAndWithoutRequestResponseWithRequestWithResponseRequest {
 private:
  struct Storage_;

 public:
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      ::std::string arg) noexcept
      : storage_({.arg = std::move(arg)}) {}
  WithAndWithoutRequestResponseWithRequestWithResponseRequest()
      : WithAndWithoutRequestResponseWithRequestWithResponseRequest(
            Storage_{}) {}

  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      WithAndWithoutRequestResponseWithRequestWithResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseRequest& operator=(
      WithAndWithoutRequestResponseWithRequestWithResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      const WithAndWithoutRequestResponseWithRequestWithResponseRequest&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestWithResponseRequest(
            other.CloneStorage_()) {}
  WithAndWithoutRequestResponseWithRequestWithResponseRequest& operator=(
      const WithAndWithoutRequestResponseWithRequestWithResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithAndWithoutRequestResponseWithRequestWithResponseRequest& other)
      const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest,
        16, 16>::Equal(this, &other);
  }
  bool operator!=(
      const WithAndWithoutRequestResponseWithRequestWithResponseRequest& other)
      const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestWithResponseRequest,
        16, 16>::Equal(this, &other);
  }

  const ::std::string& arg() const { return storage_.arg; }

  ::std::string& arg() { return storage_.arg; }

 private:
  struct Storage_ final {
    ::std::string arg{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest,
      16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::string,
                      fidl::internal::NaturalCodingConstraintString<>>{
          &Storage_::arg, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

class WithAndWithoutRequestResponseWithRequestNoResponseRequest {
 private:
  struct Storage_;

 public:
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      ::std::string arg) noexcept
      : storage_({.arg = std::move(arg)}) {}
  WithAndWithoutRequestResponseWithRequestNoResponseRequest()
      : WithAndWithoutRequestResponseWithRequestNoResponseRequest(Storage_{}) {}

  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      WithAndWithoutRequestResponseWithRequestNoResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestNoResponseRequest& operator=(
      WithAndWithoutRequestResponseWithRequestNoResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      const WithAndWithoutRequestResponseWithRequestNoResponseRequest&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestNoResponseRequest(
            other.CloneStorage_()) {}
  WithAndWithoutRequestResponseWithRequestNoResponseRequest& operator=(
      const WithAndWithoutRequestResponseWithRequestNoResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithAndWithoutRequestResponseWithRequestNoResponseRequest& other)
      const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestNoResponseRequest,
        16, 16>::Equal(this, &other);
  }
  bool operator!=(
      const WithAndWithoutRequestResponseWithRequestNoResponseRequest& other)
      const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestNoResponseRequest,
        16, 16>::Equal(this, &other);
  }

  const ::std::string& arg() const { return storage_.arg; }

  ::std::string& arg() { return storage_.arg; }

 private:
  struct Storage_ final {
    ::std::string arg{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest,
      16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::string,
                      fidl::internal::NaturalCodingConstraintString<>>{
          &Storage_::arg, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest {
 private:
  struct Storage_;

 public:
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      ::std::string arg) noexcept
      : storage_({.arg = std::move(arg)}) {}
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest()
      : WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
            Storage_{}) {}

  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& operator=(
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
            other.CloneStorage_()) {}
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& operator=(
      const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& other)
      const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        16, 16>::Equal(this, &other);
  }
  bool operator!=(
      const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& other)
      const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
        16, 16>::Equal(this, &other);
  }

  const ::std::string& arg() const { return storage_.arg; }

  ::std::string& arg() { return storage_.arg; }

 private:
  struct Storage_ final {
    ::std::string arg{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
      16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::string,
                      fidl::internal::NaturalCodingConstraintString<>>{
          &Storage_::arg, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

class WithAndWithoutRequestResponseOnWithResponseRequest {
 private:
  struct Storage_;

 public:
  WithAndWithoutRequestResponseOnWithResponseRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseOnWithResponseRequest(::std::string ret) noexcept
      : storage_({.ret = std::move(ret)}) {}
  WithAndWithoutRequestResponseOnWithResponseRequest()
      : WithAndWithoutRequestResponseOnWithResponseRequest(Storage_{}) {}

  WithAndWithoutRequestResponseOnWithResponseRequest(
      WithAndWithoutRequestResponseOnWithResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseOnWithResponseRequest& operator=(
      WithAndWithoutRequestResponseOnWithResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseOnWithResponseRequest(
      const WithAndWithoutRequestResponseOnWithResponseRequest& other) noexcept
      : WithAndWithoutRequestResponseOnWithResponseRequest(
            other.CloneStorage_()) {}
  WithAndWithoutRequestResponseOnWithResponseRequest& operator=(
      const WithAndWithoutRequestResponseOnWithResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const WithAndWithoutRequestResponseOnWithResponseRequest&
                      other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest,
        16, 16>::Equal(this, &other);
  }
  bool operator!=(const WithAndWithoutRequestResponseOnWithResponseRequest&
                      other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest,
        16, 16>::Equal(this, &other);
  }

  const ::std::string& ret() const { return storage_.ret; }

  ::std::string& ret() { return storage_.ret; }

 private:
  struct Storage_ final {
    ::std::string ret{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest, 16,
      16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::string,
                      fidl::internal::NaturalCodingConstraintString<>>{
          &Storage_::ret, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

class WithAndWithoutRequestResponseNoRequestWithResponseTopResponse {
 private:
  struct Storage_;

 public:
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      ::std::string ret) noexcept
      : storage_({.ret = std::move(ret)}) {}
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse()
      : WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            Storage_{}) {}

  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse& operator=(
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      const WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
          other) noexcept
      : WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            other.CloneStorage_()) {}
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse& operator=(
      const WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
          other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
          other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
        16, 16>::Equal(this, &other);
  }
  bool operator!=(
      const WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
          other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::
            WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
        16, 16>::Equal(this, &other);
  }

  const ::std::string& ret() const { return storage_.ret; }

  ::std::string& ret() { return storage_.ret; }

 private:
  struct Storage_ final {
    ::std::string ret{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
      16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalStructMember<
                      Storage_, ::std::string,
                      fidl::internal::NaturalCodingConstraintString<>>{
          &Storage_::ret, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

class TransitionalRequestTopResponse {
 private:
  struct Storage_;

 public:
  TransitionalRequestTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalRequestTopResponse(int64_t y) noexcept
      : storage_({.y = std::move(y)}) {}
  TransitionalRequestTopResponse()
      : TransitionalRequestTopResponse(Storage_{}) {}

  TransitionalRequestTopResponse(TransitionalRequestTopResponse&&) noexcept =
      default;
  TransitionalRequestTopResponse& operator=(
      TransitionalRequestTopResponse&&) noexcept = default;
  TransitionalRequestTopResponse(
      const TransitionalRequestTopResponse& other) noexcept
      : TransitionalRequestTopResponse(other.CloneStorage_()) {}
  TransitionalRequestTopResponse& operator=(
      const TransitionalRequestTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const TransitionalRequestTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalRequestTopResponse, 8, 8>::Equal(this,
                                                                       &other);
  }
  bool operator!=(const TransitionalRequestTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalRequestTopResponse, 8, 8>::Equal(this,
                                                                       &other);
  }

  int64_t y() const { return storage_.y; }

  int64_t& y() { return storage_.y; }

 private:
  struct Storage_ final {
    int64_t y{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::TransitionalRequestTopResponse, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::TransitionalRequestTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::y, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

class TransitionalRequestRequest {
 private:
  struct Storage_;

 public:
  TransitionalRequestRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalRequestRequest(int64_t x) noexcept
      : storage_({.x = std::move(x)}) {}
  TransitionalRequestRequest() : TransitionalRequestRequest(Storage_{}) {}

  TransitionalRequestRequest(TransitionalRequestRequest&&) noexcept = default;
  TransitionalRequestRequest& operator=(TransitionalRequestRequest&&) noexcept =
      default;
  TransitionalRequestRequest(const TransitionalRequestRequest& other) noexcept
      : TransitionalRequestRequest(other.CloneStorage_()) {}
  TransitionalRequestRequest& operator=(
      const TransitionalRequestRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const TransitionalRequestRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalRequestRequest, 8, 8>::Equal(this,
                                                                   &other);
  }
  bool operator!=(const TransitionalRequestRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalRequestRequest, 8, 8>::Equal(this,
                                                                   &other);
  }

  int64_t x() const { return storage_.x; }

  int64_t& x() { return storage_.x; }

 private:
  struct Storage_ final {
    int64_t x{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::TransitionalRequestRequest, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::TransitionalRequestRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::x, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

class TransitionalOneWayRequest {
 private:
  struct Storage_;

 public:
  TransitionalOneWayRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalOneWayRequest(int64_t x) noexcept
      : storage_({.x = std::move(x)}) {}
  TransitionalOneWayRequest() : TransitionalOneWayRequest(Storage_{}) {}

  TransitionalOneWayRequest(TransitionalOneWayRequest&&) noexcept = default;
  TransitionalOneWayRequest& operator=(TransitionalOneWayRequest&&) noexcept =
      default;
  TransitionalOneWayRequest(const TransitionalOneWayRequest& other) noexcept
      : TransitionalOneWayRequest(other.CloneStorage_()) {}
  TransitionalOneWayRequest& operator=(
      const TransitionalOneWayRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const TransitionalOneWayRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalOneWayRequest, 8, 8>::Equal(this, &other);
  }
  bool operator!=(const TransitionalOneWayRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalOneWayRequest, 8, 8>::Equal(this, &other);
  }

  int64_t x() const { return storage_.x; }

  int64_t& x() { return storage_.x; }

 private:
  struct Storage_ final {
    int64_t x{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::TransitionalOneWayRequest, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::TransitionalOneWayRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::x, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

class TransitionalEventRequest {
 private:
  struct Storage_;

 public:
  TransitionalEventRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalEventRequest(int64_t x) noexcept
      : storage_({.x = std::move(x)}) {}
  TransitionalEventRequest() : TransitionalEventRequest(Storage_{}) {}

  TransitionalEventRequest(TransitionalEventRequest&&) noexcept = default;
  TransitionalEventRequest& operator=(TransitionalEventRequest&&) noexcept =
      default;
  TransitionalEventRequest(const TransitionalEventRequest& other) noexcept
      : TransitionalEventRequest(other.CloneStorage_()) {}
  TransitionalEventRequest& operator=(
      const TransitionalEventRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const TransitionalEventRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalEventRequest, 8, 8>::Equal(this, &other);
  }
  bool operator!=(const TransitionalEventRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::TransitionalEventRequest, 8, 8>::Equal(this, &other);
  }

  int64_t x() const { return storage_.x; }

  int64_t& x() { return storage_.x; }

 private:
  struct Storage_ final {
    int64_t x{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::TransitionalEventRequest, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::TransitionalEventRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::x, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_TheUnionTable;

class TheUnion {
 private:
  using Storage_ = cpp17::variant<cpp17::monostate, uint32_t>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kV = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

  // Create an unknown value of this union.
  TheUnion() : storage_(std::make_shared<Storage_>()) {}

  TheUnion(TheUnion&&) noexcept = default;
  TheUnion& operator=(TheUnion&&) noexcept = default;
  TheUnion(const TheUnion& other) noexcept : TheUnion(other.CloneStorage_()) {}
  TheUnion& operator=(const TheUnion& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const TheUnion& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(const TheUnion& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_protocols::TheUnion::Tag Which() const {
    return TheUnion::IndexToTag(storage_->index());
  }
  static TheUnion WithV(uint32_t val) {
    return TheUnion(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> v() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> v() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::TheUnion>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalUnionMember<
                          ::fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>());

  explicit TheUnion(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::fidl::internal::NaturalDecoder* decoder,
                                     ::test_protocols::TheUnion::Tag tag) {
    switch (tag) {
      case ::test_protocols::TheUnion::Tag::kV:
        return 1;
      case ::test_protocols::TheUnion::Tag::kUnknown:
        return 0;
      default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr ::test_protocols::TheUnion::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::TheUnion::Tag::kV;
      default:
        return ::test_protocols::TheUnion::Tag::kUnknown;
    }
  }
};

extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

class MethodWithUnionUnionMethodRequest {
 private:
  struct Storage_;

 public:
  MethodWithUnionUnionMethodRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  MethodWithUnionUnionMethodRequest(::test_protocols::TheUnion u) noexcept
      : storage_({.u = std::move(u)}) {}
  MethodWithUnionUnionMethodRequest()
      : MethodWithUnionUnionMethodRequest(Storage_{}) {}

  MethodWithUnionUnionMethodRequest(
      MethodWithUnionUnionMethodRequest&&) noexcept = default;
  MethodWithUnionUnionMethodRequest& operator=(
      MethodWithUnionUnionMethodRequest&&) noexcept = default;
  MethodWithUnionUnionMethodRequest(
      const MethodWithUnionUnionMethodRequest& other) noexcept
      : MethodWithUnionUnionMethodRequest(other.CloneStorage_()) {}
  MethodWithUnionUnionMethodRequest& operator=(
      const MethodWithUnionUnionMethodRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const MethodWithUnionUnionMethodRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::MethodWithUnionUnionMethodRequest, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const MethodWithUnionUnionMethodRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::MethodWithUnionUnionMethodRequest, 24,
        16>::Equal(this, &other);
  }

  const ::test_protocols::TheUnion& u() const { return storage_.u; }

  ::test_protocols::TheUnion& u() { return storage_.u; }

 private:
  struct Storage_ final {
    ::test_protocols::TheUnion u{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::MethodWithUnionUnionMethodRequest, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::MethodWithUnionUnionMethodRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::TheUnion,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::u, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

class SyscallProtocolMethodCRequest {
 private:
  struct Storage_;

 public:
  SyscallProtocolMethodCRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  SyscallProtocolMethodCRequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  SyscallProtocolMethodCRequest() : SyscallProtocolMethodCRequest(Storage_{}) {}

  SyscallProtocolMethodCRequest(SyscallProtocolMethodCRequest&&) noexcept =
      default;
  SyscallProtocolMethodCRequest& operator=(
      SyscallProtocolMethodCRequest&&) noexcept = default;
  SyscallProtocolMethodCRequest(
      const SyscallProtocolMethodCRequest& other) noexcept
      : SyscallProtocolMethodCRequest(other.CloneStorage_()) {}
  SyscallProtocolMethodCRequest& operator=(
      const SyscallProtocolMethodCRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const SyscallProtocolMethodCRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::SyscallProtocolMethodCRequest, 16, 16>::Equal(this,
                                                                        &other);
  }
  bool operator!=(const SyscallProtocolMethodCRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::SyscallProtocolMethodCRequest, 16, 16>::Equal(this,
                                                                        &other);
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int64_t a{};
    int64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::SyscallProtocolMethodCRequest, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::SyscallProtocolMethodCRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::a, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::b, 8, 8});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

class ProtocolEnds {
 private:
  struct Storage_;

 public:
  ProtocolEnds(Storage_ storage) noexcept : storage_(std::move(storage)) {}
  ProtocolEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client,
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server,
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt,
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>
          server_opt) noexcept
      : storage_({.client = std::move(client),
                  .server = std::move(server),
                  .client_opt = std::move(client_opt),
                  .server_opt = std::move(server_opt)}) {}
  ProtocolEnds() : ProtocolEnds(Storage_{}) {}

  ProtocolEnds(ProtocolEnds&&) noexcept = default;
  ProtocolEnds& operator=(ProtocolEnds&&) noexcept = default;

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client()
      const {
    return storage_.client;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client() {
    return storage_.client;
  }

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server()
      const {
    return storage_.server;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server() {
    return storage_.server;
  }

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client_opt()
      const {
    return storage_.client_opt;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client_opt() {
    return storage_.client_opt;
  }

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server_opt()
      const {
    return storage_.server_opt;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server_opt() {
    return storage_.server_opt;
  }

 private:
  struct Storage_ final {
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client{};
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server{};
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt{};
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ProtocolEnds, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<::test_protocols::ProtocolEnds>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
          &Storage_::client, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, false>>{
          &Storage_::server, 4, 4},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
          &Storage_::client_opt, 8, 8},
      ::fidl::internal::NaturalStructMember<
          Storage_, ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>,
          fidl::internal::NaturalCodingConstraintHandle<
              ZX_OBJ_TYPE_CHANNEL, ZX_DEFAULT_CHANNEL_RIGHTS, true>>{
          &Storage_::server_opt, 12, 12});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

class WithProtocolEndsStructContainingEndsTopResponse {
 private:
  struct Storage_;

 public:
  WithProtocolEndsStructContainingEndsTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsStructContainingEndsTopResponse(
      ::test_protocols::ProtocolEnds out) noexcept
      : storage_({.out = std::move(out)}) {}
  WithProtocolEndsStructContainingEndsTopResponse()
      : WithProtocolEndsStructContainingEndsTopResponse(Storage_{}) {}

  WithProtocolEndsStructContainingEndsTopResponse(
      WithProtocolEndsStructContainingEndsTopResponse&&) noexcept = default;
  WithProtocolEndsStructContainingEndsTopResponse& operator=(
      WithProtocolEndsStructContainingEndsTopResponse&&) noexcept = default;

  const ::test_protocols::ProtocolEnds& out() const { return storage_.out; }

  ::test_protocols::ProtocolEnds& out() { return storage_.out; }

 private:
  struct Storage_ final {
    ::test_protocols::ProtocolEnds out{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse, 16,
      16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::ProtocolEnds,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::out, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

class WithProtocolEndsStructContainingEndsRequest {
 private:
  struct Storage_;

 public:
  WithProtocolEndsStructContainingEndsRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsStructContainingEndsRequest(
      ::test_protocols::ProtocolEnds in) noexcept
      : storage_({.in = std::move(in)}) {}
  WithProtocolEndsStructContainingEndsRequest()
      : WithProtocolEndsStructContainingEndsRequest(Storage_{}) {}

  WithProtocolEndsStructContainingEndsRequest(
      WithProtocolEndsStructContainingEndsRequest&&) noexcept = default;
  WithProtocolEndsStructContainingEndsRequest& operator=(
      WithProtocolEndsStructContainingEndsRequest&&) noexcept = default;

  const ::test_protocols::ProtocolEnds& in() const { return storage_.in; }

  ::test_protocols::ProtocolEnds& in() { return storage_.in; }

 private:
  struct Storage_ final {
    ::test_protocols::ProtocolEnds in{};
  };

  Storage_ storage_;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::ProtocolEnds,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::in, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

#endif  // __Fuchsia__

extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

class ManyParametersFifteenRequest {
 private:
  struct Storage_;

 public:
  ManyParametersFifteenRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ManyParametersFifteenRequest(bool p1, bool p2, bool p3, bool p4, bool p5,
                               bool p6, bool p7, bool p8, bool p9, bool p10,
                               bool p11, bool p12, bool p13, bool p14,
                               bool p15) noexcept
      : storage_({.p1 = std::move(p1),
                  .p2 = std::move(p2),
                  .p3 = std::move(p3),
                  .p4 = std::move(p4),
                  .p5 = std::move(p5),
                  .p6 = std::move(p6),
                  .p7 = std::move(p7),
                  .p8 = std::move(p8),
                  .p9 = std::move(p9),
                  .p10 = std::move(p10),
                  .p11 = std::move(p11),
                  .p12 = std::move(p12),
                  .p13 = std::move(p13),
                  .p14 = std::move(p14),
                  .p15 = std::move(p15)}) {}
  ManyParametersFifteenRequest() : ManyParametersFifteenRequest(Storage_{}) {}

  ManyParametersFifteenRequest(ManyParametersFifteenRequest&&) noexcept =
      default;
  ManyParametersFifteenRequest& operator=(
      ManyParametersFifteenRequest&&) noexcept = default;
  ManyParametersFifteenRequest(
      const ManyParametersFifteenRequest& other) noexcept
      : ManyParametersFifteenRequest(other.CloneStorage_()) {}
  ManyParametersFifteenRequest& operator=(
      const ManyParametersFifteenRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ManyParametersFifteenRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ManyParametersFifteenRequest, 15, 15>::Equal(this,
                                                                       &other);
  }
  bool operator!=(const ManyParametersFifteenRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ManyParametersFifteenRequest, 15, 15>::Equal(this,
                                                                       &other);
  }

  bool p1() const { return storage_.p1; }

  bool& p1() { return storage_.p1; }

  bool p2() const { return storage_.p2; }

  bool& p2() { return storage_.p2; }

  bool p3() const { return storage_.p3; }

  bool& p3() { return storage_.p3; }

  bool p4() const { return storage_.p4; }

  bool& p4() { return storage_.p4; }

  bool p5() const { return storage_.p5; }

  bool& p5() { return storage_.p5; }

  bool p6() const { return storage_.p6; }

  bool& p6() { return storage_.p6; }

  bool p7() const { return storage_.p7; }

  bool& p7() { return storage_.p7; }

  bool p8() const { return storage_.p8; }

  bool& p8() { return storage_.p8; }

  bool p9() const { return storage_.p9; }

  bool& p9() { return storage_.p9; }

  bool p10() const { return storage_.p10; }

  bool& p10() { return storage_.p10; }

  bool p11() const { return storage_.p11; }

  bool& p11() { return storage_.p11; }

  bool p12() const { return storage_.p12; }

  bool& p12() { return storage_.p12; }

  bool p13() const { return storage_.p13; }

  bool& p13() { return storage_.p13; }

  bool p14() const { return storage_.p14; }

  bool& p14() { return storage_.p14; }

  bool p15() const { return storage_.p15; }

  bool& p15() { return storage_.p15; }

 private:
  struct Storage_ final {
    bool p1{};
    bool p2{};
    bool p3{};
    bool p4{};
    bool p5{};
    bool p6{};
    bool p7{};
    bool p8{};
    bool p9{};
    bool p10{};
    bool p11{};
    bool p12{};
    bool p13{};
    bool p14{};
    bool p15{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ManyParametersFifteenRequest, 15, 15>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ManyParametersFifteenRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p1, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p2, 1, 1},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p3, 2, 2},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p4, 3, 3},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p5, 4, 4},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p6, 5, 5},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p7, 6, 6},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p8, 7, 7},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p9, 8, 8},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p10, 9, 9},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p11, 10, 10},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p12, 11, 11},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p13, 12, 12},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p14, 13, 13},
      ::fidl::internal::NaturalStructMember<
          Storage_, bool, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::p15, 14, 14});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

class WithErrorSyntax_ErrorAsEnum_Result {
 private:
  using Storage_ =
      cpp17::variant<cpp17::monostate,
                     ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response,
                     ::test_protocols::ErrorEnum>;

 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

  // Create an unknown value of this union.
  WithErrorSyntax_ErrorAsEnum_Result()
      : storage_(std::make_shared<Storage_>()) {}

  WithErrorSyntax_ErrorAsEnum_Result(
      WithErrorSyntax_ErrorAsEnum_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Result& operator=(
      WithErrorSyntax_ErrorAsEnum_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Result(
      const WithErrorSyntax_ErrorAsEnum_Result& other) noexcept
      : WithErrorSyntax_ErrorAsEnum_Result(other.CloneStorage_()) {}
  WithErrorSyntax_ErrorAsEnum_Result& operator=(
      const WithErrorSyntax_ErrorAsEnum_Result& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntax_ErrorAsEnum_Result& other) const noexcept {
    return *storage_ == *other.storage_;
  }
  bool operator!=(
      const WithErrorSyntax_ErrorAsEnum_Result& other) const noexcept {
    return *storage_ != *other.storage_;
  }

  constexpr ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag Which()
      const {
    return WithErrorSyntax_ErrorAsEnum_Result::IndexToTag(storage_->index());
  }
  static WithErrorSyntax_ErrorAsEnum_Result WithResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response val) {
    return WithErrorSyntax_ErrorAsEnum_Result(
        std::make_shared<Storage_>(std::in_place_index_t<1>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage_> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage_> response() {
    return ::fidl::internal::UnionMemberView<1, Storage_>(storage_);
  }
  static WithErrorSyntax_ErrorAsEnum_Result WithErr(
      ::test_protocols::ErrorEnum val) {
    return WithErrorSyntax_ErrorAsEnum_Result(
        std::make_shared<Storage_>(std::in_place_index_t<2>{}, std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage_> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage_> err() {
    return ::fidl::internal::UnionMemberView<2, Storage_>(storage_);
  }

 private:
  std::shared_ptr<Storage_> storage_;
  std::shared_ptr<Storage_> CloneStorage_() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>;
  static constexpr auto kMembers =
      std::make_tuple(::fidl::internal::NaturalUnionMember<
                          ::fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>(),
                      ::fidl::internal::NaturalUnionMember<
                          fidl::internal::NaturalCodingConstraintEmpty>());

  explicit WithErrorSyntax_ErrorAsEnum_Result(std::shared_ptr<Storage_> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::fidl::internal::NaturalDecoder* decoder,
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
        return 2;
      default: {
        decoder->SetError(::fidl::internal::kCodingErrorUnknownUnionTag);
        return 0;
      }
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag
  IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
            kResponse;
    }
  }
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

class WithErrorSyntaxErrorAsEnumTopResponse {
 private:
  struct Storage_;

 public:
  WithErrorSyntaxErrorAsEnumTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxErrorAsEnumTopResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxErrorAsEnumTopResponse()
      : WithErrorSyntaxErrorAsEnumTopResponse(Storage_{}) {}

  WithErrorSyntaxErrorAsEnumTopResponse(
      WithErrorSyntaxErrorAsEnumTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsEnumTopResponse& operator=(
      WithErrorSyntaxErrorAsEnumTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsEnumTopResponse(
      const WithErrorSyntaxErrorAsEnumTopResponse& other) noexcept
      : WithErrorSyntaxErrorAsEnumTopResponse(other.CloneStorage_()) {}
  WithErrorSyntaxErrorAsEnumTopResponse& operator=(
      const WithErrorSyntaxErrorAsEnumTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const WithErrorSyntaxErrorAsEnumTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 24,
        16>::Equal(this, &other);
  }
  bool operator!=(
      const WithErrorSyntaxErrorAsEnumTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 24,
        16>::Equal(this, &other);
  }

  const ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result& result() const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result& result() {
    return storage_.result;
  }

 private:
  struct Storage_ final {
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 24, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result,
          fidl::internal::NaturalCodingConstraintEmpty>{&Storage_::result, 0,
                                                        0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

class ChannelProtocolMethodBTopResponse {
 private:
  struct Storage_;

 public:
  ChannelProtocolMethodBTopResponse(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMethodBTopResponse(int64_t result) noexcept
      : storage_({.result = std::move(result)}) {}
  ChannelProtocolMethodBTopResponse()
      : ChannelProtocolMethodBTopResponse(Storage_{}) {}

  ChannelProtocolMethodBTopResponse(
      ChannelProtocolMethodBTopResponse&&) noexcept = default;
  ChannelProtocolMethodBTopResponse& operator=(
      ChannelProtocolMethodBTopResponse&&) noexcept = default;
  ChannelProtocolMethodBTopResponse(
      const ChannelProtocolMethodBTopResponse& other) noexcept
      : ChannelProtocolMethodBTopResponse(other.CloneStorage_()) {}
  ChannelProtocolMethodBTopResponse& operator=(
      const ChannelProtocolMethodBTopResponse& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(
      const ChannelProtocolMethodBTopResponse& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolMethodBTopResponse, 8,
        8>::Equal(this, &other);
  }
  bool operator!=(
      const ChannelProtocolMethodBTopResponse& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolMethodBTopResponse, 8,
        8>::Equal(this, &other);
  }

  int64_t result() const { return storage_.result; }

  int64_t& result() { return storage_.result; }

 private:
  struct Storage_ final {
    int64_t result{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolMethodBTopResponse, 8, 8>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolMethodBTopResponse>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::result, 0, 0});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

class ChannelProtocolMethodBRequest {
 private:
  struct Storage_;

 public:
  ChannelProtocolMethodBRequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMethodBRequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  ChannelProtocolMethodBRequest() : ChannelProtocolMethodBRequest(Storage_{}) {}

  ChannelProtocolMethodBRequest(ChannelProtocolMethodBRequest&&) noexcept =
      default;
  ChannelProtocolMethodBRequest& operator=(
      ChannelProtocolMethodBRequest&&) noexcept = default;
  ChannelProtocolMethodBRequest(
      const ChannelProtocolMethodBRequest& other) noexcept
      : ChannelProtocolMethodBRequest(other.CloneStorage_()) {}
  ChannelProtocolMethodBRequest& operator=(
      const ChannelProtocolMethodBRequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ChannelProtocolMethodBRequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolMethodBRequest, 16, 16>::Equal(this,
                                                                        &other);
  }
  bool operator!=(const ChannelProtocolMethodBRequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolMethodBRequest, 16, 16>::Equal(this,
                                                                        &other);
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int64_t a{};
    int64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolMethodBRequest, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolMethodBRequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::a, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::b, 8, 8});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

class ChannelProtocolMethodARequest {
 private:
  struct Storage_;

 public:
  ChannelProtocolMethodARequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMethodARequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  ChannelProtocolMethodARequest() : ChannelProtocolMethodARequest(Storage_{}) {}

  ChannelProtocolMethodARequest(ChannelProtocolMethodARequest&&) noexcept =
      default;
  ChannelProtocolMethodARequest& operator=(
      ChannelProtocolMethodARequest&&) noexcept = default;
  ChannelProtocolMethodARequest(
      const ChannelProtocolMethodARequest& other) noexcept
      : ChannelProtocolMethodARequest(other.CloneStorage_()) {}
  ChannelProtocolMethodARequest& operator=(
      const ChannelProtocolMethodARequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ChannelProtocolMethodARequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolMethodARequest, 16, 16>::Equal(this,
                                                                        &other);
  }
  bool operator!=(const ChannelProtocolMethodARequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolMethodARequest, 16, 16>::Equal(this,
                                                                        &other);
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int64_t a{};
    int64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolMethodARequest, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolMethodARequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::a, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::b, 8, 8});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

class ChannelProtocolEventARequest {
 private:
  struct Storage_;

 public:
  ChannelProtocolEventARequest(Storage_ storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolEventARequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  ChannelProtocolEventARequest() : ChannelProtocolEventARequest(Storage_{}) {}

  ChannelProtocolEventARequest(ChannelProtocolEventARequest&&) noexcept =
      default;
  ChannelProtocolEventARequest& operator=(
      ChannelProtocolEventARequest&&) noexcept = default;
  ChannelProtocolEventARequest(
      const ChannelProtocolEventARequest& other) noexcept
      : ChannelProtocolEventARequest(other.CloneStorage_()) {}
  ChannelProtocolEventARequest& operator=(
      const ChannelProtocolEventARequest& other) noexcept {
    storage_ = other.CloneStorage_();
    return *this;
  }

  bool operator==(const ChannelProtocolEventARequest& other) const noexcept {
    return ::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolEventARequest, 16, 16>::Equal(this,
                                                                       &other);
  }
  bool operator!=(const ChannelProtocolEventARequest& other) const noexcept {
    return !::fidl::internal::NaturalStructCodingTraits<
        ::test_protocols::ChannelProtocolEventARequest, 16, 16>::Equal(this,
                                                                       &other);
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  struct Storage_ final {
    int64_t a{};
    int64_t b{};
  };

  Storage_ storage_;
  Storage_ CloneStorage_() const;

  friend struct ::fidl::internal::NaturalStructCodingTraits<
      ::test_protocols::ChannelProtocolEventARequest, 16, 16>;
  friend struct ::fidl::internal::MemberVisitor<
      ::test_protocols::ChannelProtocolEventARequest>;
  static constexpr auto kMembers = std::make_tuple(
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::a, 0, 0},
      ::fidl::internal::NaturalStructMember<
          Storage_, int64_t, fidl::internal::NaturalCodingConstraintEmpty>{
          &Storage_::b, 8, 8});
  static constexpr auto kPaddingV1 = std::make_tuple();
  static constexpr auto kPaddingV2 = std::make_tuple();
};

}  // namespace test_protocols
namespace fidl {

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

template <>
struct IsResource<::test_protocols::WithErrorSyntax_HandleInResult_Response>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_HandleInResult_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_HandleInResult_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_HandleInResult_Response,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithErrorSyntax_HandleInResult_Response, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

template <>
struct IsResource<::test_protocols::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxHandleInResultTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntaxHandleInResultTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithErrorSyntaxHandleInResultTopResponse, 24, 16> {
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

template <>
struct IsResource<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::HandleRightsProtocolResponseMethodTopResponse,
                4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

template <>
struct IsResource<::test_protocols::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolResponseMethodRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::HandleRightsProtocolResponseMethodRequest, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

template <>
struct IsResource<::test_protocols::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::HandleRightsProtocolNoResponseMethodRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::HandleRightsProtocolNoResponseMethodRequest, 4, 4> {
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

template <>
struct IsResource<::test_protocols::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolAnEventRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolAnEventRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::HandleRightsProtocolAnEventRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::HandleRightsProtocolAnEventRequest, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

template <>
struct IsResource<::test_protocols::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolTakeHandleRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolTakeHandleRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolTakeHandleRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ChannelProtocolTakeHandleRequest, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

template <>
struct IsResource<::test_protocols::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMutateSocketTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMutateSocketTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolMutateSocketTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::ChannelProtocolMutateSocketTopResponse, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

template <>
struct IsResource<::test_protocols::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMutateSocketRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMutateSocketRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolMutateSocketRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ChannelProtocolMutateSocketRequest, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsServerEndsTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsServerEndsTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithProtocolEndsServerEndsTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithProtocolEndsServerEndsTopResponse, 4, 4> {
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsServerEndsRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsServerEndsRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithProtocolEndsServerEndsRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithProtocolEndsServerEndsRequest, 4, 4> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsClientEndsTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsClientEndsTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithProtocolEndsClientEndsTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithProtocolEndsClientEndsTopResponse, 4, 4> {
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsClientEndsRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsClientEndsRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithProtocolEndsClientEndsRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithProtocolEndsClientEndsRequest, 4, 4> {};

#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response, 24, 24> {
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse,
                24, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response, 1, 1> {};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse,
                24, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response, 1, 1> {
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestWithResponseTopResponse,
          16, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::
                    WithAndWithoutRequestResponseWithRequestWithResponseRequest,
                16, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::
                    WithAndWithoutRequestResponseWithRequestNoResponseRequest,
                16, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::
              WithAndWithoutRequestResponseWithRequestEmptyResponseRequest,
          16, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest,
          16, 16> {};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::
              WithAndWithoutRequestResponseNoRequestWithResponseTopResponse,
          16, 16> {};

extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

template <>
struct IsFidlType<::test_protocols::TransitionalRequestTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::TransitionalRequestTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalRequestTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::TransitionalRequestTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::TransitionalRequestTopResponse, 8, 8> {};

extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

template <>
struct IsFidlType<::test_protocols::TransitionalRequestRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::TransitionalRequestRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalRequestRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::TransitionalRequestRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::TransitionalRequestRequest, 8, 8> {};

extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

template <>
struct IsFidlType<::test_protocols::TransitionalOneWayRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::TransitionalOneWayRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalOneWayRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::TransitionalOneWayRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::TransitionalOneWayRequest, 8, 8> {};

extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

template <>
struct IsFidlType<::test_protocols::TransitionalEventRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::TransitionalEventRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalEventRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::TransitionalEventRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::TransitionalEventRequest, 8, 8> {};

extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

template <>
struct IsFidlType<::test_protocols::MethodWithUnionUnionMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::MethodWithUnionUnionMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_MethodWithUnionUnionMethodRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::MethodWithUnionUnionMethodRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::MethodWithUnionUnionMethodRequest, 24, 16> {};

extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

template <>
struct IsFidlType<::test_protocols::SyscallProtocolMethodCRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::SyscallProtocolMethodCRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_SyscallProtocolMethodCRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::SyscallProtocolMethodCRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::SyscallProtocolMethodCRequest, 16, 16> {};

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

template <>
struct IsResource<::test_protocols::ProtocolEnds> : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ProtocolEnds> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::ProtocolEnds> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ProtocolEndsTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ProtocolEnds,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ProtocolEnds, 16, 16> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

template <>
struct IsResource<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse, 16,
          16> {};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::WithProtocolEndsStructContainingEndsRequest,
                16, 16> {};

#endif  // __Fuchsia__

extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

template <>
struct IsFidlType<::test_protocols::ManyParametersFifteenRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ManyParametersFifteenRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ManyParametersFifteenRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ManyParametersFifteenRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ManyParametersFifteenRequest, 15, 15> {};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final
    : public ::fidl::internal::NaturalStructCodingTraits<
          ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse, 24, 16> {};

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolMethodBTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMethodBTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMethodBTopResponseTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolMethodBTopResponse,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ChannelProtocolMethodBTopResponse, 8, 8> {};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolMethodBRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMethodBRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMethodBRequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolMethodBRequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ChannelProtocolMethodBRequest, 16, 16> {};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolMethodARequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMethodARequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMethodARequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolMethodARequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ChannelProtocolMethodARequest, 16, 16> {};

extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolEventARequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolEventARequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolEventARequestTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ChannelProtocolEventARequest,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalStructCodingTraits<
                ::test_protocols::ChannelProtocolEventARequest, 16, 16> {};

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

template <>
struct IsResource<::test_protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_HandleInResult_Result>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_HandleInResult_ResultTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_HandleInResult_Result,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_HandleInResult_Result> {};

#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result> {};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result> {};

extern "C" const fidl_type_t test_protocols_TheUnionTable;

template <>
struct IsFidlType<::test_protocols::TheUnion> : public std::true_type {};
template <>
struct IsUnion<::test_protocols::TheUnion> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::TheUnion> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TheUnionTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::TheUnion, ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::TheUnion> {};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public std::true_type {};
template <>
struct IsUnion<::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result,
    ::fidl::internal::NaturalCodingConstraintEmpty>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result> {};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::rights, ::fidl::internal::NaturalCodingConstraintEmpty> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::NaturalEncoder* encoder,
                     ::test_protocols::rights* value, size_t offset,
                     size_t recursion_depth) {
    if (static_cast<uint32_t>(*value) & ~3ull) {
      encoder->SetError(::fidl::internal::kCodingErrorUnknownBitSetInBitsValue);
    }
    *encoder->template GetPtr<::test_protocols::rights>(offset) = *value;
  }
  static void Decode(internal::NaturalDecoder* decoder,
                     ::test_protocols::rights* value, size_t offset,
                     size_t recursion_depth) {
    *value = *decoder->template GetPtr<::test_protocols::rights>(offset);
    if (static_cast<uint32_t>(*value) & ~3ull) {
      decoder->SetError(::fidl::internal::kCodingErrorUnknownBitSetInBitsValue);
    }
  }
};

template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::obj_type,
    ::fidl::internal::NaturalCodingConstraintEmpty> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::NaturalEncoder* encoder,
                     ::test_protocols::obj_type* value, size_t offset,
                     size_t recursion_depth) {
    switch (*value) {
      case ::test_protocols::obj_type::kNone:
      case ::test_protocols::obj_type::kSocket:
        break;
      default:
        encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
    *encoder->template GetPtr<::test_protocols::obj_type>(offset) = *value;
  }
  static void Decode(internal::NaturalDecoder* decoder,
                     ::test_protocols::obj_type* value, size_t offset,
                     size_t recursion_depth) {
    *value = *decoder->template GetPtr<::test_protocols::obj_type>(offset);
    switch (*value) {
      case ::test_protocols::obj_type::kNone:
      case ::test_protocols::obj_type::kSocket:
        break;
      default:
        decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
  }
};
template <>
struct internal::NaturalCodingTraits<
    ::test_protocols::ErrorEnum,
    ::fidl::internal::NaturalCodingConstraintEmpty> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);
  static constexpr bool is_memcpy_compatible = false;

  static void Encode(internal::NaturalEncoder* encoder,
                     ::test_protocols::ErrorEnum* value, size_t offset,
                     size_t recursion_depth) {
    switch (*value) {
      case ::test_protocols::ErrorEnum::kErrFoo:
      case ::test_protocols::ErrorEnum::kErrBar:
        break;
      default:
        encoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
    *encoder->template GetPtr<::test_protocols::ErrorEnum>(offset) = *value;
  }
  static void Decode(internal::NaturalDecoder* decoder,
                     ::test_protocols::ErrorEnum* value, size_t offset,
                     size_t recursion_depth) {
    *value = *decoder->template GetPtr<::test_protocols::ErrorEnum>(offset);
    switch (*value) {
      case ::test_protocols::ErrorEnum::kErrFoo:
      case ::test_protocols::ErrorEnum::kErrBar:
        break;
      default:
        decoder->SetError(::fidl::internal::kCodingErrorUnknownEnumValue);
        return;
    }
  }
};

}  // namespace fidl
