// WARNING: This file is machine generated by fidlgen.

#pragma once

#include <fidl/test.protocols/cpp/common_types.h>
#include <fidl/test.protocols/cpp/markers.h>
#include <lib/fidl/cpp/coding_traits.h>
#include <lib/fidl/cpp/internal/codable_base.h>
#include <lib/fidl/cpp/unified_messaging.h>

#include <cinttypes>
#include <string>

#ifdef __Fuchsia__

#include <lib/zx/channel.h>
#include <lib/zx/handle.h>
#include <lib/zx/socket.h>

#endif  // __Fuchsia__

namespace test_protocols {
class WithErrorSyntax_HandleInResult_Response;

class WithErrorSyntaxHandleInResultTopResponse;

class HandleRightsProtocolResponseMethodTopResponse;

class HandleRightsProtocolResponseMethodRequest;

class HandleRightsProtocolNoResponseMethodRequest;

class HandleRightsProtocolAnEventRequest;

class ChannelProtocolTakeHandleRequest;

class ChannelProtocolMutateSocketTopResponse;

class ChannelProtocolMutateSocketRequest;

class WithProtocolEndsServerEndsTopResponse;

class WithProtocolEndsServerEndsRequest;

class WithProtocolEndsClientEndsTopResponse;

class WithProtocolEndsClientEndsRequest;

class WithErrorSyntax_ResponseAsStruct_Response;

class WithErrorSyntaxResponseAsStructTopResponse;

class WithErrorSyntax_ErrorAsPrimitive_Response;

class WithErrorSyntaxErrorAsPrimitiveTopResponse;

class WithErrorSyntax_ErrorAsEnum_Response;

class WithAndWithoutRequestResponseWithRequestWithResponseTopResponse;

class WithAndWithoutRequestResponseWithRequestWithResponseRequest;

class WithAndWithoutRequestResponseWithRequestNoResponseRequest;

class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest;

class WithAndWithoutRequestResponseOnWithResponseRequest;

class WithAndWithoutRequestResponseNoRequestWithResponseTopResponse;

class TransitionalRequestTopResponse;

class TransitionalRequestRequest;

class TransitionalOneWayRequest;

class TransitionalEventRequest;

class MethodWithUnionUnionMethodRequest;

class SyscallProtocolMethodCRequest;

class ProtocolEnds;

class WithProtocolEndsStructContainingEndsTopResponse;

class WithProtocolEndsStructContainingEndsRequest;

class ManyParametersFifteenRequest;

class WithErrorSyntaxErrorAsEnumTopResponse;

class ChannelProtocolMethodBTopResponse;

class ChannelProtocolMethodBRequest;

class ChannelProtocolMethodARequest;

class ChannelProtocolEventARequest;

class WithErrorSyntax_HandleInResult_Result;

class WithErrorSyntax_ResponseAsStruct_Result;

class WithErrorSyntax_ErrorAsPrimitive_Result;

class TheUnion;

class WithErrorSyntax_ErrorAsEnum_Result;

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

class WithErrorSyntax_HandleInResult_Response final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntax_HandleInResult_Response> {
 private:
  friend ::fidl::internal::CodableBase<WithErrorSyntax_HandleInResult_Response>;
  friend ::fidl::CodingTraits<WithErrorSyntax_HandleInResult_Response>;
  WithErrorSyntax_HandleInResult_Response(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::handle h{};
  };

  WithErrorSyntax_HandleInResult_Response(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_HandleInResult_Response(::zx::handle h) noexcept
      : storage_({.h = std::move(h)}) {}
  WithErrorSyntax_HandleInResult_Response()
      : WithErrorSyntax_HandleInResult_Response(Storage{}) {}

  WithErrorSyntax_HandleInResult_Response(
      WithErrorSyntax_HandleInResult_Response&&) noexcept = default;
  WithErrorSyntax_HandleInResult_Response& operator=(
      WithErrorSyntax_HandleInResult_Response&&) noexcept = default;

  const ::zx::handle& h() const { return storage_.h; }

  ::zx::handle& h() { return storage_.h; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResultTable;

class WithErrorSyntax_HandleInResult_Result final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

 private:
  using Storage =
      cpp17::variant<cpp17::monostate,
                     ::test_protocols::WithErrorSyntax_HandleInResult_Response,
                     uint32_t>;
  std::shared_ptr<Storage> storage_;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_HandleInResult_Result>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 3>
      Members = {std::nullopt, std::nullopt, std::nullopt};

  explicit WithErrorSyntax_HandleInResult_Result(
      std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
          kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag
  IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
            kResponse;
    }
  }

 public:
  // Create an unknown value of this union.
  WithErrorSyntax_HandleInResult_Result()
      : storage_(std::make_shared<Storage>()) {}

  WithErrorSyntax_HandleInResult_Result(
      WithErrorSyntax_HandleInResult_Result&&) noexcept = default;
  WithErrorSyntax_HandleInResult_Result& operator=(
      WithErrorSyntax_HandleInResult_Result&&) noexcept = default;

  constexpr ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag Which()
      const {
    return WithErrorSyntax_HandleInResult_Result::IndexToTag(storage_->index());
  }
  static WithErrorSyntax_HandleInResult_Result WithResponse(
      ::test_protocols::WithErrorSyntax_HandleInResult_Response val) {
    return WithErrorSyntax_HandleInResult_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
                kResponse)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> response() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  static WithErrorSyntax_HandleInResult_Result WithErr(uint32_t val) {
    return WithErrorSyntax_HandleInResult_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_HandleInResult_Result::Tag::
                kErr)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage> err() {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

class WithErrorSyntaxHandleInResultTopResponse final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntaxHandleInResultTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      WithErrorSyntaxHandleInResultTopResponse>;
  friend ::fidl::CodingTraits<WithErrorSyntaxHandleInResultTopResponse>;
  WithErrorSyntaxHandleInResultTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::WithErrorSyntax_HandleInResult_Result result{};
  };

  WithErrorSyntaxHandleInResultTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxHandleInResultTopResponse(
      ::test_protocols::WithErrorSyntax_HandleInResult_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxHandleInResultTopResponse()
      : WithErrorSyntaxHandleInResultTopResponse(Storage{}) {}

  WithErrorSyntaxHandleInResultTopResponse(
      WithErrorSyntaxHandleInResultTopResponse&&) noexcept = default;
  WithErrorSyntaxHandleInResultTopResponse& operator=(
      WithErrorSyntaxHandleInResultTopResponse&&) noexcept = default;

  const ::test_protocols::WithErrorSyntax_HandleInResult_Result& result()
      const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_HandleInResult_Result& result() {
    return storage_.result;
  }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

class HandleRightsProtocolResponseMethodTopResponse final
    : public ::fidl::internal::CodableBase<
          HandleRightsProtocolResponseMethodTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      HandleRightsProtocolResponseMethodTopResponse>;
  friend ::fidl::CodingTraits<HandleRightsProtocolResponseMethodTopResponse>;
  HandleRightsProtocolResponseMethodTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::socket h{};
  };

  HandleRightsProtocolResponseMethodTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolResponseMethodTopResponse(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolResponseMethodTopResponse()
      : HandleRightsProtocolResponseMethodTopResponse(Storage{}) {}

  HandleRightsProtocolResponseMethodTopResponse(
      HandleRightsProtocolResponseMethodTopResponse&&) noexcept = default;
  HandleRightsProtocolResponseMethodTopResponse& operator=(
      HandleRightsProtocolResponseMethodTopResponse&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

class HandleRightsProtocolResponseMethodRequest final
    : public ::fidl::internal::CodableBase<
          HandleRightsProtocolResponseMethodRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      HandleRightsProtocolResponseMethodRequest>;
  friend ::fidl::CodingTraits<HandleRightsProtocolResponseMethodRequest>;
  HandleRightsProtocolResponseMethodRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::socket h{};
  };

  HandleRightsProtocolResponseMethodRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolResponseMethodRequest(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolResponseMethodRequest()
      : HandleRightsProtocolResponseMethodRequest(Storage{}) {}

  HandleRightsProtocolResponseMethodRequest(
      HandleRightsProtocolResponseMethodRequest&&) noexcept = default;
  HandleRightsProtocolResponseMethodRequest& operator=(
      HandleRightsProtocolResponseMethodRequest&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

class HandleRightsProtocolNoResponseMethodRequest final
    : public ::fidl::internal::CodableBase<
          HandleRightsProtocolNoResponseMethodRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      HandleRightsProtocolNoResponseMethodRequest>;
  friend ::fidl::CodingTraits<HandleRightsProtocolNoResponseMethodRequest>;
  HandleRightsProtocolNoResponseMethodRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::socket h{};
  };

  HandleRightsProtocolNoResponseMethodRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolNoResponseMethodRequest(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolNoResponseMethodRequest()
      : HandleRightsProtocolNoResponseMethodRequest(Storage{}) {}

  HandleRightsProtocolNoResponseMethodRequest(
      HandleRightsProtocolNoResponseMethodRequest&&) noexcept = default;
  HandleRightsProtocolNoResponseMethodRequest& operator=(
      HandleRightsProtocolNoResponseMethodRequest&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

class HandleRightsProtocolAnEventRequest final
    : public ::fidl::internal::CodableBase<HandleRightsProtocolAnEventRequest> {
 private:
  friend ::fidl::internal::CodableBase<HandleRightsProtocolAnEventRequest>;
  friend ::fidl::CodingTraits<HandleRightsProtocolAnEventRequest>;
  HandleRightsProtocolAnEventRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::socket h{};
  };

  HandleRightsProtocolAnEventRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  HandleRightsProtocolAnEventRequest(::zx::socket h) noexcept
      : storage_({.h = std::move(h)}) {}
  HandleRightsProtocolAnEventRequest()
      : HandleRightsProtocolAnEventRequest(Storage{}) {}

  HandleRightsProtocolAnEventRequest(
      HandleRightsProtocolAnEventRequest&&) noexcept = default;
  HandleRightsProtocolAnEventRequest& operator=(
      HandleRightsProtocolAnEventRequest&&) noexcept = default;

  const ::zx::socket& h() const { return storage_.h; }

  ::zx::socket& h() { return storage_.h; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

class ChannelProtocolTakeHandleRequest final
    : public ::fidl::internal::CodableBase<ChannelProtocolTakeHandleRequest> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolTakeHandleRequest>;
  friend ::fidl::CodingTraits<ChannelProtocolTakeHandleRequest>;
  ChannelProtocolTakeHandleRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::handle h{};
  };

  ChannelProtocolTakeHandleRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolTakeHandleRequest(::zx::handle h) noexcept
      : storage_({.h = std::move(h)}) {}
  ChannelProtocolTakeHandleRequest()
      : ChannelProtocolTakeHandleRequest(Storage{}) {}

  ChannelProtocolTakeHandleRequest(
      ChannelProtocolTakeHandleRequest&&) noexcept = default;
  ChannelProtocolTakeHandleRequest& operator=(
      ChannelProtocolTakeHandleRequest&&) noexcept = default;

  const ::zx::handle& h() const { return storage_.h; }

  ::zx::handle& h() { return storage_.h; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

class ChannelProtocolMutateSocketTopResponse final
    : public ::fidl::internal::CodableBase<
          ChannelProtocolMutateSocketTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolMutateSocketTopResponse>;
  friend ::fidl::CodingTraits<ChannelProtocolMutateSocketTopResponse>;
  ChannelProtocolMutateSocketTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::socket b{};
  };

  ChannelProtocolMutateSocketTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMutateSocketTopResponse(::zx::socket b) noexcept
      : storage_({.b = std::move(b)}) {}
  ChannelProtocolMutateSocketTopResponse()
      : ChannelProtocolMutateSocketTopResponse(Storage{}) {}

  ChannelProtocolMutateSocketTopResponse(
      ChannelProtocolMutateSocketTopResponse&&) noexcept = default;
  ChannelProtocolMutateSocketTopResponse& operator=(
      ChannelProtocolMutateSocketTopResponse&&) noexcept = default;

  const ::zx::socket& b() const { return storage_.b; }

  ::zx::socket& b() { return storage_.b; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

class ChannelProtocolMutateSocketRequest final
    : public ::fidl::internal::CodableBase<ChannelProtocolMutateSocketRequest> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolMutateSocketRequest>;
  friend ::fidl::CodingTraits<ChannelProtocolMutateSocketRequest>;
  ChannelProtocolMutateSocketRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::zx::socket a{};
  };

  ChannelProtocolMutateSocketRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMutateSocketRequest(::zx::socket a) noexcept
      : storage_({.a = std::move(a)}) {}
  ChannelProtocolMutateSocketRequest()
      : ChannelProtocolMutateSocketRequest(Storage{}) {}

  ChannelProtocolMutateSocketRequest(
      ChannelProtocolMutateSocketRequest&&) noexcept = default;
  ChannelProtocolMutateSocketRequest& operator=(
      ChannelProtocolMutateSocketRequest&&) noexcept = default;

  const ::zx::socket& a() const { return storage_.a; }

  ::zx::socket& a() { return storage_.a; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

class WithProtocolEndsServerEndsTopResponse final
    : public ::fidl::internal::CodableBase<
          WithProtocolEndsServerEndsTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<WithProtocolEndsServerEndsTopResponse>;
  friend ::fidl::CodingTraits<WithProtocolEndsServerEndsTopResponse>;
  WithProtocolEndsServerEndsTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out{};
  };

  WithProtocolEndsServerEndsTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsServerEndsTopResponse(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> out) noexcept
      : storage_({.out = std::move(out)}) {}
  WithProtocolEndsServerEndsTopResponse()
      : WithProtocolEndsServerEndsTopResponse(Storage{}) {}

  WithProtocolEndsServerEndsTopResponse(
      WithProtocolEndsServerEndsTopResponse&&) noexcept = default;
  WithProtocolEndsServerEndsTopResponse& operator=(
      WithProtocolEndsServerEndsTopResponse&&) noexcept = default;

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& out() const {
    return storage_.out;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& out() {
    return storage_.out;
  }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

class WithProtocolEndsServerEndsRequest final
    : public ::fidl::internal::CodableBase<WithProtocolEndsServerEndsRequest> {
 private:
  friend ::fidl::internal::CodableBase<WithProtocolEndsServerEndsRequest>;
  friend ::fidl::CodingTraits<WithProtocolEndsServerEndsRequest>;
  WithProtocolEndsServerEndsRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in{};
  };

  WithProtocolEndsServerEndsRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsServerEndsRequest(
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> in) noexcept
      : storage_({.in = std::move(in)}) {}
  WithProtocolEndsServerEndsRequest()
      : WithProtocolEndsServerEndsRequest(Storage{}) {}

  WithProtocolEndsServerEndsRequest(
      WithProtocolEndsServerEndsRequest&&) noexcept = default;
  WithProtocolEndsServerEndsRequest& operator=(
      WithProtocolEndsServerEndsRequest&&) noexcept = default;

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& in() const {
    return storage_.in;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& in() {
    return storage_.in;
  }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

class WithProtocolEndsClientEndsTopResponse final
    : public ::fidl::internal::CodableBase<
          WithProtocolEndsClientEndsTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<WithProtocolEndsClientEndsTopResponse>;
  friend ::fidl::CodingTraits<WithProtocolEndsClientEndsTopResponse>;
  WithProtocolEndsClientEndsTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out{};
  };

  WithProtocolEndsClientEndsTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsClientEndsTopResponse(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> out) noexcept
      : storage_({.out = std::move(out)}) {}
  WithProtocolEndsClientEndsTopResponse()
      : WithProtocolEndsClientEndsTopResponse(Storage{}) {}

  WithProtocolEndsClientEndsTopResponse(
      WithProtocolEndsClientEndsTopResponse&&) noexcept = default;
  WithProtocolEndsClientEndsTopResponse& operator=(
      WithProtocolEndsClientEndsTopResponse&&) noexcept = default;

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& out() const {
    return storage_.out;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& out() {
    return storage_.out;
  }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

class WithProtocolEndsClientEndsRequest final
    : public ::fidl::internal::CodableBase<WithProtocolEndsClientEndsRequest> {
 private:
  friend ::fidl::internal::CodableBase<WithProtocolEndsClientEndsRequest>;
  friend ::fidl::CodingTraits<WithProtocolEndsClientEndsRequest>;
  WithProtocolEndsClientEndsRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in{};
  };

  WithProtocolEndsClientEndsRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsClientEndsRequest(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> in) noexcept
      : storage_({.in = std::move(in)}) {}
  WithProtocolEndsClientEndsRequest()
      : WithProtocolEndsClientEndsRequest(Storage{}) {}

  WithProtocolEndsClientEndsRequest(
      WithProtocolEndsClientEndsRequest&&) noexcept = default;
  WithProtocolEndsClientEndsRequest& operator=(
      WithProtocolEndsClientEndsRequest&&) noexcept = default;

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& in() const {
    return storage_.in;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& in() {
    return storage_.in;
  }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

class WithErrorSyntax_ResponseAsStruct_Response final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntax_ResponseAsStruct_Response> {
 private:
  friend ::fidl::internal::CodableBase<
      WithErrorSyntax_ResponseAsStruct_Response>;
  friend ::fidl::CodingTraits<WithErrorSyntax_ResponseAsStruct_Response>;
  WithErrorSyntax_ResponseAsStruct_Response(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t a{};
    int64_t b{};
    int64_t c{};
  };

  WithErrorSyntax_ResponseAsStruct_Response(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_ResponseAsStruct_Response(int64_t a, int64_t b,
                                            int64_t c) noexcept
      : storage_({.a = std::move(a), .b = std::move(b), .c = std::move(c)}) {}
  WithErrorSyntax_ResponseAsStruct_Response()
      : WithErrorSyntax_ResponseAsStruct_Response(Storage{}) {}

  WithErrorSyntax_ResponseAsStruct_Response(
      WithErrorSyntax_ResponseAsStruct_Response&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Response& operator=(
      WithErrorSyntax_ResponseAsStruct_Response&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Response(
      const WithErrorSyntax_ResponseAsStruct_Response& other) noexcept
      : WithErrorSyntax_ResponseAsStruct_Response(other.CloneStorage()) {}
  WithErrorSyntax_ResponseAsStruct_Response& operator=(
      const WithErrorSyntax_ResponseAsStruct_Response& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

  int64_t c() const { return storage_.c; }

  int64_t& c() { return storage_.c; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResultTable;

class WithErrorSyntax_ResponseAsStruct_Result final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

 private:
  using Storage = cpp17::variant<
      cpp17::monostate,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response, uint32_t>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 3>
      Members = {std::nullopt, std::nullopt, std::nullopt};

  explicit WithErrorSyntax_ResponseAsStruct_Result(
      std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
          kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::
      Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
            kResponse;
    }
  }

 public:
  // Create an unknown value of this union.
  WithErrorSyntax_ResponseAsStruct_Result()
      : storage_(std::make_shared<Storage>()) {}

  WithErrorSyntax_ResponseAsStruct_Result(
      WithErrorSyntax_ResponseAsStruct_Result&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Result& operator=(
      WithErrorSyntax_ResponseAsStruct_Result&&) noexcept = default;
  WithErrorSyntax_ResponseAsStruct_Result(
      const WithErrorSyntax_ResponseAsStruct_Result& other) noexcept
      : WithErrorSyntax_ResponseAsStruct_Result(other.CloneStorage()) {}
  WithErrorSyntax_ResponseAsStruct_Result& operator=(
      const WithErrorSyntax_ResponseAsStruct_Result& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag
  Which() const {
    return WithErrorSyntax_ResponseAsStruct_Result::IndexToTag(
        storage_->index());
  }
  static WithErrorSyntax_ResponseAsStruct_Result WithResponse(
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response val) {
    return WithErrorSyntax_ResponseAsStruct_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
                kResponse)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> response() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  static WithErrorSyntax_ResponseAsStruct_Result WithErr(uint32_t val) {
    return WithErrorSyntax_ResponseAsStruct_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result::Tag::
                kErr)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage> err() {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

class WithErrorSyntaxResponseAsStructTopResponse final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntaxResponseAsStructTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      WithErrorSyntaxResponseAsStructTopResponse>;
  friend ::fidl::CodingTraits<WithErrorSyntaxResponseAsStructTopResponse>;
  WithErrorSyntaxResponseAsStructTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result result{};
  };

  WithErrorSyntaxResponseAsStructTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxResponseAsStructTopResponse(
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxResponseAsStructTopResponse()
      : WithErrorSyntaxResponseAsStructTopResponse(Storage{}) {}

  WithErrorSyntaxResponseAsStructTopResponse(
      WithErrorSyntaxResponseAsStructTopResponse&&) noexcept = default;
  WithErrorSyntaxResponseAsStructTopResponse& operator=(
      WithErrorSyntaxResponseAsStructTopResponse&&) noexcept = default;
  WithErrorSyntaxResponseAsStructTopResponse(
      const WithErrorSyntaxResponseAsStructTopResponse& other) noexcept
      : WithErrorSyntaxResponseAsStructTopResponse(other.CloneStorage()) {}
  WithErrorSyntaxResponseAsStructTopResponse& operator=(
      const WithErrorSyntaxResponseAsStructTopResponse& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result& result()
      const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result& result() {
    return storage_.result;
  }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

class WithErrorSyntax_ErrorAsPrimitive_Response final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntax_ErrorAsPrimitive_Response> {
 private:
  friend ::fidl::internal::CodableBase<
      WithErrorSyntax_ErrorAsPrimitive_Response>;
  friend ::fidl::CodingTraits<WithErrorSyntax_ErrorAsPrimitive_Response>;
  WithErrorSyntax_ErrorAsPrimitive_Response(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t __reserved = 0u;
  };

  WithErrorSyntax_ErrorAsPrimitive_Response(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_ErrorAsPrimitive_Response(uint8_t __reserved) noexcept
      : storage_({.__reserved = std::move(__reserved)}) {}
  WithErrorSyntax_ErrorAsPrimitive_Response()
      : WithErrorSyntax_ErrorAsPrimitive_Response(Storage{}) {}

  WithErrorSyntax_ErrorAsPrimitive_Response(
      WithErrorSyntax_ErrorAsPrimitive_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Response& operator=(
      WithErrorSyntax_ErrorAsPrimitive_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Response(
      const WithErrorSyntax_ErrorAsPrimitive_Response& other) noexcept
      : WithErrorSyntax_ErrorAsPrimitive_Response(other.CloneStorage()) {}
  WithErrorSyntax_ErrorAsPrimitive_Response& operator=(
      const WithErrorSyntax_ErrorAsPrimitive_Response& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t __reserved() const { return storage_.__reserved; }

  uint8_t& __reserved() { return storage_.__reserved; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResultTable;

class WithErrorSyntax_ErrorAsPrimitive_Result final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

 private:
  using Storage = cpp17::variant<
      cpp17::monostate,
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response, uint32_t>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 3>
      Members = {std::nullopt, std::nullopt, std::nullopt};

  explicit WithErrorSyntax_ErrorAsPrimitive_Result(
      std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
          kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::
      Tag
      IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
            kResponse;
    }
  }

 public:
  // Create an unknown value of this union.
  WithErrorSyntax_ErrorAsPrimitive_Result()
      : storage_(std::make_shared<Storage>()) {}

  WithErrorSyntax_ErrorAsPrimitive_Result(
      WithErrorSyntax_ErrorAsPrimitive_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(
      WithErrorSyntax_ErrorAsPrimitive_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsPrimitive_Result(
      const WithErrorSyntax_ErrorAsPrimitive_Result& other) noexcept
      : WithErrorSyntax_ErrorAsPrimitive_Result(other.CloneStorage()) {}
  WithErrorSyntax_ErrorAsPrimitive_Result& operator=(
      const WithErrorSyntax_ErrorAsPrimitive_Result& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag
  Which() const {
    return WithErrorSyntax_ErrorAsPrimitive_Result::IndexToTag(
        storage_->index());
  }
  static WithErrorSyntax_ErrorAsPrimitive_Result WithResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response val) {
    return WithErrorSyntax_ErrorAsPrimitive_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
                kResponse)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> response() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  static WithErrorSyntax_ErrorAsPrimitive_Result WithErr(uint32_t val) {
    return WithErrorSyntax_ErrorAsPrimitive_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result::Tag::
                kErr)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage> err() {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

class WithErrorSyntaxErrorAsPrimitiveTopResponse final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntaxErrorAsPrimitiveTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      WithErrorSyntaxErrorAsPrimitiveTopResponse>;
  friend ::fidl::CodingTraits<WithErrorSyntaxErrorAsPrimitiveTopResponse>;
  WithErrorSyntaxErrorAsPrimitiveTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result result{};
  };

  WithErrorSyntaxErrorAsPrimitiveTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxErrorAsPrimitiveTopResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxErrorAsPrimitiveTopResponse()
      : WithErrorSyntaxErrorAsPrimitiveTopResponse(Storage{}) {}

  WithErrorSyntaxErrorAsPrimitiveTopResponse(
      WithErrorSyntaxErrorAsPrimitiveTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsPrimitiveTopResponse& operator=(
      WithErrorSyntaxErrorAsPrimitiveTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsPrimitiveTopResponse(
      const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) noexcept
      : WithErrorSyntaxErrorAsPrimitiveTopResponse(other.CloneStorage()) {}
  WithErrorSyntaxErrorAsPrimitiveTopResponse& operator=(
      const WithErrorSyntaxErrorAsPrimitiveTopResponse& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result& result()
      const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result& result() {
    return storage_.result;
  }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

class WithErrorSyntax_ErrorAsEnum_Response final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntax_ErrorAsEnum_Response> {
 private:
  friend ::fidl::internal::CodableBase<WithErrorSyntax_ErrorAsEnum_Response>;
  friend ::fidl::CodingTraits<WithErrorSyntax_ErrorAsEnum_Response>;
  WithErrorSyntax_ErrorAsEnum_Response(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    uint8_t __reserved = 0u;
  };

  WithErrorSyntax_ErrorAsEnum_Response(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntax_ErrorAsEnum_Response(uint8_t __reserved) noexcept
      : storage_({.__reserved = std::move(__reserved)}) {}
  WithErrorSyntax_ErrorAsEnum_Response()
      : WithErrorSyntax_ErrorAsEnum_Response(Storage{}) {}

  WithErrorSyntax_ErrorAsEnum_Response(
      WithErrorSyntax_ErrorAsEnum_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Response& operator=(
      WithErrorSyntax_ErrorAsEnum_Response&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Response(
      const WithErrorSyntax_ErrorAsEnum_Response& other) noexcept
      : WithErrorSyntax_ErrorAsEnum_Response(other.CloneStorage()) {}
  WithErrorSyntax_ErrorAsEnum_Response& operator=(
      const WithErrorSyntax_ErrorAsEnum_Response& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  uint8_t __reserved() const { return storage_.__reserved; }

  uint8_t& __reserved() { return storage_.__reserved; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

class WithAndWithoutRequestResponseWithRequestWithResponseTopResponse final
    : public ::fidl::internal::CodableBase<
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>;
  friend ::fidl::CodingTraits<
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>;
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      ::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::std::string ret{};
  };

  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      ::std::string ret) noexcept
      : storage_({.ret = std::move(ret)}) {}
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse()
      : WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            Storage{}) {}

  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse& operator=(
      WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
      const WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestWithResponseTopResponse(
            other.CloneStorage()) {}
  WithAndWithoutRequestResponseWithRequestWithResponseTopResponse& operator=(
      const WithAndWithoutRequestResponseWithRequestWithResponseTopResponse&
          other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::std::string& ret() const { return storage_.ret; }

  ::std::string& ret() { return storage_.ret; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

class WithAndWithoutRequestResponseWithRequestWithResponseRequest final
    : public ::fidl::internal::CodableBase<
          WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      WithAndWithoutRequestResponseWithRequestWithResponseRequest>;
  friend ::fidl::CodingTraits<
      WithAndWithoutRequestResponseWithRequestWithResponseRequest>;
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      ::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::std::string arg{};
  };

  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      ::std::string arg) noexcept
      : storage_({.arg = std::move(arg)}) {}
  WithAndWithoutRequestResponseWithRequestWithResponseRequest()
      : WithAndWithoutRequestResponseWithRequestWithResponseRequest(Storage{}) {
  }

  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      WithAndWithoutRequestResponseWithRequestWithResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseRequest& operator=(
      WithAndWithoutRequestResponseWithRequestWithResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestWithResponseRequest(
      const WithAndWithoutRequestResponseWithRequestWithResponseRequest&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestWithResponseRequest(
            other.CloneStorage()) {}
  WithAndWithoutRequestResponseWithRequestWithResponseRequest& operator=(
      const WithAndWithoutRequestResponseWithRequestWithResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::std::string& arg() const { return storage_.arg; }

  ::std::string& arg() { return storage_.arg; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

class WithAndWithoutRequestResponseWithRequestNoResponseRequest final
    : public ::fidl::internal::CodableBase<
          WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      WithAndWithoutRequestResponseWithRequestNoResponseRequest>;
  friend ::fidl::CodingTraits<
      WithAndWithoutRequestResponseWithRequestNoResponseRequest>;
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      ::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::std::string arg{};
  };

  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      ::std::string arg) noexcept
      : storage_({.arg = std::move(arg)}) {}
  WithAndWithoutRequestResponseWithRequestNoResponseRequest()
      : WithAndWithoutRequestResponseWithRequestNoResponseRequest(Storage{}) {}

  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      WithAndWithoutRequestResponseWithRequestNoResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestNoResponseRequest& operator=(
      WithAndWithoutRequestResponseWithRequestNoResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestNoResponseRequest(
      const WithAndWithoutRequestResponseWithRequestNoResponseRequest&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestNoResponseRequest(
            other.CloneStorage()) {}
  WithAndWithoutRequestResponseWithRequestNoResponseRequest& operator=(
      const WithAndWithoutRequestResponseWithRequestNoResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::std::string& arg() const { return storage_.arg; }

  ::std::string& arg() { return storage_.arg; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest final
    : public ::fidl::internal::CodableBase<
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>;
  friend ::fidl::CodingTraits<
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>;
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      ::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::std::string arg{};
  };

  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      ::std::string arg) noexcept
      : storage_({.arg = std::move(arg)}) {}
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest()
      : WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
            Storage{}) {}

  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& operator=(
      WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&&) noexcept =
      default;
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
      const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&
          other) noexcept
      : WithAndWithoutRequestResponseWithRequestEmptyResponseRequest(
            other.CloneStorage()) {}
  WithAndWithoutRequestResponseWithRequestEmptyResponseRequest& operator=(
      const WithAndWithoutRequestResponseWithRequestEmptyResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::std::string& arg() const { return storage_.arg; }

  ::std::string& arg() { return storage_.arg; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

class WithAndWithoutRequestResponseOnWithResponseRequest final
    : public ::fidl::internal::CodableBase<
          WithAndWithoutRequestResponseOnWithResponseRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      WithAndWithoutRequestResponseOnWithResponseRequest>;
  friend ::fidl::CodingTraits<
      WithAndWithoutRequestResponseOnWithResponseRequest>;
  WithAndWithoutRequestResponseOnWithResponseRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::std::string ret{};
  };

  WithAndWithoutRequestResponseOnWithResponseRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseOnWithResponseRequest(::std::string ret) noexcept
      : storage_({.ret = std::move(ret)}) {}
  WithAndWithoutRequestResponseOnWithResponseRequest()
      : WithAndWithoutRequestResponseOnWithResponseRequest(Storage{}) {}

  WithAndWithoutRequestResponseOnWithResponseRequest(
      WithAndWithoutRequestResponseOnWithResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseOnWithResponseRequest& operator=(
      WithAndWithoutRequestResponseOnWithResponseRequest&&) noexcept = default;
  WithAndWithoutRequestResponseOnWithResponseRequest(
      const WithAndWithoutRequestResponseOnWithResponseRequest& other) noexcept
      : WithAndWithoutRequestResponseOnWithResponseRequest(
            other.CloneStorage()) {}
  WithAndWithoutRequestResponseOnWithResponseRequest& operator=(
      const WithAndWithoutRequestResponseOnWithResponseRequest&
          other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::std::string& ret() const { return storage_.ret; }

  ::std::string& ret() { return storage_.ret; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

class WithAndWithoutRequestResponseNoRequestWithResponseTopResponse final
    : public ::fidl::internal::CodableBase<
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>;
  friend ::fidl::CodingTraits<
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>;
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      ::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::std::string ret{};
  };

  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      ::std::string ret) noexcept
      : storage_({.ret = std::move(ret)}) {}
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse()
      : WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            Storage{}) {}

  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse& operator=(
      WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&&) noexcept =
      default;
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
      const WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
          other) noexcept
      : WithAndWithoutRequestResponseNoRequestWithResponseTopResponse(
            other.CloneStorage()) {}
  WithAndWithoutRequestResponseNoRequestWithResponseTopResponse& operator=(
      const WithAndWithoutRequestResponseNoRequestWithResponseTopResponse&
          other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::std::string& ret() const { return storage_.ret; }

  ::std::string& ret() { return storage_.ret; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

class TransitionalRequestTopResponse final
    : public ::fidl::internal::CodableBase<TransitionalRequestTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<TransitionalRequestTopResponse>;
  friend ::fidl::CodingTraits<TransitionalRequestTopResponse>;
  TransitionalRequestTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t y{};
  };

  TransitionalRequestTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalRequestTopResponse(int64_t y) noexcept
      : storage_({.y = std::move(y)}) {}
  TransitionalRequestTopResponse()
      : TransitionalRequestTopResponse(Storage{}) {}

  TransitionalRequestTopResponse(TransitionalRequestTopResponse&&) noexcept =
      default;
  TransitionalRequestTopResponse& operator=(
      TransitionalRequestTopResponse&&) noexcept = default;
  TransitionalRequestTopResponse(
      const TransitionalRequestTopResponse& other) noexcept
      : TransitionalRequestTopResponse(other.CloneStorage()) {}
  TransitionalRequestTopResponse& operator=(
      const TransitionalRequestTopResponse& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t y() const { return storage_.y; }

  int64_t& y() { return storage_.y; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

class TransitionalRequestRequest final
    : public ::fidl::internal::CodableBase<TransitionalRequestRequest> {
 private:
  friend ::fidl::internal::CodableBase<TransitionalRequestRequest>;
  friend ::fidl::CodingTraits<TransitionalRequestRequest>;
  TransitionalRequestRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t x{};
  };

  TransitionalRequestRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalRequestRequest(int64_t x) noexcept
      : storage_({.x = std::move(x)}) {}
  TransitionalRequestRequest() : TransitionalRequestRequest(Storage{}) {}

  TransitionalRequestRequest(TransitionalRequestRequest&&) noexcept = default;
  TransitionalRequestRequest& operator=(TransitionalRequestRequest&&) noexcept =
      default;
  TransitionalRequestRequest(const TransitionalRequestRequest& other) noexcept
      : TransitionalRequestRequest(other.CloneStorage()) {}
  TransitionalRequestRequest& operator=(
      const TransitionalRequestRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t x() const { return storage_.x; }

  int64_t& x() { return storage_.x; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

class TransitionalOneWayRequest final
    : public ::fidl::internal::CodableBase<TransitionalOneWayRequest> {
 private:
  friend ::fidl::internal::CodableBase<TransitionalOneWayRequest>;
  friend ::fidl::CodingTraits<TransitionalOneWayRequest>;
  TransitionalOneWayRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t x{};
  };

  TransitionalOneWayRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalOneWayRequest(int64_t x) noexcept
      : storage_({.x = std::move(x)}) {}
  TransitionalOneWayRequest() : TransitionalOneWayRequest(Storage{}) {}

  TransitionalOneWayRequest(TransitionalOneWayRequest&&) noexcept = default;
  TransitionalOneWayRequest& operator=(TransitionalOneWayRequest&&) noexcept =
      default;
  TransitionalOneWayRequest(const TransitionalOneWayRequest& other) noexcept
      : TransitionalOneWayRequest(other.CloneStorage()) {}
  TransitionalOneWayRequest& operator=(
      const TransitionalOneWayRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t x() const { return storage_.x; }

  int64_t& x() { return storage_.x; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

class TransitionalEventRequest final
    : public ::fidl::internal::CodableBase<TransitionalEventRequest> {
 private:
  friend ::fidl::internal::CodableBase<TransitionalEventRequest>;
  friend ::fidl::CodingTraits<TransitionalEventRequest>;
  TransitionalEventRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t x{};
  };

  TransitionalEventRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  TransitionalEventRequest(int64_t x) noexcept
      : storage_({.x = std::move(x)}) {}
  TransitionalEventRequest() : TransitionalEventRequest(Storage{}) {}

  TransitionalEventRequest(TransitionalEventRequest&&) noexcept = default;
  TransitionalEventRequest& operator=(TransitionalEventRequest&&) noexcept =
      default;
  TransitionalEventRequest(const TransitionalEventRequest& other) noexcept
      : TransitionalEventRequest(other.CloneStorage()) {}
  TransitionalEventRequest& operator=(
      const TransitionalEventRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t x() const { return storage_.x; }

  int64_t& x() { return storage_.x; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_TheUnionTable;

class TheUnion final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kV = 1,  // 0x1
    kUnknown = ::std::numeric_limits<::fidl_union_tag_t>::max(),
  };

 private:
  using Storage = cpp17::variant<cpp17::monostate, uint32_t>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::TheUnion>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 2>
      Members = {std::nullopt, std::nullopt};

  explicit TheUnion(std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(::test_protocols::TheUnion::Tag tag) {
    switch (tag) {
      case ::test_protocols::TheUnion::Tag::kV:
        return 1;
      case ::test_protocols::TheUnion::Tag::kUnknown:
        return 0;
    }
  }

  static constexpr ::test_protocols::TheUnion::Tag IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::TheUnion::Tag::kV;
      default:
        return ::test_protocols::TheUnion::Tag::kUnknown;
    }
  }

 public:
  // Create an unknown value of this union.
  TheUnion() : storage_(std::make_shared<Storage>()) {}

  TheUnion(TheUnion&&) noexcept = default;
  TheUnion& operator=(TheUnion&&) noexcept = default;
  TheUnion(const TheUnion& other) noexcept : TheUnion(other.CloneStorage()) {}
  TheUnion& operator=(const TheUnion& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_protocols::TheUnion::Tag Which() const {
    return TheUnion::IndexToTag(storage_->index());
  }
  static TheUnion WithV(uint32_t val) {
    return TheUnion(
        std::make_shared<Storage>(std::in_place_index_t<TagToIndex(
                                      ::test_protocols::TheUnion::Tag::kV)>{},
                                  std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> v() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> v() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
};

extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

class MethodWithUnionUnionMethodRequest final
    : public ::fidl::internal::CodableBase<MethodWithUnionUnionMethodRequest> {
 private:
  friend ::fidl::internal::CodableBase<MethodWithUnionUnionMethodRequest>;
  friend ::fidl::CodingTraits<MethodWithUnionUnionMethodRequest>;
  MethodWithUnionUnionMethodRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::TheUnion u{};
  };

  MethodWithUnionUnionMethodRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  MethodWithUnionUnionMethodRequest(::test_protocols::TheUnion u) noexcept
      : storage_({.u = std::move(u)}) {}
  MethodWithUnionUnionMethodRequest()
      : MethodWithUnionUnionMethodRequest(Storage{}) {}

  MethodWithUnionUnionMethodRequest(
      MethodWithUnionUnionMethodRequest&&) noexcept = default;
  MethodWithUnionUnionMethodRequest& operator=(
      MethodWithUnionUnionMethodRequest&&) noexcept = default;
  MethodWithUnionUnionMethodRequest(
      const MethodWithUnionUnionMethodRequest& other) noexcept
      : MethodWithUnionUnionMethodRequest(other.CloneStorage()) {}
  MethodWithUnionUnionMethodRequest& operator=(
      const MethodWithUnionUnionMethodRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::test_protocols::TheUnion& u() const { return storage_.u; }

  ::test_protocols::TheUnion& u() { return storage_.u; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

class SyscallProtocolMethodCRequest final
    : public ::fidl::internal::CodableBase<SyscallProtocolMethodCRequest> {
 private:
  friend ::fidl::internal::CodableBase<SyscallProtocolMethodCRequest>;
  friend ::fidl::CodingTraits<SyscallProtocolMethodCRequest>;
  SyscallProtocolMethodCRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t a{};
    int64_t b{};
  };

  SyscallProtocolMethodCRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  SyscallProtocolMethodCRequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  SyscallProtocolMethodCRequest() : SyscallProtocolMethodCRequest(Storage{}) {}

  SyscallProtocolMethodCRequest(SyscallProtocolMethodCRequest&&) noexcept =
      default;
  SyscallProtocolMethodCRequest& operator=(
      SyscallProtocolMethodCRequest&&) noexcept = default;
  SyscallProtocolMethodCRequest(
      const SyscallProtocolMethodCRequest& other) noexcept
      : SyscallProtocolMethodCRequest(other.CloneStorage()) {}
  SyscallProtocolMethodCRequest& operator=(
      const SyscallProtocolMethodCRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

#ifdef __Fuchsia__

extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

class ProtocolEnds final : public ::fidl::internal::CodableBase<ProtocolEnds> {
 private:
  friend ::fidl::internal::CodableBase<ProtocolEnds>;
  friend ::fidl::CodingTraits<ProtocolEnds>;
  ProtocolEnds(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client{};
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server{};
    ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt{};
    ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server_opt{};
  };

  ProtocolEnds(Storage storage) noexcept : storage_(std::move(storage)) {}
  ProtocolEnds(
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client,
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol> server,
      ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol> client_opt,
      ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>
          server_opt) noexcept
      : storage_({.client = std::move(client),
                  .server = std::move(server),
                  .client_opt = std::move(client_opt),
                  .server_opt = std::move(server_opt)}) {}
  ProtocolEnds() : ProtocolEnds(Storage{}) {}

  ProtocolEnds(ProtocolEnds&&) noexcept = default;
  ProtocolEnds& operator=(ProtocolEnds&&) noexcept = default;

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client()
      const {
    return storage_.client;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client() {
    return storage_.client;
  }

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server()
      const {
    return storage_.server;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server() {
    return storage_.server;
  }

  const ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client_opt()
      const {
    return storage_.client_opt;
  }

  ::fidl::ClientEnd<::test_protocols::DiscoverableProtocol>& client_opt() {
    return storage_.client_opt;
  }

  const ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server_opt()
      const {
    return storage_.server_opt;
  }

  ::fidl::ServerEnd<::test_protocols::DiscoverableProtocol>& server_opt() {
    return storage_.server_opt;
  }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

class WithProtocolEndsStructContainingEndsTopResponse final
    : public ::fidl::internal::CodableBase<
          WithProtocolEndsStructContainingEndsTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<
      WithProtocolEndsStructContainingEndsTopResponse>;
  friend ::fidl::CodingTraits<WithProtocolEndsStructContainingEndsTopResponse>;
  WithProtocolEndsStructContainingEndsTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::ProtocolEnds out{};
  };

  WithProtocolEndsStructContainingEndsTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsStructContainingEndsTopResponse(
      ::test_protocols::ProtocolEnds out) noexcept
      : storage_({.out = std::move(out)}) {}
  WithProtocolEndsStructContainingEndsTopResponse()
      : WithProtocolEndsStructContainingEndsTopResponse(Storage{}) {}

  WithProtocolEndsStructContainingEndsTopResponse(
      WithProtocolEndsStructContainingEndsTopResponse&&) noexcept = default;
  WithProtocolEndsStructContainingEndsTopResponse& operator=(
      WithProtocolEndsStructContainingEndsTopResponse&&) noexcept = default;

  const ::test_protocols::ProtocolEnds& out() const { return storage_.out; }

  ::test_protocols::ProtocolEnds& out() { return storage_.out; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

#ifdef __Fuchsia__

extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

class WithProtocolEndsStructContainingEndsRequest final
    : public ::fidl::internal::CodableBase<
          WithProtocolEndsStructContainingEndsRequest> {
 private:
  friend ::fidl::internal::CodableBase<
      WithProtocolEndsStructContainingEndsRequest>;
  friend ::fidl::CodingTraits<WithProtocolEndsStructContainingEndsRequest>;
  WithProtocolEndsStructContainingEndsRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::ProtocolEnds in{};
  };

  WithProtocolEndsStructContainingEndsRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithProtocolEndsStructContainingEndsRequest(
      ::test_protocols::ProtocolEnds in) noexcept
      : storage_({.in = std::move(in)}) {}
  WithProtocolEndsStructContainingEndsRequest()
      : WithProtocolEndsStructContainingEndsRequest(Storage{}) {}

  WithProtocolEndsStructContainingEndsRequest(
      WithProtocolEndsStructContainingEndsRequest&&) noexcept = default;
  WithProtocolEndsStructContainingEndsRequest& operator=(
      WithProtocolEndsStructContainingEndsRequest&&) noexcept = default;

  const ::test_protocols::ProtocolEnds& in() const { return storage_.in; }

  ::test_protocols::ProtocolEnds& in() { return storage_.in; }

 private:
  Storage storage_;
};

#endif  // __Fuchsia__

extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

class ManyParametersFifteenRequest final
    : public ::fidl::internal::CodableBase<ManyParametersFifteenRequest> {
 private:
  friend ::fidl::internal::CodableBase<ManyParametersFifteenRequest>;
  friend ::fidl::CodingTraits<ManyParametersFifteenRequest>;
  ManyParametersFifteenRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    bool p1{};
    bool p2{};
    bool p3{};
    bool p4{};
    bool p5{};
    bool p6{};
    bool p7{};
    bool p8{};
    bool p9{};
    bool p10{};
    bool p11{};
    bool p12{};
    bool p13{};
    bool p14{};
    bool p15{};
  };

  ManyParametersFifteenRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ManyParametersFifteenRequest(bool p1, bool p2, bool p3, bool p4, bool p5,
                               bool p6, bool p7, bool p8, bool p9, bool p10,
                               bool p11, bool p12, bool p13, bool p14,
                               bool p15) noexcept
      : storage_({.p1 = std::move(p1),
                  .p2 = std::move(p2),
                  .p3 = std::move(p3),
                  .p4 = std::move(p4),
                  .p5 = std::move(p5),
                  .p6 = std::move(p6),
                  .p7 = std::move(p7),
                  .p8 = std::move(p8),
                  .p9 = std::move(p9),
                  .p10 = std::move(p10),
                  .p11 = std::move(p11),
                  .p12 = std::move(p12),
                  .p13 = std::move(p13),
                  .p14 = std::move(p14),
                  .p15 = std::move(p15)}) {}
  ManyParametersFifteenRequest() : ManyParametersFifteenRequest(Storage{}) {}

  ManyParametersFifteenRequest(ManyParametersFifteenRequest&&) noexcept =
      default;
  ManyParametersFifteenRequest& operator=(
      ManyParametersFifteenRequest&&) noexcept = default;
  ManyParametersFifteenRequest(
      const ManyParametersFifteenRequest& other) noexcept
      : ManyParametersFifteenRequest(other.CloneStorage()) {}
  ManyParametersFifteenRequest& operator=(
      const ManyParametersFifteenRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  bool p1() const { return storage_.p1; }

  bool& p1() { return storage_.p1; }

  bool p2() const { return storage_.p2; }

  bool& p2() { return storage_.p2; }

  bool p3() const { return storage_.p3; }

  bool& p3() { return storage_.p3; }

  bool p4() const { return storage_.p4; }

  bool& p4() { return storage_.p4; }

  bool p5() const { return storage_.p5; }

  bool& p5() { return storage_.p5; }

  bool p6() const { return storage_.p6; }

  bool& p6() { return storage_.p6; }

  bool p7() const { return storage_.p7; }

  bool& p7() { return storage_.p7; }

  bool p8() const { return storage_.p8; }

  bool& p8() { return storage_.p8; }

  bool p9() const { return storage_.p9; }

  bool& p9() { return storage_.p9; }

  bool p10() const { return storage_.p10; }

  bool& p10() { return storage_.p10; }

  bool p11() const { return storage_.p11; }

  bool& p11() { return storage_.p11; }

  bool p12() const { return storage_.p12; }

  bool& p12() { return storage_.p12; }

  bool p13() const { return storage_.p13; }

  bool& p13() { return storage_.p13; }

  bool p14() const { return storage_.p14; }

  bool& p14() { return storage_.p14; }

  bool p15() const { return storage_.p15; }

  bool& p15() { return storage_.p15; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResultTable;

class WithErrorSyntax_ErrorAsEnum_Result final {
 public:
  // TODO: share union tag types between wire & natural.
  enum class Tag : fidl_union_tag_t {
    kResponse = 1,  // 0x1
    kErr = 2,       // 0x2
  };

 private:
  using Storage =
      cpp17::variant<cpp17::monostate,
                     ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response,
                     ::test_protocols::ErrorEnum>;
  std::shared_ptr<Storage> storage_;
  std::shared_ptr<Storage> CloneStorage() const;
  friend struct ::fidl::internal::NaturalUnionCodingTraits<
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>;
  static constexpr std::array<std::optional<::fidl::HandleInformation>, 3>
      Members = {std::nullopt, std::nullopt, std::nullopt};

  explicit WithErrorSyntax_ErrorAsEnum_Result(std::shared_ptr<Storage> storage)
      : storage_(std::move(storage)) {}

  static constexpr size_t TagToIndex(
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag tag) {
    switch (tag) {
      case ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kResponse:
        return 1;
      case ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr:
        return 2;
    }
  }

  static constexpr ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag
  IndexToTag(size_t index) {
    switch (index) {
      case 1:
        return ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
            kResponse;
      case 2:
        return ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr;
      // TODO: what's the right thing to do here?
      default:
        return ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
            kResponse;
    }
  }

 public:
  // Create an unknown value of this union.
  WithErrorSyntax_ErrorAsEnum_Result()
      : storage_(std::make_shared<Storage>()) {}

  WithErrorSyntax_ErrorAsEnum_Result(
      WithErrorSyntax_ErrorAsEnum_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Result& operator=(
      WithErrorSyntax_ErrorAsEnum_Result&&) noexcept = default;
  WithErrorSyntax_ErrorAsEnum_Result(
      const WithErrorSyntax_ErrorAsEnum_Result& other) noexcept
      : WithErrorSyntax_ErrorAsEnum_Result(other.CloneStorage()) {}
  WithErrorSyntax_ErrorAsEnum_Result& operator=(
      const WithErrorSyntax_ErrorAsEnum_Result& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  constexpr ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag Which()
      const {
    return WithErrorSyntax_ErrorAsEnum_Result::IndexToTag(storage_->index());
  }
  static WithErrorSyntax_ErrorAsEnum_Result WithResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response val) {
    return WithErrorSyntax_ErrorAsEnum_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::
                kResponse)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<1, Storage> response() const {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<1, Storage> response() {
    return ::fidl::internal::UnionMemberView<1, Storage>(storage_);
  }
  static WithErrorSyntax_ErrorAsEnum_Result WithErr(
      ::test_protocols::ErrorEnum val) {
    return WithErrorSyntax_ErrorAsEnum_Result(std::make_shared<Storage>(
        std::in_place_index_t<TagToIndex(
            ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result::Tag::kErr)>{},
        std::move(val)));
  }

  const ::fidl::internal::UnionMemberView<2, Storage> err() const {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
  ::fidl::internal::UnionMemberView<2, Storage> err() {
    return ::fidl::internal::UnionMemberView<2, Storage>(storage_);
  }
};

extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

class WithErrorSyntaxErrorAsEnumTopResponse final
    : public ::fidl::internal::CodableBase<
          WithErrorSyntaxErrorAsEnumTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<WithErrorSyntaxErrorAsEnumTopResponse>;
  friend ::fidl::CodingTraits<WithErrorSyntaxErrorAsEnumTopResponse>;
  WithErrorSyntaxErrorAsEnumTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result result{};
  };

  WithErrorSyntaxErrorAsEnumTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  WithErrorSyntaxErrorAsEnumTopResponse(
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result result) noexcept
      : storage_({.result = std::move(result)}) {}
  WithErrorSyntaxErrorAsEnumTopResponse()
      : WithErrorSyntaxErrorAsEnumTopResponse(Storage{}) {}

  WithErrorSyntaxErrorAsEnumTopResponse(
      WithErrorSyntaxErrorAsEnumTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsEnumTopResponse& operator=(
      WithErrorSyntaxErrorAsEnumTopResponse&&) noexcept = default;
  WithErrorSyntaxErrorAsEnumTopResponse(
      const WithErrorSyntaxErrorAsEnumTopResponse& other) noexcept
      : WithErrorSyntaxErrorAsEnumTopResponse(other.CloneStorage()) {}
  WithErrorSyntaxErrorAsEnumTopResponse& operator=(
      const WithErrorSyntaxErrorAsEnumTopResponse& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  const ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result& result() const {
    return storage_.result;
  }

  ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result& result() {
    return storage_.result;
  }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

class ChannelProtocolMethodBTopResponse final
    : public ::fidl::internal::CodableBase<ChannelProtocolMethodBTopResponse> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolMethodBTopResponse>;
  friend ::fidl::CodingTraits<ChannelProtocolMethodBTopResponse>;
  ChannelProtocolMethodBTopResponse(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t result{};
  };

  ChannelProtocolMethodBTopResponse(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMethodBTopResponse(int64_t result) noexcept
      : storage_({.result = std::move(result)}) {}
  ChannelProtocolMethodBTopResponse()
      : ChannelProtocolMethodBTopResponse(Storage{}) {}

  ChannelProtocolMethodBTopResponse(
      ChannelProtocolMethodBTopResponse&&) noexcept = default;
  ChannelProtocolMethodBTopResponse& operator=(
      ChannelProtocolMethodBTopResponse&&) noexcept = default;
  ChannelProtocolMethodBTopResponse(
      const ChannelProtocolMethodBTopResponse& other) noexcept
      : ChannelProtocolMethodBTopResponse(other.CloneStorage()) {}
  ChannelProtocolMethodBTopResponse& operator=(
      const ChannelProtocolMethodBTopResponse& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t result() const { return storage_.result; }

  int64_t& result() { return storage_.result; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

class ChannelProtocolMethodBRequest final
    : public ::fidl::internal::CodableBase<ChannelProtocolMethodBRequest> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolMethodBRequest>;
  friend ::fidl::CodingTraits<ChannelProtocolMethodBRequest>;
  ChannelProtocolMethodBRequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t a{};
    int64_t b{};
  };

  ChannelProtocolMethodBRequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMethodBRequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  ChannelProtocolMethodBRequest() : ChannelProtocolMethodBRequest(Storage{}) {}

  ChannelProtocolMethodBRequest(ChannelProtocolMethodBRequest&&) noexcept =
      default;
  ChannelProtocolMethodBRequest& operator=(
      ChannelProtocolMethodBRequest&&) noexcept = default;
  ChannelProtocolMethodBRequest(
      const ChannelProtocolMethodBRequest& other) noexcept
      : ChannelProtocolMethodBRequest(other.CloneStorage()) {}
  ChannelProtocolMethodBRequest& operator=(
      const ChannelProtocolMethodBRequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

class ChannelProtocolMethodARequest final
    : public ::fidl::internal::CodableBase<ChannelProtocolMethodARequest> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolMethodARequest>;
  friend ::fidl::CodingTraits<ChannelProtocolMethodARequest>;
  ChannelProtocolMethodARequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t a{};
    int64_t b{};
  };

  ChannelProtocolMethodARequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolMethodARequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  ChannelProtocolMethodARequest() : ChannelProtocolMethodARequest(Storage{}) {}

  ChannelProtocolMethodARequest(ChannelProtocolMethodARequest&&) noexcept =
      default;
  ChannelProtocolMethodARequest& operator=(
      ChannelProtocolMethodARequest&&) noexcept = default;
  ChannelProtocolMethodARequest(
      const ChannelProtocolMethodARequest& other) noexcept
      : ChannelProtocolMethodARequest(other.CloneStorage()) {}
  ChannelProtocolMethodARequest& operator=(
      const ChannelProtocolMethodARequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

class ChannelProtocolEventARequest final
    : public ::fidl::internal::CodableBase<ChannelProtocolEventARequest> {
 private:
  friend ::fidl::internal::CodableBase<ChannelProtocolEventARequest>;
  friend ::fidl::CodingTraits<ChannelProtocolEventARequest>;
  ChannelProtocolEventARequest(::fidl::Decoder& decoder);
  template <typename Payload>
  friend auto ::fidl::internal::EncodeTransactionalMessageWithoutValidating(
      ::fidl::Encoder& encoder, Payload&& payload)
      -> ::fidl::HLCPPOutgoingMessage;
  void EncodeWithoutValidating(::fidl::Encoder& encoder, size_t offset);

 public:
  struct Storage final {
    int64_t a{};
    int64_t b{};
  };

  ChannelProtocolEventARequest(Storage storage) noexcept
      : storage_(std::move(storage)) {}
  ChannelProtocolEventARequest(int64_t a, int64_t b) noexcept
      : storage_({.a = std::move(a), .b = std::move(b)}) {}
  ChannelProtocolEventARequest() : ChannelProtocolEventARequest(Storage{}) {}

  ChannelProtocolEventARequest(ChannelProtocolEventARequest&&) noexcept =
      default;
  ChannelProtocolEventARequest& operator=(
      ChannelProtocolEventARequest&&) noexcept = default;
  ChannelProtocolEventARequest(
      const ChannelProtocolEventARequest& other) noexcept
      : ChannelProtocolEventARequest(other.CloneStorage()) {}
  ChannelProtocolEventARequest& operator=(
      const ChannelProtocolEventARequest& other) noexcept {
    storage_ = other.CloneStorage();
    return *this;
  }

  int64_t a() const { return storage_.a; }

  int64_t& a() { return storage_.a; }

  int64_t b() const { return storage_.b; }

  int64_t& b() { return storage_.b; }

 private:
  Storage storage_;
  Storage CloneStorage() const;
};

}  // namespace test_protocols
namespace fidl {

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;

template <>
struct IsResource<::test_protocols::WithErrorSyntax_HandleInResult_Response>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_HandleInResult_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_HandleInResult_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_HandleInResult_ResponseTable;
};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntax_HandleInResult_Response> {
  static constexpr size_t inline_size_v1_no_ee = 4;
  static constexpr size_t inline_size_v2 = 4;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntax_HandleInResult_Response* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.h, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_NONE,
                       .rights = 0x80000000,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntax_HandleInResult_Response* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.h, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;

template <>
struct IsResource<::test_protocols::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxHandleInResultTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxHandleInResultTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxHandleInResultTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithErrorSyntaxHandleInResultTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntaxHandleInResultTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;

template <>
struct IsResource<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolResponseMethodTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.h, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x1,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::HandleRightsProtocolResponseMethodTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.h, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolResponseMethodRequestTable;

template <>
struct IsResource<::test_protocols::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::HandleRightsProtocolResponseMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolResponseMethodRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::HandleRightsProtocolResponseMethodRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::HandleRightsProtocolResponseMethodRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.h, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x3,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::HandleRightsProtocolResponseMethodRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.h, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;

template <>
struct IsResource<::test_protocols::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::HandleRightsProtocolNoResponseMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolNoResponseMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolNoResponseMethodRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::HandleRightsProtocolNoResponseMethodRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.h, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x3,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::HandleRightsProtocolNoResponseMethodRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.h, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_HandleRightsProtocolAnEventRequestTable;

template <>
struct IsResource<::test_protocols::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::HandleRightsProtocolAnEventRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::HandleRightsProtocolAnEventRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_HandleRightsProtocolAnEventRequestTable;
};

template <>
struct CodingTraits<::test_protocols::HandleRightsProtocolAnEventRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::HandleRightsProtocolAnEventRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.h, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x3,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::HandleRightsProtocolAnEventRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.h, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_ChannelProtocolTakeHandleRequestTable;

template <>
struct IsResource<::test_protocols::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ChannelProtocolTakeHandleRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolTakeHandleRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolTakeHandleRequestTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolTakeHandleRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolTakeHandleRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.h, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_NONE,
                       .rights = 0x80000000,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ChannelProtocolTakeHandleRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.h, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketTopResponseTable;

template <>
struct IsResource<::test_protocols::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ChannelProtocolMutateSocketTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMutateSocketTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMutateSocketTopResponseTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolMutateSocketTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolMutateSocketTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x80000000,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::ChannelProtocolMutateSocketTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.b, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMutateSocketRequestTable;

template <>
struct IsResource<::test_protocols::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ChannelProtocolMutateSocketRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMutateSocketRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMutateSocketRequestTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolMutateSocketRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolMutateSocketRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_SOCKET,
                       .rights = 0x80000000,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::ChannelProtocolMutateSocketRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsTopResponseTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsServerEndsTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsServerEndsTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsServerEndsTopResponseTable;
};

template <>
struct CodingTraits<::test_protocols::WithProtocolEndsServerEndsTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithProtocolEndsServerEndsTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.out, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithProtocolEndsServerEndsTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.out, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsServerEndsRequestTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsServerEndsRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsServerEndsRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsServerEndsRequestTable;
};

template <>
struct CodingTraits<::test_protocols::WithProtocolEndsServerEndsRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithProtocolEndsServerEndsRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.in, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::WithProtocolEndsServerEndsRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.in, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsTopResponseTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsClientEndsTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsClientEndsTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsClientEndsTopResponseTable;
};

template <>
struct CodingTraits<::test_protocols::WithProtocolEndsClientEndsTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithProtocolEndsClientEndsTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.out, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithProtocolEndsClientEndsTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.out, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsClientEndsRequestTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsClientEndsRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsClientEndsRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsClientEndsRequestTable;
};

template <>
struct CodingTraits<::test_protocols::WithProtocolEndsClientEndsRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithProtocolEndsClientEndsRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.in, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::WithProtocolEndsClientEndsRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.in, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ResponseAsStruct_ResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 24;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 16
                                                                           : 16;
    ::fidl::Encode(encoder, &value->storage_.c, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntax_ResponseAsStruct_Response* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.c, offset + 16);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxResponseAsStructTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntaxResponseAsStructTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ErrorAsPrimitive_ResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response> {
  static constexpr size_t inline_size_v1_no_ee = 1;
  static constexpr size_t inline_size_v2 = 1;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.__reserved, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Response* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.__reserved, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxErrorAsPrimitiveTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntaxErrorAsPrimitiveTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntax_ErrorAsEnum_ResponseTable;
};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntax_ErrorAsEnum_Response> {
  static constexpr size_t inline_size_v1_no_ee = 1;
  static constexpr size_t inline_size_v2 = 1;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.__reserved, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntax_ErrorAsEnum_Response* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.__reserved, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse*
              value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.ret, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseTopResponse*
              value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.ret, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestWithResponseRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestWithResponseRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.arg, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestWithResponseRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.arg, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithAndWithoutRequestResponseWithRequestNoResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestNoResponseRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestNoResponseRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.arg, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestNoResponseRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.arg, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseWithRequestEmptyResponseRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseWithRequestEmptyResponseRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.arg, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::
          WithAndWithoutRequestResponseWithRequestEmptyResponseRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.arg, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;

template <>
struct IsFidlType<
    ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseOnWithResponseRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest*
          value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.ret, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithAndWithoutRequestResponseOnWithResponseRequest*
          value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.ret, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;

template <>
struct IsFidlType<
    ::test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithAndWithoutRequestResponseNoRequestWithResponseTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::
        WithAndWithoutRequestResponseNoRequestWithResponseTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.ret, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::
          WithAndWithoutRequestResponseNoRequestWithResponseTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.ret, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_TransitionalRequestTopResponseTable;

template <>
struct IsFidlType<::test_protocols::TransitionalRequestTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::TransitionalRequestTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalRequestTopResponseTable;
};

template <>
struct CodingTraits<::test_protocols::TransitionalRequestTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::TransitionalRequestTopResponse* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.y, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::TransitionalRequestTopResponse* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.y, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_TransitionalRequestRequestTable;

template <>
struct IsFidlType<::test_protocols::TransitionalRequestRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::TransitionalRequestRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalRequestRequestTable;
};

template <>
struct CodingTraits<::test_protocols::TransitionalRequestRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::TransitionalRequestRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.x, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::TransitionalRequestRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.x, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_TransitionalOneWayRequestTable;

template <>
struct IsFidlType<::test_protocols::TransitionalOneWayRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::TransitionalOneWayRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalOneWayRequestTable;
};

template <>
struct CodingTraits<::test_protocols::TransitionalOneWayRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::TransitionalOneWayRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.x, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::TransitionalOneWayRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.x, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_TransitionalEventRequestTable;

template <>
struct IsFidlType<::test_protocols::TransitionalEventRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::TransitionalEventRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_TransitionalEventRequestTable;
};

template <>
struct CodingTraits<::test_protocols::TransitionalEventRequest> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::TransitionalEventRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.x, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::TransitionalEventRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.x, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_MethodWithUnionUnionMethodRequestTable;

template <>
struct IsFidlType<::test_protocols::MethodWithUnionUnionMethodRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::MethodWithUnionUnionMethodRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_MethodWithUnionUnionMethodRequestTable;
};

template <>
struct CodingTraits<::test_protocols::MethodWithUnionUnionMethodRequest> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::MethodWithUnionUnionMethodRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.u, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::MethodWithUnionUnionMethodRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.u, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_SyscallProtocolMethodCRequestTable;

template <>
struct IsFidlType<::test_protocols::SyscallProtocolMethodCRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::SyscallProtocolMethodCRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_SyscallProtocolMethodCRequestTable;
};

template <>
struct CodingTraits<::test_protocols::SyscallProtocolMethodCRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::SyscallProtocolMethodCRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::SyscallProtocolMethodCRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_ProtocolEndsTable;

template <>
struct IsResource<::test_protocols::ProtocolEnds> : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::ProtocolEnds> : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<::test_protocols::ProtocolEnds> final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ProtocolEndsTable;
};

template <>
struct CodingTraits<::test_protocols::ProtocolEnds> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::ProtocolEnds* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.client, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.server, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.client_opt, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 12
                                                                           : 12;
    ::fidl::Encode(encoder, &value->storage_.server_opt, offset + field_offset,
                   ::fidl::HandleInformation{
                       .object_type = ZX_OBJ_TYPE_CHANNEL,
                       .rights = ZX_DEFAULT_CHANNEL_RIGHTS,
                   });
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ProtocolEnds* value, size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.client, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.server, offset + 4);
    ::fidl::Decode(decoder, &value->storage_.client_opt, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.server_opt, offset + 12);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;

template <>
struct IsResource<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};
template <>
struct IsFidlType<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsStructContainingEndsTopResponseTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.out, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithProtocolEndsStructContainingEndsTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.out, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithProtocolEndsStructContainingEndsRequestTable;

template <>
struct IsResource<::test_protocols::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithProtocolEndsStructContainingEndsRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithProtocolEndsStructContainingEndsRequestTable;
};

template <>
struct CodingTraits<
    ::test_protocols::WithProtocolEndsStructContainingEndsRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.in, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithProtocolEndsStructContainingEndsRequest* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.in, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_ManyParametersFifteenRequestTable;

template <>
struct IsFidlType<::test_protocols::ManyParametersFifteenRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ManyParametersFifteenRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ManyParametersFifteenRequestTable;
};

template <>
struct CodingTraits<::test_protocols::ManyParametersFifteenRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ManyParametersFifteenRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.p1, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 1
                                                                           : 1;
    ::fidl::Encode(encoder, &value->storage_.p2, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 2
                                                                           : 2;
    ::fidl::Encode(encoder, &value->storage_.p3, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 3
                                                                           : 3;
    ::fidl::Encode(encoder, &value->storage_.p4, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 4
                                                                           : 4;
    ::fidl::Encode(encoder, &value->storage_.p5, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 5
                                                                           : 5;
    ::fidl::Encode(encoder, &value->storage_.p6, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 6
                                                                           : 6;
    ::fidl::Encode(encoder, &value->storage_.p7, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 7
                                                                           : 7;
    ::fidl::Encode(encoder, &value->storage_.p8, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.p9, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 9
                                                                           : 9;
    ::fidl::Encode(encoder, &value->storage_.p10, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 10
                                                                           : 10;
    ::fidl::Encode(encoder, &value->storage_.p11, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 11
                                                                           : 11;
    ::fidl::Encode(encoder, &value->storage_.p12, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 12
                                                                           : 12;
    ::fidl::Encode(encoder, &value->storage_.p13, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 13
                                                                           : 13;
    ::fidl::Encode(encoder, &value->storage_.p14, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 14
                                                                           : 14;
    ::fidl::Encode(encoder, &value->storage_.p15, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ManyParametersFifteenRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.p1, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.p2, offset + 1);
    ::fidl::Decode(decoder, &value->storage_.p3, offset + 2);
    ::fidl::Decode(decoder, &value->storage_.p4, offset + 3);
    ::fidl::Decode(decoder, &value->storage_.p5, offset + 4);
    ::fidl::Decode(decoder, &value->storage_.p6, offset + 5);
    ::fidl::Decode(decoder, &value->storage_.p7, offset + 6);
    ::fidl::Decode(decoder, &value->storage_.p8, offset + 7);
    ::fidl::Decode(decoder, &value->storage_.p9, offset + 8);
    ::fidl::Decode(decoder, &value->storage_.p10, offset + 9);
    ::fidl::Decode(decoder, &value->storage_.p11, offset + 10);
    ::fidl::Decode(decoder, &value->storage_.p12, offset + 11);
    ::fidl::Decode(decoder, &value->storage_.p13, offset + 12);
    ::fidl::Decode(decoder, &value->storage_.p14, offset + 13);
    ::fidl::Decode(decoder, &value->storage_.p15, offset + 14);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;

template <>
struct IsFidlType<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_WithErrorSyntaxErrorAsEnumTopResponseTable;
};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 24;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse* value,
      size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(
      DecoderImpl* decoder,
      ::test_protocols::WithErrorSyntaxErrorAsEnumTopResponse* value,
      size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t
    test_protocols_ChannelProtocolMethodBTopResponseTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolMethodBTopResponse>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMethodBTopResponse>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMethodBTopResponseTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolMethodBTopResponse> {
  static constexpr size_t inline_size_v1_no_ee = 8;
  static constexpr size_t inline_size_v2 = 8;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolMethodBTopResponse* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.result, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ChannelProtocolMethodBTopResponse* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.result, offset + 0);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodBRequestTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolMethodBRequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMethodBRequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMethodBRequestTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolMethodBRequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolMethodBRequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ChannelProtocolMethodBRequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_ChannelProtocolMethodARequestTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolMethodARequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolMethodARequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolMethodARequestTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolMethodARequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolMethodARequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ChannelProtocolMethodARequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

#ifdef __Fuchsia__
extern "C" const fidl_type_t test_protocols_ChannelProtocolEventARequestTable;

template <>
struct IsFidlType<::test_protocols::ChannelProtocolEventARequest>
    : public std::true_type {};

template <>
struct ::fidl::internal::TypeTraits<
    ::test_protocols::ChannelProtocolEventARequest>
    final {
 public:
  static constexpr const fidl_type_t* kCodingTable =
      &test_protocols_ChannelProtocolEventARequestTable;
};

template <>
struct CodingTraits<::test_protocols::ChannelProtocolEventARequest> {
  static constexpr size_t inline_size_v1_no_ee = 16;
  static constexpr size_t inline_size_v2 = 16;

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder,
      ::test_protocols::ChannelProtocolEventARequest* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    [[maybe_unused]] uint32_t field_offset;
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 0
                                                                           : 0;
    ::fidl::Encode(encoder, &value->storage_.a, offset + field_offset);
    field_offset =
        encoder->wire_format() == ::fidl::internal::WireFormatVersion::kV1 ? 8
                                                                           : 8;
    ::fidl::Encode(encoder, &value->storage_.b, offset + field_offset);
  }

  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder,
                     ::test_protocols::ChannelProtocolEventARequest* value,
                     size_t offset) {
    ::fidl::Decode(decoder, &value->storage_.a, offset + 0);
    ::fidl::Decode(decoder, &value->storage_.b, offset + 8);
  }
};
#endif  // __Fuchsia__

template <>
struct IsResource<::test_protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};
template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_HandleInResult_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntax_HandleInResult_Result>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_HandleInResult_Result> {};

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntax_ResponseAsStruct_Result>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_ResponseAsStruct_Result> {};

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result>
    final : public ::fidl::internal::NaturalUnionCodingTraits<
                ::test_protocols::WithErrorSyntax_ErrorAsPrimitive_Result> {};

template <>
struct IsFidlType<::test_protocols::TheUnion> : public std::true_type {};

template <>
struct CodingTraits<::test_protocols::TheUnion> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_protocols::TheUnion> {};

template <>
struct IsFidlType<::test_protocols::WithErrorSyntax_ErrorAsEnum_Result>
    : public std::true_type {};

template <>
struct CodingTraits<::test_protocols::WithErrorSyntax_ErrorAsEnum_Result> final
    : public ::fidl::internal::NaturalUnionCodingTraits<
          ::test_protocols::WithErrorSyntax_ErrorAsEnum_Result> {};

template <>
struct CodingTraits<::test_protocols::rights> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::rights* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_protocols::rights* value,
                     size_t offset) {
    // TODO: decode
  }
};

template <>
struct CodingTraits<::test_protocols::obj_type> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::obj_type* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_protocols::obj_type* value,
                     size_t offset) {
    // TODO: decode
  }
};
template <>
struct CodingTraits<::test_protocols::ErrorEnum> {
  static constexpr size_t inline_size_v1_no_ee = sizeof(uint32_t);
  static constexpr size_t inline_size_v2 = sizeof(uint32_t);

  template <class EncoderImpl>
  static void Encode(
      EncoderImpl* encoder, ::test_protocols::ErrorEnum* value, size_t offset,
      cpp17::optional<HandleInformation> maybe_handle_info = cpp17::nullopt) {
    // TODO: encode
  }
  template <typename DecoderImpl>
  static void Decode(DecoderImpl* decoder, ::test_protocols::ErrorEnum* value,
                     size_t offset) {
    // TODO: decode
  }
};

}  // namespace fidl
