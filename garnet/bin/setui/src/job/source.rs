// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! Job Source Support
//!
//! # Summary
//!
//! The source mod contains components for providing [Jobs](Job) to Job manager (most likely
//! [manager](job::manager::Manager)). In a typical workflow, client code will create a [Seeder],
//! which is used to send [Job](Job) streams to a manager via the
//! [MessageHub](crate::message::message_hub::MessageHub). The [Seeder] can send any stream where
//! the data implements [Into<Job>]. Once the source is received, the manager can assign a unique
//! [Id] to the source, using [IdGenerator]. The manager can then use a [Handler] to handle the
//!  produced [Jobs](Job) and their results.

use crate::clock::now;
use crate::job::{self, Job, Payload};
use crate::message::base::{Audience, MessengerType};
use crate::service::message::{Delegate, Messenger, Signature};

use core::pin::Pin;
use fuchsia_async as fasync;
use fuchsia_zircon as zx;
use futures::lock::Mutex;
use futures::Stream;
use futures::StreamExt;
use std::collections::VecDeque;
use std::sync::Arc;
use thiserror::Error as ThisError;

#[derive(Clone)]
/// [Seeder] properly packages and sends [Job] source streams to a [Job] manager.
pub struct Seeder {
    /// A [Messenger](crate::message::messenger::MessengerClient) to send Payloads to the manager.
    messenger: Messenger,
    /// The [Signature](crate::message::base::Signature) of the manager to receive the source
    /// Payloads.
    manager_signature: Signature,
}

impl Seeder {
    // TODO(fxbug.dev/70534): Use Manager to handle FIDL requests.
    #[allow(dead_code)]
    pub async fn new(delegate: &Delegate, manager_signature: Signature) -> Self {
        Self {
            messenger: delegate
                .create(MessengerType::Unbound)
                .await
                .expect("should create messenger")
                .0,
            manager_signature: manager_signature,
        }
    }

    // TODO(fxbug.dev/70534): Use Manager to handle FIDL requests.
    #[allow(dead_code)]
    pub async fn seed<
        J: Into<Job>,
        E: Into<Error>,
        T: 'static + Stream<Item = Result<J, E>> + Send,
    >(
        &self,
        source: T,
    ) {
        // Convert the incoming stream into the expected types for a Job source.
        let mapped_stream: Pin<Box<dyn Stream<Item = Result<Job, Error>> + Send>> =
            source.map(|result| result.map(Into::into).map_err(Into::into)).boxed();

        // Send the source stream to the manager.
        self.messenger
            .message(
                Payload::Source(Arc::new(Mutex::new(Some(mapped_stream)))).into(),
                Audience::Messenger(self.manager_signature),
            )
            .send()
            .ack();
    }
}

/// The types of errors for [Jobs](Job). This is a single, unified set over all Job source
/// related-errors. This enumeration should be expanded to capture any future error variant.
#[derive(ThisError, Debug, Clone, PartialEq)]
pub enum Error {
    #[error("Unknown error")]
    Unknown,
}

#[derive(Debug, PartialEq)]
/// The current state of the source. This is used by the managing entity to understand how to handle
/// pending and completed [Jobs](Job) from a source.
pub(super) enum State {
    /// The source is still available to produce new [Jobs](Job).
    Active,
    /// The source is no longer producing new [Jobs](Job).
    Completed,
}

/// [Id] provides a unique identifier for a source within its parent space, most often a manager.
// TODO(fxbug.dev/73541): Explore using generational indices instead.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub(super) struct Id {
    _identifier: usize,
}

impl Id {
    fn new(identifier: usize) -> Self {
        Self { _identifier: identifier }
    }
}

/// [IdGenerator] creates unique [Ids](Id) to be associated with a source. This uniqueness is
/// guaranteed for [Ids] generated by the same [IdGenerator].
pub(super) struct IdGenerator {
    next_identifier: usize,
}

impl IdGenerator {
    pub fn new() -> Self {
        Self { next_identifier: 0 }
    }

    pub fn generate(&mut self) -> Id {
        let return_id = Id::new(self.next_identifier);
        self.next_identifier += 1;

        return_id
    }
}

/// [Handler] handles [Jobs](Job) within the scope of a single scope. It determines what [Job](Job)
/// should be executed (if any). This responsibility includes managing any queueing that might be
/// necessary based on the [Job] type.
pub(super) struct Handler {
    /// A [IdGenerator](job::IdGenerator) to assign unique ids to incoming jobs.
    job_id_generator: job::IdGenerator,
    /// A list of [Jobs](Job) to be executed.
    // TODO(fxbug.dev/73503): Add grouping/association based on signature.
    pending_jobs: Vec<job::Info>,
    /// The [Id](job::Id) of the currently executing [Job]. None if no [Job] is executing for this
    /// source.
    executing_job: Option<job::Id>,
    /// A list of states. The element represents the most current [State]. We keep track of seen
    /// states to allow post analysis, such as source duration.
    states: VecDeque<(State, zx::Time)>,
}

impl Handler {
    pub fn new() -> Self {
        let mut handler = Self {
            job_id_generator: job::IdGenerator::new(),
            pending_jobs: Vec::new(),
            executing_job: None,
            states: VecDeque::new(),
        };

        handler.set_state(State::Active);

        handler
    }

    /// Marks the source as completed.
    pub fn complete(&mut self) {
        self.set_state(State::Completed);
    }

    /// Returns whether the source has completed.
    pub fn is_completed(&mut self) -> bool {
        self.states.back().map_or(false, |(state, _)| *state == State::Completed)
    }

    fn set_state(&mut self, state: State) {
        // State should not be set after the source has been completed.
        assert!(!self.is_completed());

        self.states.push_back((state, now()));
    }

    pub fn execute_next<F: Fn(job::Info, job::execution::Details) + Send + 'static>(
        &mut self,
        messenger: Messenger,
        callback: F,
    ) -> bool {
        // Prevent multiple simultaneous Job executions for now.
        if self.executing_job.is_some() || self.pending_jobs.is_empty() {
            return false;
        }

        // Retrieve next pending Job.
        let mut job_info = self.pending_jobs.remove(0);
        let job_id = job_info.id;
        self.executing_job = Some(job_id);

        fasync::Task::spawn(async move {
            let start = now();
            job_info.get_job_mut().workload.execute(messenger).await;
            callback(job_info, job::execution::Details { start_time: start, end_time: now() });
        })
        .detach();

        return true;
    }

    /// Returns whether there are jobs in the pipe.
    pub fn has_jobs(&self) -> bool {
        !self.pending_jobs.is_empty() || self.executing_job.is_some()
    }

    /// Adds a [Job] to be handled by this [Handler].
    pub fn add_job(&mut self, incoming_job: Job) {
        self.pending_jobs.push(job::Info::new(self.job_id_generator.generate(), incoming_job));
    }

    /// Informs the [Handler] that a [Job] by the given [Id](job::Id) has completed.
    pub fn handle_job_completion(&mut self, job_id: job::Id) {
        // The job should be tracked by this source.
        assert_eq!(self.executing_job.take().expect("job should be present"), job_id);
        // Clear any tracking.
        self.executing_job = None;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::job::ExecutionType;
    use crate::service::message;
    use crate::service::test;
    use crate::tests::scaffold::workload::{StubWorkload, Workload};

    use futures::FutureExt;
    use matches::assert_matches;

    #[test]
    fn test_id_generation() {
        let mut generator = IdGenerator::new();
        // Ensure generator is creating unique ids
        assert!(generator.generate() != generator.generate());
    }

    #[fuchsia_async::run_until_stalled(test)]
    async fn test_seeding() {
        // Create delegate for communication between components.
        let message_hub_delegate = message::create_hub();

        // Create a top-level receptor to receive sources.
        let mut receptor = message_hub_delegate
            .create(MessengerType::Unbound)
            .await
            .expect("should create receptor")
            .1;

        // Create seeder.
        let seeder = Seeder::new(&message_hub_delegate, receptor.get_signature()).await;

        let job_stream = async {
            Ok(Job::new(StubWorkload::new(), ExecutionType::Independent)) as Result<Job, Error>
        }
        .into_stream();

        seeder.seed(job_stream).await;

        assert_matches!(receptor.next_of::<Payload>().await, Ok((Payload::Source(_), _)));
    }

    #[fuchsia_async::run_until_stalled(test)]
    async fn test_handling() {
        // Create delegate for communication between components.
        let message_hub_delegate = message::create_hub();

        let results: Vec<i64> = (0..10).collect();

        // Create a top-level receptor to receive job results from.
        let mut receptor = message_hub_delegate
            .create(MessengerType::Unbound)
            .await
            .expect("should create receptor")
            .1;

        let mut handler = Handler::new();

        let messenger = message_hub_delegate
            .create(MessengerType::Unbound)
            .await
            .expect("should create messenger")
            .0;

        assert!(!handler.execute_next(messenger, |_, _| {}));

        for result in &results {
            handler.add_job(Job::new(
                Workload::new(test::Payload::Integer(*result), receptor.get_signature()),
                ExecutionType::Independent,
            ));
        }

        for result in results {
            // Create a messenger to send communication from the workload.
            let messenger = message_hub_delegate
                .create(MessengerType::Unbound)
                .await
                .expect("should create messenger")
                .0;

            let (execution_tx, mut execution_rx) = futures::channel::mpsc::unbounded::<job::Id>();

            // Execute job.
            assert!(handler.execute_next(messenger, move |job, _| {
                execution_tx.unbounded_send(job.id).expect("send should succeed");
            }));

            // Confirm received value matches the value sent from workload.
            let test::Payload::Integer(value) =
                receptor.next_of::<test::Payload>().await.expect("should have payload").0;
            assert_eq!(value, result);

            handler
                .handle_job_completion(execution_rx.next().await.expect("should have gotten id"));
        }
    }
}
