// Copyright 2021 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

//! Job Handling Support
//!
//! # Summary
//!
//! [Jobs] are basic units of work that interfaces in the setting service can specify. In addition
//! to the workload, [Job] definitions also capture information about how the work should be
//! handled. For example, a Job can specify that it would like to run in sequence within a set of
//! similar [Jobs](Job). This behavior is captured by the [Job's](Job) [ExecutionType].
//!
//! Sources are streams that provide jobs from a given source. The lifetime of (Jobs)[Job] produced
//! by a source are bound to the source's lifetime. The end of a source stream will lead to any
//! in-flight and pending jobs being cancelled.
//!
//! Job Manager is responsible for managing sources and the jobs they produce. The manager
//! associates and maintains any supporting data for jobs, such as caches.
use crate::clock::now;
use crate::payload_convert;
use crate::service::message;

use async_trait::async_trait;
use core::fmt::{Debug, Formatter};
use core::pin::Pin;
use fuchsia_zircon as zx;
use futures::lock::Mutex;
use futures::stream::Stream;
use std::sync::Arc;

pub mod manager;
pub mod source;

payload_convert!(Job, Payload);

/// The data payload that can be sent to the [Job Manager](crate::job::manager::Manager).
#[derive(Clone)]
pub enum Payload {
    /// [Source] represents a new source of [Jobs](Job).
    Source(Arc<Mutex<Option<Pin<Box<dyn Stream<Item = Result<Job, source::Error>> + Send>>>>>),
}

impl Debug for Payload {
    fn fmt(&self, f: &mut Formatter<'_>) -> core::fmt::Result {
        write!(f, "Job Payload")
    }
}

impl PartialEq for Payload {
    fn eq(&self, _other: &Self) -> bool {
        false
    }
}

/// A trait for creating work that can be executed as a job.
#[async_trait]
pub trait Workload {
    /// Called when a [Workload] should run. All workload specific logic should be encompassed in
    /// this method.
    async fn execute(&mut self, messenger: message::Messenger);
}

/// An identifier specified by [Jobs](Job) to group related workflows. This is useful for
/// [Workloads](Workload) that need to be run sequentially. The [Signature] is used by the job
/// infrastructure to associate resources such as caches.
#[derive(PartialEq, Clone, Debug, Eq, Hash)]
pub struct Signature {
    key: String,
}

impl Signature {
    /// Constructs a new [Signature]. The key provided will group the associated [Job] with other
    /// [Jobs](Job) of the same key. The association is scoped to other [Jobs](Job) in the same
    /// parent source.
    pub fn new(key: String) -> Self {
        Self { key }
    }
}

/// The workload types of a [Job]. This enumeration is used to define how a [Job] will be treated in
/// relation to other jobs from the same source.
pub enum ExecutionType {
    /// Independent jobs are executed in isolation from other [Jobs](Job). Some functionality is
    /// unavailable for Independent jobs, such as caches.
    Independent,
    /// Sequential [Jobs](Job) wait until all pre-existing [Jobs](Job) of the same [Signature] are
    /// completed.
    Sequential(Signature),
}

/// A [Job] is a simple data container that associates a [Workload] with an [ExecutionType]
/// along with metadata, such as the creation time.
pub struct Job {
    /// The [Workload] to be run.
    pub workload: Box<dyn Workload + Send + Sync>,
    /// The [ExecutionType] determining how the [Workload] will be run.
    pub execution_type: ExecutionType,
}

impl Job {
    pub fn new(workload: Box<dyn Workload + Send + Sync>, execution_type: ExecutionType) -> Self {
        Self { workload, execution_type }
    }
}

/// [Id] provides a unique identifier for a job within its parent space. Unlike
/// [Signatures](Signature), All [Job Ids](Id) will be unique per [Job]. [Ids](Id) should never be
/// directly constructed. An [IdGenerator] should be used instead.
// TODO(fxbug.dev/73541): Explore using generational indices instead.
#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]
pub(super) struct Id {
    _identifier: usize,
}

impl Id {
    fn new(identifier: usize) -> Self {
        Self { _identifier: identifier }
    }
}

/// [`IdGenerator`] is responsible for generating unique [Ids](Id).
pub(super) struct IdGenerator {
    next_identifier: usize,
}

impl IdGenerator {
    pub fn new() -> Self {
        Self { next_identifier: 0 }
    }

    /// Produces a [`Id`] that is unique from any [`Id`] that has or will be generated by this
    /// [`IdGenerator`] instance.
    pub fn generate(&mut self) -> Id {
        let return_id = Id::new(self.next_identifier);
        self.next_identifier += 1;

        return_id
    }
}

/// [Info] is used to capture details about a [Job] once it has been accepted by an entity that will
/// process it. This includes an assigned [Id] and a recording at what time it was accepted.
pub(self) struct Info {
    pub id: Id,
    pub acceptance_time: zx::Time,
    pub job: Job,
}

impl Info {
    pub fn new(id: Id, job: Job) -> Self {
        Self { id, acceptance_time: now(), job }
    }

    /// Returns a mutable reference to the contained [Job].
    pub fn get_job_mut(&mut self) -> &mut Job {
        return &mut self.job;
    }
}

pub(super) mod execution {
    use fuchsia_zircon as zx;
    /// [Details] represent the final result of an execution.
    pub(super) struct Details {
        /// The time at which the job execution started.
        pub start_time: zx::Time,
        /// The time at which the job execution ended.
        pub end_time: zx::Time,
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::message::base::MessengerType;
    use crate::service::test::Payload;
    use crate::tests::scaffold::workload::Workload;

    use matches::assert_matches;
    use rand::Rng;

    #[test]
    fn test_id_generation() {
        let mut generator = IdGenerator::new();
        // Ensure generator creates subsequent ids that don't match.
        assert!(generator.generate() != generator.generate());
    }

    #[fuchsia_async::run_until_stalled(test)]
    async fn test_job_functionality() {
        // Create delegate for communication between components.
        let message_hub_delegate = message::create_hub();

        // Create a top-level receptor to receive communication from the workload.
        let mut receptor = message_hub_delegate
            .create(MessengerType::Unbound)
            .await
            .expect("should create receptor")
            .1;

        // Create a messenger to send communication from the workload.
        let messenger = message_hub_delegate
            .create(MessengerType::Unbound)
            .await
            .expect("should create messenger")
            .0;

        let mut rng = rand::thread_rng();
        // The value expected to be conveyed from workload to receptor.
        let val = rng.gen();

        // Create job from workload scaffolding.
        let mut job = Job::new(
            Workload::new(Payload::Integer(val), receptor.get_signature()),
            ExecutionType::Independent,
        );

        job.workload.execute(messenger).await;

        // Confirm received value matches the value sent from workload.
        assert_matches!(
            receptor.next_of::<Payload>().await.expect("should return result, not error").0,
            Payload::Integer(value) if value == val);
    }
}
