// Copyright 2022 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.virtualization;

using zx;

type GuestStatus = strict enum {
    /// Initial state when the guest manager is created but before the guest has ever been run.
    NOT_STARTED = 1;

    /// A client has instructed the guest manager to begin launching the guest.
    STARTING = 2;

    /// The guest's dispatch loops are running. This is the expected steady state.
    RUNNING = 3;

    /// A client has instructed the guest manager to begin stopping the guest. If a non-zero
    /// has been provided, the guest manager may attempt to gracefully shutdown the guest.
    STOPPING = 4;

    /// The guest is no longer running. A stop reason may be present if the guest stopped due to
    /// an error.
    STOPPED = 5;

    /// The VMM component terminated unexpectedly. Attempting to launch the guest again will
    /// restart the component.
    VMM_UNEXPECTED_TERMINATION = 6;
};

/// An informational only subset of the GuestConfig. If adding new non-handle entries to the
/// GuestConfig, consider also adding them here.
type GuestDescriptor = table {
    /// Number of guest VCPUs.
    1: num_cpus uint8;

    /// Guest memory in bytes.
    2: guest_memory uint64;

    /// Whether the guest was started with the given virtual device.
    3: wayland bool;
    4: magma bool;
    5: network bool;
    6: balloon bool;
    7: console bool;
    8: gpu bool;
    9: rng bool;
   10: vsock bool;
   11: sound bool;
};

type GuestInfo = table {
    /// The current state of the guest.
    1: guest_status GuestStatus;

    /// Current uptime of the guest.
    2: uptime zx.duration;

    /// A subset of the config used to start the guest.
    3: guest_descriptor GuestDescriptor;

    /// Contains the last value reported to the guest manager if stopped due to an error.
    4: stop_error GuestError;
};

@discoverable
protocol GuestManager {
    /// Launch a new guest instance
    ///
    /// Returns ZX_ERR_ALREADY_EXISTS if the guest already launched
    /// Returns ZX_ERR_INVALID_ARGS if failed to parse config from the guest package
    /// TODO(fxbug.dev/104989): Return a GuestManagerError.
    LaunchGuest(resource struct {
        guest_config GuestConfig;
        controller server_end:Guest;
    }) -> (struct {}) error zx.status;

    /// Connect to a currently running guest
    /// TODO(fxbug.dev/104989): Return a GuestManagerError.
    ConnectToGuest(resource struct {
        controller server_end:Guest;
    }) -> (struct {}) error zx.status;

    /// Query guest info
    GetGuestInfo() -> (resource struct {
        guest_info GuestInfo;
    });
};

// TODO(fxbug.dev/100515): Reconsider the use of composition here
@discoverable
protocol ZirconGuestManager {
    compose GuestManager;
};

@discoverable
protocol DebianGuestManager {
    compose GuestManager;
};

@discoverable
protocol TerminaGuestManager {
    compose GuestManager;
};
