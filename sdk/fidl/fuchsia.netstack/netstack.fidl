// Copyright 2013 The Fuchsia Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
library fuchsia.netstack;

using fuchsia.hardware.ethernet;
using fuchsia.net.dhcp;
using fuchsia.net.interfaces;
using zx;

type NetErr = struct {
    status strict enum {
        OK = 0;
        UNKNOWN_ERROR = 1;
        DNS_ERROR = 2;
        PARSE_ERROR = 3;
        IPV4_ONLY = 4;
        UNKNOWN_INTERFACE = 5;
    };
    message string:MAX;
};

@discoverable
protocol Netstack {
    /// Creates a bridge and returns the newly created nicid or an
    /// error if the creation fails.
    BridgeInterfaces(struct {
        nicids vector<uint32>:MAX;
    }) -> (struct {
        result NetErr;
        nicid uint32;
    });

    /// Adds a new interface backed by the given ethernet device.
    AddEthernetDevice(resource struct {
        topological_path string:MAX;
        interface_config struct {
            name fuchsia.net.interfaces.name;

            /// An unstable file path corresponding to the interface. Used in
            /// watching the creation and destruction of the interface, or in
            /// accessing the interface using netdump.
            filepath string:MAX;

            metric uint32;
        };
        device client_end:fuchsia.hardware.ethernet.Device;
    }) -> (struct {
        nicid uint32;
    }) error zx.status;

    /// Connects to a DHCP client.
    ///
    /// + request `nicid` the interface on which the target client is running.
    /// + request `request` grants control over the client.
    // TODO(stijlist): re-home this protocol. GetDhcpClient should be a member
    // of the protocol that eventually owns network interface management
    // in general.
    GetDhcpClient(resource struct {
        nicid uint32;
        client server_end:fuchsia.net.dhcp.Client;
    }) -> (struct {}) error zx.status;
};
