## fi-0076: Fallible methods must have a response type {#fi-0076}

<!-- TODO(fxbug.dev/88366): Flexible but infallible methods also need a response
     type and should be documented here. -->

Fallible methods have a domain error specification. They must also specify
a response type, also known as a success type. In other words, the response type
cannot be absent:

{% include "docs/reference/fidl/language/error-catalog/label/_bad.md" %}

```fidl
{% includecode gerrit_repo="fuchsia/fuchsia" gerrit_path="tools/fidl/fidlc/tests/fidl/bad/error_method_absent_response.test.fidl" exclude_regexp="\/\/ (Copyright 20|Use of|found in).*" %}
```

If you would like to express that a response of a fallible method does not
hold any information, replace `()` with `(struct {})` instead:

{% include "docs/reference/fidl/language/error-catalog/label/_good.md" %}

```fidl
{% includecode gerrit_repo="fuchsia/fuchsia" gerrit_path="tools/fidl/fidlc/tests/fidl/good/error_method_empty_struct_response.test.fidl" exclude_regexp="\/\/ (Copyright 20|Use of|found in).*" %}
```

This is because under the hood, fallible methods wrap the response type and the
error type into a result union, which is sent by the server to indicate success
or failure. Because the syntax of FIDL prioritizes ABI concerns, and because
union members cannot be absent, the response type of a fallible method also
cannot be absent.

Note that the equivalent for infallible method responses is an absent response
payload, indicated by `MyMethod(...) -> ();`, instead of an empty struct such as
`MyMethod(...) -> (struct {});`. See [fi-0077](#fi-0077).

